<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Charlie</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-27T08:47:20.962Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Charlie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云计算总结</title>
    <link href="http://example.com/posts/7b9adefe/"/>
    <id>http://example.com/posts/7b9adefe/</id>
    <published>2024-06-14T02:06:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<p>判断题，20分：基本上都是对的<br>填空题：概念，架构<br>设计与计算<br>问答题</p><p><strong>概览</strong>和<strong>架构</strong>PPT一页一页看，55分左右</p><hr><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>考试重点在<strong>云计算概念</strong>，技术细节没那么重要</p><p>云计算特点：部署模型，服务模型</p><hr><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1. 定义"></a>1.1. 定义</h2><p>云计算是一种商业计算模型。它将计算任务分布在大量计算机构成的资源池上，使各种应用系统能够根据需要获取计算力、存储空间和信息服务。  </p><p>云计算是通过网络按需提供可动态伸缩的廉价计算服务。</p><p>核心：按需使用、按量计费；基础设施、平台、软件等所有IT资源均作为服务；</p><h2 id="1-2-本质"><a href="#1-2-本质" class="headerlink" title="1.2. 本质"></a>1.2. 本质</h2><p>本质：架构到资源的全面弹性</p><h2 id="1-3-演化"><a href="#1-3-演化" class="headerlink" title="1.3. 演化"></a>1.3. 演化</h2><ol><li>主机系统与集中计算</li><li><strong>效用计算</strong>：考虑后买主机成本高，将IT资源包装成可以度量的服务提供给用户<ul><li>只规定了计费使用的模式，没有IT资源管理方式的考虑</li></ul></li><li>客户机/服务器模式</li><li>集群计算</li><li><strong>服务计算</strong>：把所有的应用程序都作为服务提供，而不是购买软件<ul><li>不同服务相对独立，松散耦合，随意组合</li><li>重点是服务发现</li></ul></li><li>个人计算机与桌面计算</li><li>分布式计算</li><li>网格计算</li><li>软件即服务</li><li><strong>云计算：效用计算+服务计算</strong><ol><li>增强版的效用计算：不仅考虑计费，还考虑IT管理</li><li>更广泛的服务计算：不仅提供软件，还包括基础设施和平台。</li></ol></li></ol><h2 id="1-4-云计算发展的推动"><a href="#1-4-云计算发展的推动" class="headerlink" title="1.4. 云计算发展的推动"></a>1.4. 云计算发展的推动</h2><ol><li>网络带宽提升</li><li>技术成熟度</li><li>移动互联网的发展</li><li>数据中心的演变</li><li>经济因素：降低成本、节约资源、可持续发展</li><li>大数据：存储和计算大数据的需求</li></ol><h2 id="1-5-云计算特征和分类"><a href="#1-5-云计算特征和分类" class="headerlink" title="1.5. 云计算特征和分类"></a>1.5. 云计算特征和分类</h2><h3 id="1-5-1-概念模型"><a href="#1-5-1-概念模型" class="headerlink" title="1.5.1. 概念模型"></a>1.5.1. <span style="background:rgba(3, 135, 102, 0.2)">概念模型</span></h3><ol><li>各类用户：企业/政府/学术机构/个人</li><li>各种终端</li><li>按量付费的商业模式</li><li>简化的服务接口</li><li>公有云和私有云</li></ol><h3 id="1-5-2-特征"><a href="#1-5-2-特征" class="headerlink" title="1.5.2. 特征"></a>1.5.2. 特征</h3><ol><li>物理特征：超大规模</li><li>技术特征：虚拟化</li><li>商业特征：按需服务</li><li>使用特征：<ol><li>通用</li><li>高可伸缩性</li><li>极其廉价</li></ol></li><li>目标特征：高可靠性</li></ol><h3 id="1-5-3-部署模型"><a href="#1-5-3-部署模型" class="headerlink" title="1.5.3. 部署模型"></a>1.5.3. <span style="background:rgba(3, 135, 102, 0.2)">部署模型</span></h3><ol><li>公有云：由第三方提供者拥有的可公共访问的云环境</li><li>社区云：类似公有云，但访问被限定为特定的云用户社区</li><li>私有云：由一家组织单独拥有，利用云计算技术来访问组织内部的IT资源</li><li>混合云：由两种或多种不同云部署模型组成的云环境</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F19%2F20-44-36-bac6e2d57df8e405719c514469a7efe3-20240619204436-377243.png" alt="image.png"></p><h2 id="1-6-云服务模型"><a href="#1-6-云服务模型" class="headerlink" title="1.6. 云服务模型"></a>1.6. 云服务模型</h2><ol><li>软件作为服务 SaaS (Software as a Service)<ul><li>通过标准的Web浏览器或软件客户端访问云上的应用</li><li>如：Salesforce online CRM</li></ul></li><li>平台作为服务 PaaS (Platform as a Service)<ul><li>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具。</li><li>如：Google App Engine, Microsoft Windows Azure, 数据库、文件系统和应用运行环境</li></ul></li><li>基础设施作为服务 IaaS (Infrastructure as a Service)<ul><li>指通过虚拟机方式对外提供计算、存储和网络能力</li><li>如：Amazon EC2/S3</li></ul></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F19%2F21-00-05-7d1eecf830ddd1f4f1f3445966a08c82-20240619210004-5de36d.png" alt="image.png"></p><h2 id="1-7-云计算三元认知论"><a href="#1-7-云计算三元认知论" class="headerlink" title="1.7. 云计算三元认知论"></a>1.7. 云计算三元认知论</h2><ol><li>商业模式</li><li>计算范式：<ol><li>云体逻辑结构：具体落地的云平台逻辑结构——物理结构就是云数据中心计算+存储+通信</li><li>云栈逻辑结构：面向服务的云平台逻辑结构——物理结构就是管理系统的结构基础设施即服务，平台即服务，软件即服务</li></ol></li><li>实现方式：数据中心+云平台管理系统</li></ol><h1 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h1><ol><li>云计算架构：如何设计整体的结构，计算架构</li><li><strong>云计算架构的二维视角</strong></li><li>逻辑架构：<ul><li>云体，云数据中心</li><li>云栈，重点讲了openstack，<strong>分层</strong>，<strong>如何从技术角度构建</strong></li></ul></li><li>SOA<ul><li>SOA是什么</li><li>和云的关系</li></ul></li></ol><hr><h2 id="2-1-计算架构及演化"><a href="#2-1-计算架构及演化" class="headerlink" title="2.1. 计算架构及演化"></a>2.1. 计算架构及演化</h2><p><strong>架构</strong>(Architecture)是指系统或应用程序的设计和组织方式<br><strong>计算架构</strong>是指描述计算机系统功能、组织和实现的一组规则和方法</p><ol><li>中央集权架构：所有计算资源、业务逻辑集中在一台主机</li><li>客户机/服务器架构（C/S架构）：客户机承担少量计算和全部I/O任务，服务器承担主要计算任务</li><li>中间层架构：把业务逻辑和数据服务放在两台服务器上，本质还是C/S架构</li><li>浏览器/服务器架构（B/S架构）：客户端只显示和运行基于浏览器的脚本程序，Web服务器层屏蔽各中间件的差异，提供通用的用户访问界面</li><li>C/S和B/S混合架构</li><li>**面向服务的架构(SOA)**：将应用程序的不同功能单元（即服务）通过这些服务之间定义良好的接口和契约联系起来</li></ol><h2 id="2-2-SOA"><a href="#2-2-SOA" class="headerlink" title="2.2. SOA"></a>2.2. SOA</h2><ul><li><p><strong>SOA是什么</strong>：面向服务的体系结构SOA是一个组件模型，将应用程序的不同功能单元（即服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它独立于实现服务的硬件平台、操作系统和编程语言，使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。</p></li><li><p><strong>SOA和云的关系</strong>：</p><ol><li><strong>服务重用性和灵活性</strong>：SOA让IT系统变得更有弹性，以便更灵活、更快地响应不断改变的需求，解决“重用软件功能”的问题</li><li>云计算采用的是面向服务的计算架构</li></ol></li></ul><h2 id="2-3-云计算架构的二维视角"><a href="#2-3-云计算架构的二维视角" class="headerlink" title="2.3. 云计算架构的二维视角"></a>2.3. 云计算架构的二维视角</h2><p>最易于理解的二维视角：基础架构 + 应用程序； 两者分别视为：后端 （云组件） + 前端（给用户的服务）</p><p>进一步的分层架构：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F11-02-04-ff2342b92bac265fafd01af7910a2779-20240620110203-a0192e.png" alt="image.png"></p><ol><li>虚拟化层<ul><li>将硬件转换为统一的IT资源【可灵活拆分、统一计量、统一管理、软件定义的】</li><li>可以在不同的抽象层实现：应用层、操作系统层、体系结构层、硬件层</li></ul></li><li>Web服务层<ul><li>将云资源提供给客户的一种最方便的方式，解决大部分客户无法直接使用虚拟机的问题</li><li>支持面广，对客户端要求低，浏览器就可以访问，<strong>所有服务通过REST API提供</strong></li></ul></li><li>服务总线层<ul><li>中间件层，封装计算服务、数据存储、消息传递</li><li>分离用户与虚拟化层、连接用户与Web服务层</li></ul></li><li>客户机用户界面<ul><li>Web门户，把各种服务混搭集成在一个界面</li></ul></li></ol><h2 id="2-4-云计算的逻辑架构"><a href="#2-4-云计算的逻辑架构" class="headerlink" title="2.4. 云计算的逻辑架构"></a>2.4. 云计算的逻辑架构</h2><p>云体：云计算的物质基础，目前可以认为云体就是数据中心。包括了网络、服务器、交换机、电力等。<br>云栈：云平台，是在云上构建的运行环境。可以管理应用程序。如openstack。</p><h1 id="3-分布式计算"><a href="#3-分布式计算" class="headerlink" title="3. 分布式计算"></a>3. 分布式计算</h1><p>会有一点点涉及，不需要争对复习也能回答出来</p><p>虽然不考，但概念和云计算连接很紧密</p><h1 id="4-分布式存储"><a href="#4-分布式存储" class="headerlink" title="4. 分布式存储"></a>4. 分布式存储</h1><p>同上</p><p>考试几乎不涉及</p><h1 id="5-虚拟化技术"><a href="#5-虚拟化技术" class="headerlink" title="5. 虚拟化技术"></a>5. 虚拟化技术</h1><p>大概知道构建云的时候起到什么作用。</p><p><strong>虚拟化技术和云计算的关系</strong>？</p><p>云计算里面涉及<strong>哪些具体的虚拟化技术</strong>？云计算中需要对哪些资源进行虚拟化？</p><p>对计算资源做虚拟化时<strong>用到哪些具体的虚拟化产品</strong>？VMWare，XEN，docker，KVM<br>VMWare和docker的区别，分别属于哪种类型？</p><p>不需要知道实现，<strong>要知道类型</strong>  </p><p>虚拟化的<strong>角度和层级</strong>，是否依赖宿主操作系统<br>在实现虚拟化的时候是基于软件的完全虚拟化，还是半虚拟化，还是硬件辅助的虚拟化（知道概念）<br>裸机虚拟化，寄宿虚拟化<br>CPU，内存，I/O虚拟化<br>容器属于什么层级的虚拟化？</p><p><strong>云计算中的虚拟机迁移</strong>：迁移方案，对比  </p><hr><h2 id="5-1-云计算和虚拟化的关系？"><a href="#5-1-云计算和虚拟化的关系？" class="headerlink" title="5.1. 云计算和虚拟化的关系？"></a>5.1. 云计算和虚拟化的关系？</h2><ol><li>虚拟化是云计算的核心技术，但不是其专有技术。</li><li>云计算种虚拟化的核心思想利用软件或固件管理程序构成虚拟化层，<strong>把物理资源映射为虚拟资源</strong>。在虚拟资源上可以安装和部署<strong>多个虚拟机</strong>，<strong>实现多用户共享物理资源</strong>。</li></ol><h2 id="5-2-云计算里面涉及哪些具体的虚拟化技术？"><a href="#5-2-云计算里面涉及哪些具体的虚拟化技术？" class="headerlink" title="5.2. 云计算里面涉及哪些具体的虚拟化技术？"></a>5.2. 云计算里面涉及哪些具体的虚拟化技术？</h2><ul><li>硬件虚拟化：<ol><li>CPU虚拟化</li><li>内存虚拟化</li><li>I/O虚拟化</li></ol></li><li>操作系统虚拟化</li><li>网络虚拟化：基于主机，基于网络，基于存储设备</li><li>存储虚拟化：核心网，接入网，虚拟机网络</li></ul><h2 id="5-3-至少说出四个虚拟化产品"><a href="#5-3-至少说出四个虚拟化产品" class="headerlink" title="5.3. 至少说出四个虚拟化产品"></a>5.3. 至少说出四个虚拟化产品</h2><p>VMWare，XEN，docker，KVM，lxc</p><h2 id="5-4-虚拟化层级"><a href="#5-4-虚拟化层级" class="headerlink" title="5.4. 虚拟化层级"></a>5.4. 虚拟化层级</h2><ol><li>ISA级虚拟化</li><li>硬件级虚拟计划</li><li>操作系统级虚拟化</li><li>运行时库虚拟化</li><li>应用程序级虚拟化</li></ol><h2 id="5-5-虚拟化类型"><a href="#5-5-虚拟化类型" class="headerlink" title="5.5. 虚拟化类型"></a>5.5. 虚拟化类型</h2><p><strong>硬件仿真（裸机虚拟化）</strong>：Hypervisor直接对硬件切分和抽象，再安装客户操作系统<br><strong>寄居虚拟化</strong>：需要主机操作系统，再运行VMM（Virtual Machine Monitor，虚拟机监视器） ，再安装操作系统</p><p><strong>全虚拟化</strong>：Hypervisor或VMM负责控制硬件和“传话”<br><strong>类虚拟化（硬件辅助虚拟化）</strong>：不再以普通操作系统的方式访问虚拟硬件资源，需要修改操作系统</p><h2 id="5-6-VMWare和docker的区别，分别属于哪种类型？"><a href="#5-6-VMWare和docker的区别，分别属于哪种类型？" class="headerlink" title="5.6. VMWare和docker的区别，分别属于哪种类型？"></a>5.6. VMWare和docker的区别，分别属于哪种类型？</h2><ul><li><p>区别：虚拟机和容器的区别<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F12-05-48-ec7cbaf7a78c344fd7a3b05a98f4a832-20240620120547-d6bfc5.png" alt="image.png"></p></li><li><p>类型：都属于寄居虚拟化。</p></li></ul><h2 id="5-7-云计算中的虚拟机迁移"><a href="#5-7-云计算中的虚拟机迁移" class="headerlink" title="5.7. 云计算中的虚拟机迁移"></a>5.7. 云计算中的虚拟机迁移</h2><p>不仅仅是内存的迁移，还有网络，存储设备的迁移</p><ol><li>内存迁移<ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F12-16-55-c643a5f489444a631d43fc30a3fa1f1b-20240620121655-39ff21.png" alt="image.png"></li></ul></li><li>网络迁移<ul><li>虚拟机所有网络设备，包括协议状态（如TCP连接状态）以及IP地址都要随之一起迁移；通过发送并修改相关配置实现</li></ul></li><li>存储设备迁移<ul><li>以共享的方式共享数据和文件系统，而非真正迁移</li><li>目前大多数集群使用NAS（Network Attached Storage，网络连接存储）作为存储设备共享数据</li></ul></li></ol><h1 id="6-容器"><a href="#6-容器" class="headerlink" title="6. 容器"></a>6. 容器</h1><p>考试没什么内容</p><p>属于操作系统的虚拟化，和硬件级的虚拟化有什么区别</p><hr><h2 id="6-1-容器是什么级别的虚拟化？"><a href="#6-1-容器是什么级别的虚拟化？" class="headerlink" title="6.1. 容器是什么级别的虚拟化？"></a>6.1. 容器是什么级别的虚拟化？</h2><p>属于虚拟化层级中的<strong>操作系统虚拟化</strong></p><h2 id="6-2-容器和虚拟机的区别？"><a href="#6-2-容器和虚拟机的区别？" class="headerlink" title="6.2. 容器和虚拟机的区别？"></a>6.2. 容器和虚拟机的区别？</h2><ul><li>虚拟机：抽象并虚拟化计算机物理资源<ol><li>模拟计算机的整个物理基础设施，如磁盘、驱动器和服务器设备</li><li>操作系统级别的资源隔离</li></ol></li><li>容器：更轻量化的虚拟化技术<ol><li>模拟操作系统，而非硬件</li><li>进程级别的资源隔离</li></ol></li></ul><h1 id="7-网络"><a href="#7-网络" class="headerlink" title="7. 网络"></a>7. 网络</h1><p>唯一可以出<strong>计算题</strong>的部分，4种网络，需要计算和设计</p><p>会告诉实现的逻辑，不用背。</p><p>计算每一种类型的网络架构下，需要多少交换机，可以容纳多少台主机<br>要画出来再计算</p><hr><ul><li>改进型树结构：FatTree，VL2</li><li>递归层次结构：DCell，FiConn，BCube</li><li>光交换网络：Helios， OSA</li><li>无线数据中心网络：WDCN</li><li>软件定义网络：Openflow</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F20-30-04-ef6a52419564c67c49a79e5e1cb20ca4-20240620203004-a71a9e.png" alt="image.png"></p><h2 id="7-1-FatTree"><a href="#7-1-FatTree" class="headerlink" title="7.1. FatTree"></a>7.1. FatTree</h2><ol><li>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个接入交换机，K/2个汇聚交换机。</li><li>Pod中每个交换机有K个接口，<strong>K/2个接主机，K/2个接汇聚</strong>；<strong>K/2个接接入，K/2个接核心</strong>。</li><li>有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.022ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 3103.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1278,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1778,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="msup" transform="translate(2278,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mn" transform="translate(422,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>个核心交换机，每个交换机K个端口接K个汇聚交换机。</li><li>一个Pod内的所有交换机相互连接：完全二分图。</li><li>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接。<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F20-30-43-f0c545ef1a2baaa841df0807bf036c59-20240620203042-b54c5d.png" alt="image.png"></li></ol><p>但是，FatTree的扩展性受限于核心交换机端口数量，目前比较常用的是48端口10G核心交换机，在3层树结构中能够支持27648台主机。</p><h2 id="7-2-VL2"><a href="#7-2-VL2" class="headerlink" title="7.2. VL2"></a>7.2. VL2</h2><p>若干服务器连接到机架（接入）交换机<br>每台接入交换机与两台汇聚交换机连接<br>每台汇聚交换机与所有核心交换机连接</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F20-34-16-01cef43d0941e4624764d73332cfc7d1-20240620203416-256ed1.png" alt="image.png"></p><h2 id="7-3-DECell"><a href="#7-3-DECell" class="headerlink" title="7.3. DECell"></a>7.3. DECell</h2><p>构建高层次网络时，需要的低层网络的个数等于每个低层网络中的服务器个数加1。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F20-54-30-a172241c6c1c22f60b1266923bc726fd-20240620205429-b0ad87.png" alt="image.png"></p><h2 id="7-4-FiConn"><a href="#7-4-FiConn" class="headerlink" title="7.4. FiConn"></a>7.4. FiConn</h2><ul><li>服务器使用两个网卡端口：主用端口连接低层网络，备用端口连接高层网络</li><li>递归结构定义<ol><li>第0层为基本构建单元，n个服务器连接一个具有n个端口的交换机</li><li>每个低层FiConn中备用端口空闲的一半服务器与其他相同层次的FiConn网络中备用端口空闲的服务器连接</li><li><strong>k层服务器、k层端口、k层链路</strong></li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F20-48-13-c2bc942a15b9ef404f35f90989072cdf-20240620204812-c4834d.png" alt="image.png"></p><h2 id="7-5-BCube"><a href="#7-5-BCube" class="headerlink" title="7.5. BCube"></a>7.5. BCube</h2><p>主要使用交换机构建层次化网络<br>第0层：n服务器连接1交换机<br>第1层：n个0层连接n个交换机<br>……<br>第k层：n个k-1层连接nk交换机</p><p>交换机n个端口，服务器k+1个端口</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F20%2F20-51-28-35ba4e5e9909e9fe84047e90cb4949af-20240620205127-f9af1c.png" alt="image.png"></p><h1 id="8-云数据中心"><a href="#8-云数据中心" class="headerlink" title="8. 云数据中心"></a>8. 云数据中心</h1><ol><li><strong>绿色节能技术</strong>，有哪些措施？<ol><li>配电系统</li><li>空调系统</li><li>集装箱数据中心</li><li>管理系统节能策略和算法</li><li>新能源应用</li></ol></li><li><strong>容灾备份</strong>：使用哪些技术<ul><li>两个方法：数据容灾备份，应用容灾备份</li><li>核心思想：复制数据</li><li>镜像、快照</li><li>其他：基于IP的san技术，数据库的复制技术</li></ul></li></ol><h1 id="9-OpenStack"><a href="#9-OpenStack" class="headerlink" title="9. OpenStack"></a>9. OpenStack</h1><p>理解组件之间如何协作，不仅仅是理论上，实际部署的时候怎么通过网络协作，作为基础架构的服务</p><p>出题例如，绘制OpenStack上部署服务的概念图</p><hr><p>OpenStack是一个管理云计算中计算、存储和网络，甚至是应用的通用平台，其提供Web界面、命令行工具和应用程序接口（API）等使用接口。</p><h2 id="9-1-节点类型"><a href="#9-1-节点类型" class="headerlink" title="9.1. 节点类型"></a>9.1. 节点类型</h2><ol><li>云控制器<ol><li>Keystone: 提供身份认证和服务目录</li><li>Nova: openstack中提供计算资源服务的项目，负责虚拟机和其他计算资源的生命周期管理</li></ol></li><li>存储节点<ol><li>swift对象存储</li><li>cinder块存储</li></ol></li><li>计算节点<ol><li>nova-compute负责启动和终止虚拟机，通过消息总线监听虚拟机的相关请求</li><li>nova-compute通过api server控制hypervisor</li></ol></li><li>网络节点<ol><li>nerutron组件</li></ol></li></ol><p>四种节点通过网络连接在一起</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F14%2F11-02-20-ec1653518bd49190a90cfcba346a8c81-20240614110218-8e3862.png" alt="image.png"></p><h2 id="9-2-不同类型的节点通过什么网络连接？"><a href="#9-2-不同类型的节点通过什么网络连接？" class="headerlink" title="9.2. 不同类型的节点通过什么网络连接？"></a>9.2. 不同类型的节点通过什么网络连接？</h2><ul><li>四种节点如何通过物理网络连接在一起？<ol><li>管理网络：Openstack服务之间的通信，包括消息队列、数据库和API</li><li>租户数据网络：为租户创建的虚拟网络提供物理路径</li><li>存储网络：虚拟机和存储节点之间的物理连接</li><li>对外的网络：互联网连接+对外的API网络</li></ol></li><li>使用隔离的物理网络处理不同类型的网络流量：同一个节点在不同网络中使用不同接口</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F14%2F11-03-36-5637f682906edaa1f8bfa9892e720df1-20240614110334-902fb1.png" alt="image.png"></p><h1 id="10-云计算安全"><a href="#10-云计算安全" class="headerlink" title="10. 云计算安全"></a>10. 云计算安全</h1><p>这部分不做要求</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_云计算" scheme="http://example.com/categories/2024-Spring-%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="2024_Spring_云计算" scheme="http://example.com/tags/2024-Spring-%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>软件系统设计-pmx期末</title>
    <link href="http://example.com/posts/e8fd03f1/"/>
    <id>http://example.com/posts/e8fd03f1/</id>
    <published>2024-06-11T07:06:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-重点"><a href="#1-重点" class="headerlink" title="1. 重点"></a>1. 重点</h1><h2 id="1-1-题型"><a href="#1-1-题型" class="headerlink" title="1.1. 题型"></a>1.1. 题型</h2><ul><li>简答题<ol><li>设计原则之间的关系</li><li>设计模式之间的关系</li><li>设计原则和设计模式之间的关系</li><li>架构分析方法和概念</li></ol></li><li>设计题：<ul><li>给出一个设计问题，回答设计方案</li><li>设计两三个设计模式联合设计</li></ul></li></ul><h2 id="1-2-软件模式"><a href="#1-2-软件模式" class="headerlink" title="1.2. 软件模式"></a>1.2. 软件模式</h2><ul><li>软件模式是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 </li><li>软件模式可以认为是对软件开发这一特定“问题”的“解法”的某种统一表示，软件模式等于一定条件下的出现的问题以及解法。</li><li>基础结构：<ol><li>问题描述</li><li>前提条件（环境或约束条件）</li><li>解法</li><li>效果</li></ol></li><li>软件模式与具体的应用领域无关，在模式发现过程中 需要遵循大三律(Rule of Three)，即<strong>只有经过三个以 上不同类型（或不同领域）的系统的校验</strong>，一个解决方案才能从候选模式升格为模式</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F23%2F20-26-19-94266b2710747a44725e64bb98b895b9-20240623202619-b2202d.png" alt="image.png"></p><h2 id="1-3-设计模式"><a href="#1-3-设计模式" class="headerlink" title="1.3. 设计模式"></a>1.3. 设计模式</h2><h3 id="1-3-1-基本要素"><a href="#1-3-1-基本要素" class="headerlink" title="1.3.1. 基本要素"></a>1.3.1. 基本要素</h3><ol><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果：可以作为约束条件的一部分</li></ol><h3 id="1-3-2-分类"><a href="#1-3-2-分类" class="headerlink" title="1.3.2. 分类"></a>1.3.2. 分类</h3><ul><li><p>目的</p><ol><li>创建型：创建对象</li><li>结构型：处理类和对象的组合</li><li>行为型：描述对类或对象怎样交互和怎样分配职责</li></ol></li><li><p>范围</p><ol><li>类模式：式处理类和子类之间的关系，这些关系通过继承建立， 在编译时刻就被确定下来，是属于<strong>静态</strong>的。</li><li>对象模式：处理对象间的关系，这些关系在运行时刻变化，更具<strong>动态</strong>性</li></ol></li><li><p>模式和模式的变体，不同</p></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F19%2F14-03-56-f7eba1b50144117a2d8052de51950d35-20240619140355-d9b953.png" alt="image.png"></p><h3 id="1-3-3-设计模式与类库框架"><a href="#1-3-3-设计模式与类库框架" class="headerlink" title="1.3.3. 设计模式与类库框架"></a>1.3.3. 设计模式与类库框架</h3><ul><li>为什么不设计一个设计模式的库？<ul><li>设计模式比库更高层。设计模式告诉我们怎么构建类和对象来解决特定问题，我们需要做的是使用这些原则来适应具体的应用。</li></ul></li><li>库和框架是不是设计模式？<ul><li>框架和类不是设计模式。它们提供了可以连接到代码中的具体实现。但是优势库和框架会在它们的实现中应用设计模式。如果你理解了设计模式，你可以更快理解框架和库的API。</li></ul></li></ul><h2 id="1-4-设计原则"><a href="#1-4-设计原则" class="headerlink" title="1.4. 设计原则"></a>1.4. 设计原则</h2><p>设计原则之间的关系</p><ul><li>目标：<ol><li>可复用</li><li>可维护</li></ol></li><li>设计原则<ol><li><strong>单一职责原则</strong>要求在软件系统中，一个类只负责一个功能领域中的相应职责。</li><li><strong>开闭原则</strong>要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</li><li><strong>里氏代换原则</strong>可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</li><li><strong>依赖倒转原则</strong>要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。</li><li><strong>接口隔离原则</strong>要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</li><li><strong>合成复用原则</strong>要求复用时尽量使用对象组合，而不使用继承。</li><li><strong>迪米特法则</strong>要求一个软件实体应当尽可能少的与其他实体发生相互作用。</li></ol></li><li>目标：开闭原则</li><li>指导：最小知识原则/迪米特</li><li>基础：单一职责原则、封装可变性原则</li><li>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li></ul><h1 id="2-整理"><a href="#2-整理" class="headerlink" title="2. 整理"></a>2. 整理</h1><h2 id="2-1-设计原则之间的关系"><a href="#2-1-设计原则之间的关系" class="headerlink" title="2.1. 设计原则之间的关系"></a>2.1. 设计原则之间的关系</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F23%2F11-22-54-d0863b5868bc217b2df809f178845bd0-20240623112253-38708f.png" alt="image.png"></p><ul><li>目标：开闭原则</li><li>指导：最小知识原则/迪米特</li><li>基础：单一职责原则、封装可变性原则</li><li>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li></ul><h2 id="2-2-设计模式和设计原则的关系"><a href="#2-2-设计模式和设计原则的关系" class="headerlink" title="2.2. 设计模式和设计原则的关系"></a>2.2. 设计模式和设计原则的关系</h2><h3 id="2-2-1-策略模式"><a href="#2-2-1-策略模式" class="headerlink" title="2.2.1. 策略模式"></a>2.2.1. 策略模式</h3><ul><li>使用原则：<ol><li>单一职责</li><li>依赖倒转</li><li>合成复用</li></ol></li></ul><h3 id="2-2-2-简单工厂模式"><a href="#2-2-2-简单工厂模式" class="headerlink" title="2.2.2. 简单工厂模式"></a>2.2.2. 简单工厂模式</h3><ul><li>使用原则<ol><li>最小知识原则：构造方法无法抽象但是可以封装</li><li>依赖倒转原则：工厂返回产品的抽象类，降低与产品具体创建方法的耦合</li></ol></li><li>违反：<ul><li>开闭原则：增加新的产品需要修改工厂类判断逻辑</li></ul></li></ul><h3 id="2-2-3-工厂方法模式"><a href="#2-2-3-工厂方法模式" class="headerlink" title="2.2.3. 工厂方法模式"></a>2.2.3. 工厂方法模式</h3><ul><li>使用原则<ol><li>依赖倒置</li><li>单一职责</li></ol></li><li>对开闭原则支持很好</li></ul><h3 id="2-2-4-抽象工厂模式"><a href="#2-2-4-抽象工厂模式" class="headerlink" title="2.2.4. 抽象工厂模式"></a>2.2.4. 抽象工厂模式</h3><ul><li>使用原则<ol><li>依赖倒转原则：有抽象工厂类和产品类</li><li>单一职责原则：每个具体工厂只生产一个具体产品族</li></ol></li><li><strong>开闭原则的倾斜性</strong><ul><li><strong>增加新的具体工厂和产品族很方便</strong>，符合开闭原则</li><li>不能完全支持开闭原则，<font color="#c00000">需要增加新的产品等级结构时需要修改抽象类</font></li></ul></li></ul><h3 id="2-2-5-原型模式"><a href="#2-2-5-原型模式" class="headerlink" title="2.2.5. 原型模式"></a>2.2.5. 原型模式</h3><p>好像没有使用什么原则？</p><ul><li>违背开闭原则：<strong>需要为每一个类配备一个克隆方法</strong>，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难。但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码</li></ul><h3 id="2-2-6-状态模式"><a href="#2-2-6-状态模式" class="headerlink" title="2.2.6. 状态模式"></a>2.2.6. 状态模式</h3><ul><li>使用原则<ol><li>依赖倒转原则</li><li>单一职责原则：把不同状态下的行为封装到单一状态类里</li></ol></li><li>开闭原则支持不好：增加新的状态要修改负责状态转换的源代码。</li></ul><h3 id="2-2-7-命令模式"><a href="#2-2-7-命令模式" class="headerlink" title="2.2.7. 命令模式"></a>2.2.7. 命令模式</h3><ul><li>使用原则<ol><li>单一职责原则：解耦触发和执行命令的类</li></ol></li><li>开闭原则：可以在不修改客户端原有代码的情况下创建新的命令</li></ul><h3 id="2-2-8-中介者模式"><a href="#2-2-8-中介者模式" class="headerlink" title="2.2.8. 中介者模式"></a>2.2.8. 中介者模式</h3><ul><li>使用原则<ol><li>单一职责</li><li>最小知识原则：减少对象之间互相持有引用，</li></ol></li><li>开闭原则支持好</li></ul><h3 id="2-2-9-观察者模式"><a href="#2-2-9-观察者模式" class="headerlink" title="2.2.9. 观察者模式"></a>2.2.9. 观察者模式</h3><ul><li>使用原则<ol><li>最小知识原则：实现了观察者和目标对象的松耦合</li><li>单一职责原则：观察目标集中管理数据，观察者只有行为职责</li><li>合成复用原则：变更管理器中使用。</li></ol></li><li>开闭原则：支持好</li></ul><h3 id="2-2-10-模板方法模式"><a href="#2-2-10-模板方法模式" class="headerlink" title="2.2.10. 模板方法模式"></a>2.2.10. 模板方法模式</h3><ul><li>使用原则<ol><li>单一职责：每个不同实现都需要定义子类</li></ol></li><li>开闭原则：支持好，扩展新的行为只需要增加子类</li></ul><h3 id="2-2-11-适配器模式"><a href="#2-2-11-适配器模式" class="headerlink" title="2.2.11. 适配器模式"></a>2.2.11. 适配器模式</h3><ul><li>使用原则<ol><li>单一职责：适配器只负责接口转换的职责</li><li>依赖倒转：客户端与适配器接口交互</li><li>合成复用：对象适配器使用组合复用原则。</li></ol></li><li>开闭原则支持好：只要客户端代码通过接口与适配器进行交互， 就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li></ul><h3 id="2-2-12-组合模式"><a href="#2-2-12-组合模式" class="headerlink" title="2.2.12. 组合模式"></a>2.2.12. 组合模式</h3><ul><li>使用原则<ol><li>依赖倒转：使用抽象的componet接口，实现递归结构</li></ol></li><li>开闭原则支持好：无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</li><li>违反最小接口原则：leaf和composite都会继承一些不属于自己的方法</li></ul><h3 id="2-2-13-装饰器模式"><a href="#2-2-13-装饰器模式" class="headerlink" title="2.2.13. 装饰器模式"></a>2.2.13. 装饰器模式</h3><ul><li>使用原则<ol><li>里氏代换</li><li>依赖倒转</li><li>单一职责</li><li>接口隔离：装饰器模式通过定义具体的装饰器类来实现特定的行为，而不是强迫客户端依赖于它们不需要的接口。</li></ol></li><li><strong>符合开闭原则</strong>，具体构件类和具体装饰器类可以独立变化</li></ul><h3 id="2-2-14-外观模式"><a href="#2-2-14-外观模式" class="headerlink" title="2.2.14. 外观模式"></a>2.2.14. 外观模式</h3><ul><li>使用原则<ol><li>最小知识原则：简化接口，对用户屏蔽子系统</li><li>单一职责原则：作为各个子系统的单一入口</li></ol></li><li>违反开闭原则：在不引入抽象类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码<ul><li>但抽象外观类不违反开闭原则</li></ul></li></ul><h2 id="2-3-GUI界面使用哪些设计模式？"><a href="#2-3-GUI界面使用哪些设计模式？" class="headerlink" title="2.3. GUI界面使用哪些设计模式？"></a>2.3. GUI界面使用哪些设计模式？</h2><ol><li><p>命令模式：GUI对象给业务逻辑对象发请求执行一些逻辑</p><ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F23%2F15-23-40-e03f2709770c5dce4e1aa23be3920ae4-20240623152339-81aaeb.png" alt="image.png"></li></ul></li><li><p>观察者模式: MVC使用了观察者模式</p></li><li><p>组合模式：GUI界面的元素可以嵌套，呈现树状结构</p></li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>软件质量管理-期末</title>
    <link href="http://example.com/posts/ac2f1649/"/>
    <id>http://example.com/posts/ac2f1649/</id>
    <published>2024-06-11T03:06:00.000Z</published>
    <updated>2024-06-27T08:47:20.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-过程线"><a href="#1-过程线" class="headerlink" title="1. 过程线"></a>1. 过程线</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1. 概念"></a>1.1. 概念</h2><p>[[01-软件质量管理概述]]</p><ul><li>管理是什么？  <ul><li>复现别人的成功</li></ul></li><li>管理的三要素<ol><li>目标：典型三大目标，成本、质量、工期</li><li>状态：在接近目标还是远离目标</li><li>纠偏</li></ol></li><li>管理的软件工程视角：<font color="#ff0000">成功是否可以复制？</font><ul><li>软件过程：为了实现一个或多个事先定义的目标而建立起来的一组实践的集合。这组实践之间往往有一定的先后顺序，作为一个整体来实现事先定义的一个或多个目标。</li><li>生命周期模型：对软件过程的一种人为划分</li></ul></li><li>软件过程vs软件生命周期模型<ol><li>迭代式<ul><li>![[02-历史与演变#5.2.1. 迭代式开发]]</li></ul></li><li>瀑布模型<ul><li>![[02-历史与演变#4.2.1. 瀑布模型]]</li></ul></li></ol></li></ul><h2 id="1-2-软件过程管理"><a href="#1-2-软件过程管理" class="headerlink" title="1.2. 软件过程管理"></a>1.2. 软件过程管理</h2><ul><li><p>PDCA和IDEAL：元模型</p><ul><li>![[02-历史与演变#PDCA模型]]</li><li>![[02-历史与演变#IDEAL模型]]</li></ul></li><li><p>CMM/CMMI  </p><ul><li>![[02-历史与演变#4.2.2. 成熟度模型]]</li></ul></li></ul><h2 id="1-3-软件工程演变的历史视角"><a href="#1-3-软件工程演变的历史视角" class="headerlink" title="1.3. 软件工程演变的历史视角"></a>1.3. 软件工程演变的历史视角</h2><p>[[02-历史与演变]]</p><ul><li>软件危机和软件工程</li><li>三大阶段<ul><li>敏捷宣言</li><li>![[02-历史与演变#5.2.2. 敏捷开发]]</li></ul></li><li>驱动力：本质难题</li></ul><h1 id="2-项目管理线"><a href="#2-项目管理线" class="headerlink" title="2. 项目管理线"></a>2. 项目管理线</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1. 概念"></a>2.1. 概念</h2><p><strong>三大目标</strong>：成本、时间、质量</p><h2 id="2-2-团队动力学"><a href="#2-2-团队动力学" class="headerlink" title="2.2. 团队动力学"></a>2.2. 团队动力学</h2><p>[[03-团队动力学]]</p><ul><li>知识工作的特点<ul><li>知识工作管理：不能被管理，而是自管理</li><li>领导者和特点</li><li>不同激励方式<ul><li>马斯洛需求层次理论</li><li>期望理论</li></ul></li></ul></li><li>自主团队<ul><li>内外部环境</li><li>TSP角色和职责<ul><li>![[03-团队动力学#2.2.3. 典型的TSP角色和职责]]</li></ul></li><li>TSP启动过程<ul><li>![[03-团队动力学#2.2.2. 启动会议/九次会议]]</li></ul></li><li>SCRUM角色和职责<ul><li>![[03-团队动力学#2.3. SCRUM团队]]]</li></ul></li></ul></li></ul><h2 id="2-3-估算和计划"><a href="#2-3-估算和计划" class="headerlink" title="2.3. 估算和计划"></a>2.3. 估算和计划</h2><ul><li><strong>估算要点</strong><ul><li>估算目的是什么：<strong>团队达成一致</strong></li><li>抽象、相对的估算</li></ul></li><li>PROBE估算方法，相对大小矩阵<ul><li>![[04-估算、计划和跟踪#1.3. PROBE估算方法]]</li></ul></li><li>SCRUM故事点<ul><li>![[04-估算、计划和跟踪#1.4. SCRUM中的Story point]]</li></ul></li><li>通用计划框架：正推<ul><li>![[04-估算、计划和跟踪#2.3. 通用计划框架]]</li></ul></li><li>各类计划<ul><li>质量管理</li><li>风险</li></ul></li><li>定量管理计划：自顶向下<ul><li>过程模型 </li><li>过程能力基线</li><li>过程组合<ul><li>关键子过程性能目标</li><li>整体过程性能目标</li></ul></li></ul></li></ul><p>![[08-定量管理与仿真建模]]</p><h2 id="2-4-跟踪"><a href="#2-4-跟踪" class="headerlink" title="2.4. 跟踪"></a>2.4. 跟踪</h2><ul><li>挣值管理：相对保守，完成才能拿到  <ul><li>简单，中级和高级</li><li>变形：燃尽图</li><li>为何适应软件项目</li></ul></li><li>定量管理的跟踪：自底向上<ul><li>关键子过程性能控制</li></ul></li></ul><h3 id="2-4-1-挣值管理"><a href="#2-4-1-挣值管理" class="headerlink" title="2.4.1. 挣值管理"></a>2.4.1. 挣值管理</h3><p>![[04-估算、计划和跟踪#2.6. 挣值管理方法]]</p><h3 id="2-4-2-定量管理跟踪"><a href="#2-4-2-定量管理跟踪" class="headerlink" title="2.4.2. 定量管理跟踪"></a>2.4.2. 定量管理跟踪</h3><p>关键子过程性能控制</p><h1 id="3-质量管理线"><a href="#3-质量管理线" class="headerlink" title="3. 质量管理线"></a>3. 质量管理线</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1. 概念"></a>3.1. 概念</h2><ul><li>关键质量管理的挑战：从管理三要素看，质量管理很困难</li><li>面向用户的质量观 <ul><li>![[05-质量管理#1.2. 面向用户的质量观]]</li></ul></li><li>质量管理策略和背后逻辑<ul><li>![[05-质量管理#1.3. PSP质量策略]]</li></ul></li></ul><h2 id="3-2-评审"><a href="#3-2-评审" class="headerlink" title="3.2. 评审"></a>3.2. 评审</h2><ul><li>个人评审<ul><li>关键控制因素</li><li>时机选择</li></ul></li><li>小组<ul><li>过程质量控制方式</li></ul></li></ul><h2 id="3-3-质量评审指标"><a href="#3-3-质量评审指标" class="headerlink" title="3.3. 质量评审指标"></a>3.3. 质量评审指标</h2><ol><li>Yield</li><li>A/FR</li><li>PQI</li><li>DRL</li><li><strong>特点和用途</strong></li></ol><p>![[05-质量管理#1.5. 质量指标]]</p><h2 id="3-4-质量路线图"><a href="#3-4-质量路线图" class="headerlink" title="3.4. 质量路线图"></a>3.4. 质量路线图</h2><ul><li>Journey:顺序：<ul><li>![[05-质量管理#1.6. 质量路径]]</li></ul></li><li>设计：<ul><li>模板:要哪些信息<ul><li>![[05-质量管理#2.4. PSP设计模板]]</li></ul></li><li>设计的层次</li></ul></li><li>设计评审 [[05-质量管理#2.6. 设计验证方法]]<ul><li><strong>状态机</strong>：检查状态机的完整性和正交性</li><li>符号化执行：用符号替换关键的变量，带入伪码程序，分析行为<ul><li>优点：<ol><li>实施简单，可以给出一般化结果</li><li>适合不复杂的算法，特别是遗漏系统改造中，应用这种方法世界和理解原有的设计</li></ol></li><li>缺点：<ol><li>不适合复杂逻辑的场景</li><li>纯手工验证容易出错</li></ol></li></ul></li><li><strong>执行表</strong><ul><li>优点：实施简单；结果可靠，可用于验证复杂逻辑</li><li>缺点：每次只能验证一个用例；手工验证比较耗时，容易引入错误</li></ul></li><li><strong>跟踪表</strong><ul><li>使用符号或以及用例识别等方式对程序进行一般化验证，<strong>是对执行表的补充</strong>，一次可以验证多个样例</li></ul></li><li><strong>正确性证明</strong><ul><li>将伪码当作数学定理，用形式化方法加以推理和验证</li></ul></li></ul></li></ul><h1 id="4-工程技术线"><a href="#4-工程技术线" class="headerlink" title="4. 工程技术线"></a>4. 工程技术线</h1><h2 id="4-1-需求"><a href="#4-1-需求" class="headerlink" title="4.1. 需求"></a>4.1. 需求</h2><p>客户需求<br>产品需求<br>![[06-团队工程开发#1.2. 需求分类]]</p><p>产品经理</p><h2 id="4-2-设计"><a href="#4-2-设计" class="headerlink" title="4.2. 设计"></a>4.2. 设计</h2><ul><li>自顶向下<ul><li><strong>自顶向下</strong>，逐层精化，有利于建立系统的整体观；利于评审</li></ul></li><li>考虑点<ul><li>团队智慧的运用</li><li>设计标准</li><li>Design for reuse</li><li>可测试性支持</li><li>可用性支持</li><li>![[06-团队工程开发#2.2. 设计考虑点]]</li></ul></li></ul><h2 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3. 实现"></a>4.3. 实现</h2><ul><li>考虑点<ol><li>为了实现评审</li><li>复用，自底向上实现</li><li>可测试性考虑<br>![[06-团队工程开发#2.3. 实现策略]]</li></ol></li></ul><h2 id="4-4-基础"><a href="#4-4-基础" class="headerlink" title="4.4. 基础"></a>4.4. 基础</h2><ul><li>覆盖范围</li><li>基本策略：每一种策略的优缺点、<ol><li>大爆炸</li><li>逐一添加</li><li>集族式</li><li>扁平化</li></ol></li></ul><p>![[06-团队工程开发#3. 集成的策略选择]]</p><h2 id="4-5-V-V"><a href="#4-5-V-V" class="headerlink" title="4.5. V&V"></a>4.5. V&amp;V</h2><ul><li>概念和区别<ul><li>verification验证：产品需求<ul><li>检验获得的产品和产品组件能不能满足各自事先定义好的需求规格</li></ul></li><li>validtion确认：客户需求<ul><li>确保产品可以满足客户需求以及实际操作场景的要求</li></ul></li></ul></li></ul><p>![[06-团队工程开发#4. 验证和确认(V &amp; V)]]</p><h1 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h1><h2 id="5-1-配置管理"><a href="#5-1-配置管理" class="headerlink" title="5.1. 配置管理"></a>5.1. 配置管理</h2><p>配置项<br>基线</p><p>![[07-项目支持活动#1.1. 配置管理介绍]]</p><h2 id="5-2-度量和分析"><a href="#5-2-度量和分析" class="headerlink" title="5.2. 度量和分析"></a>5.2. 度量和分析</h2><p>GQM度量体系</p><p>![[07-项目支持活动#2.2. GQM方法]]</p><h2 id="5-3-决策分析与解决方案"><a href="#5-3-决策分析与解决方案" class="headerlink" title="5.3. 决策分析与解决方案"></a>5.3. 决策分析与解决方案</h2><p>招投标<br>![[07-项目支持活动#3. 决策分析]]</p><h2 id="5-4-根因分析与解决方案"><a href="#5-4-根因分析与解决方案" class="headerlink" title="5.4. 根因分析与解决方案"></a>5.4. 根因分析与解决方案</h2><p>2-8发展，用来选择问题，选出分析项<br>鱼骨图，归因</p><p>![[07-项目支持活动#4. 根因分析与解决方案]]</p><h1 id="6-往年题"><a href="#6-往年题" class="headerlink" title="6. 往年题"></a>6. 往年题</h1><p><a class="link" href="https://blog.csdn.net/weixin_45916384/article/details/129141112">2022软件质量与管理-考题复习_软件管理中的phase yield例题-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="6-1-软件项目管理和软件过程管理"><a href="#6-1-软件项目管理和软件过程管理" class="headerlink" title="6.1. 软件项目管理和软件过程管理"></a>6.1. 软件项目管理和软件过程管理</h2><ul><li>软件项目管理是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程</li><li>软件过程管理是为了让软件过程在开发效率、质量等方面有着更好性能绩效</li></ul><h2 id="6-2-生命周期模型与软件过程的区别和联系"><a href="#6-2-生命周期模型与软件过程的区别和联系" class="headerlink" title="6.2. 生命周期模型与软件过程的区别和联系"></a>6.2. 生命周期模型与软件过程的区别和联系</h2><ol><li>生命周期模型是对一个软件开发过程的人为划分</li><li>生命周期模型是软件开发过程的框架，是对软件开发过程的一种粗粒度划分</li><li>生命周期模型往往不包括技术实践</li></ol><h2 id="6-3-2020-结合软件发展的三大阶段，描述不同阶段的典型软件开发方法和实践"><a href="#6-3-2020-结合软件发展的三大阶段，描述不同阶段的典型软件开发方法和实践" class="headerlink" title="6.3. [2020]结合软件发展的三大阶段，描述不同阶段的典型软件开发方法和实践"></a>6.3. [2020]结合软件发展的三大阶段，描述不同阶段的典型软件开发方法和实践</h2><ol><li>软硬件一体化：线性顺序过程，实质上是硬件开发流程；measure twice, cut once；code anf fix</li><li>软件成为独立产品：结构化程序设计，瀑布模型，成熟度模型</li><li>网络化和服务化：迭代式开发，敏捷运动，开源软件开发，devops</li></ol><h2 id="6-4-2018-软件项目管理和软件过程管理"><a href="#6-4-2018-软件项目管理和软件过程管理" class="headerlink" title="6.4. [2018]软件项目管理和软件过程管理"></a>6.4. [2018]软件项目管理和软件过程管理</h2><ul><li>软件项目管理是使用方法、工具、技术以及人员能力等完成软件项目，实现项目目标的过程</li><li>软件过程管理是为了让软件过程在开发效率、质量等方面有着更好的性能绩效</li></ul><h2 id="6-5-生命周期模型与软件过程的区别和联系"><a href="#6-5-生命周期模型与软件过程的区别和联系" class="headerlink" title="6.5. 生命周期模型与软件过程的区别和联系"></a>6.5. 生命周期模型与软件过程的区别和联系</h2><ol><li>软件生命周期模型是对软件过程的人为划分</li><li>生命周期模型是软件开发过程的框架，是对软件过程的一种粗粒度划分</li><li>生命周期模型往往不包含技术实践</li></ol><h2 id="6-6-如何理解瀑布模型"><a href="#6-6-如何理解瀑布模型" class="headerlink" title="6.6. 如何理解瀑布模型"></a>6.6. 如何理解瀑布模型</h2><ol><li>瀑布模型不是单一模型，而是一些列模型，覆盖最简单的场景到最复杂的场景</li><li>软件项目应该结合实际情况选择合适过程元素的瀑布模型，基本原则是，项目面临的困难越多选择的模型越复杂</li><li>软件项目团队往往低估挑战，选择过于简单而不适应的瀑布模型</li></ol><h2 id="6-7-Schedule-plan"><a href="#6-7-Schedule-plan" class="headerlink" title="6.7. Schedule plan"></a>6.7. Schedule plan</h2><ol><li>Task Order</li><li>Schedule Hour</li><li>Task List</li><li>Task hour for each task</li></ol><p>不包含Task Size</p><h2 id="6-8-谈谈你对项目估算的认识，并简要解释应用-PROBE-方法估算的优缺点"><a href="#6-8-谈谈你对项目估算的认识，并简要解释应用-PROBE-方法估算的优缺点" class="headerlink" title="6.8. 谈谈你对项目估算的认识，并简要解释应用 PROBE 方法估算的优缺点"></a>6.8. 谈谈你对项目估算的认识，并简要解释应用 PROBE 方法估算的优缺点</h2><ul><li>对估算的认识：<ol><li>规模估算往往可以根据历史数据来完成，其原因在于规模估算结果的偏差产生原因相对客观，历史数据偏差可以用以修正新的估算结果</li><li>时间估算的偏差产生原因更加复杂，一方面和规模有关，另一方面和人的主观能动性有关，因此，时间估算偏差的原因可能在于估算结果本身，这是的历史数据中的时间偏差参考价值不大</li><li>估算本身是一种猜测，追求的目标应该是一致性以及估算结果的使用者对估算结果的信心</li></ol></li><li>PROBE优缺点：<ul><li>PROBE估算方法通过定义的估算过程和数据收集以及使用框架，使得估算结果可以尽可能一致，从而使得一些统计方法可以用来调整估算结果，增强用户对估算结果的信心</li><li>但是这种估算方法非常依赖高质量的历史数据，一旦数据不完整或缺失，就可能导致估算结果有显著的偏差</li></ul></li></ul><h2 id="6-9-PROBE方法估算时间的时候，为什么不使用历史数据中的生产效率数据？"><a href="#6-9-PROBE方法估算时间的时候，为什么不使用历史数据中的生产效率数据？" class="headerlink" title="6.9. PROBE方法估算时间的时候，为什么不使用历史数据中的生产效率数据？"></a>6.9. PROBE方法估算时间的时候，为什么不使用历史数据中的生产效率数据？</h2><p>在估算资源（如人时）时候，生产效率一般在分母上，考虑到个体软件工程师生产效率的波动，易导致估算的偏差范围变大。</p><h2 id="6-10-请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？"><a href="#6-10-请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？" class="headerlink" title="6.10. 请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？"></a>6.10. 请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？</h2><ul><li>软件开发是一项非常复杂又具有创造力的知识工作。</li><li>软件开发是一种智力活动，开发者是智力劳动者，对智力劳动者不能被管理，只能自我管理。<ol><li>处理和讨论非常抽象的概念</li><li>把不同部分整合成一个可以工作的正确的系统</li><li>全身心地参与</li><li>努力做出卓越的工作</li></ol></li><li>自主团队的特点<ol><li>自行定义项目的目标</li><li>自行决定团队组成形式和成员角色</li><li>自行决定项目的开发策略</li><li>自行定义项目的开发过程</li><li>自行制定项目的开发计划</li><li>自行度量、管理和控制项目工作</li></ol></li></ul><h2 id="6-11-知识工作者的领导的特点"><a href="#6-11-知识工作者的领导的特点" class="headerlink" title="6.11. 知识工作者的领导的特点"></a>6.11. 知识工作者的领导的特点</h2><ol><li>善于倾听团队成员的想法，并加以分析和改进</li><li>善于通过询问诱导团队成员向着正确的方向前进</li><li>善于通过激励以及设定挑战目标等方式吸引团队成员努力表现</li><li>当出现不一致的意见时，领导者善于提供各种沟通方式，促使团队达成一致意见</li><li>培养团队成员技能</li><li>鼓励建立合理的授权机制</li><li>通过挑战建立目标，确定团队努力方向</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>08-定量管理与仿真建模</title>
    <link href="http://example.com/posts/b20937f7/"/>
    <id>http://example.com/posts/b20937f7/</id>
    <published>2024-06-11T02:06:00.000Z</published>
    <updated>2024-06-27T08:47:20.966Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#c00000">不是有数据就叫定量管理</font></p><p>定量管理：有预测模型，根据最终结果判断</p><p>CMMI的4、5级都有预测模型，属于定量管理，1、2、3级只能算一般项目管理</p><ul><li>过程模型</li><li>过程能力基线</li><li>过程组合<ul><li>关键子过程性能目标</li><li>整体过程性能目标</li></ul></li></ul><h1 id="1-定量管理范式"><a href="#1-定量管理范式" class="headerlink" title="1. 定量管理范式"></a>1. 定量管理范式</h1><ul><li>构建定量模型<ol><li>子过程能力基线</li><li>过程模型</li></ol></li><li>应用模型<ol><li>监控影响子过程的关键因素</li></ol></li></ul><h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h1><h2 id="2-1-子过程性能"><a href="#2-1-子过程性能" class="headerlink" title="2.1. 子过程性能"></a>2.1. 子过程性能</h2><ul><li><strong>(子)过程性能</strong>：遵循某个特定（子）过程之后产生结果的量化描述，既包括（子）过程度量<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.613ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1155 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mi" transform="translate(861,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>（例如，时间、缺陷消除效率、工时等），也包括产物度量<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.054ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 908 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"></path></g><g data-mml-node="mi" transform="translate(614,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>（例如，缺陷密度，相应时间等）。</li></ul><h2 id="2-2-子过程性能基线"><a href="#2-2-子过程性能基线" class="headerlink" title="2.2. 子过程性能基线"></a>2.2. 子过程性能基线</h2><ul><li><strong>子过程性能基线</strong>：上述过程性能的一个定量化的刻画，一般包括均值和范围。通常用作过程性能的benchmark。</li></ul><h2 id="2-3-过程或子过程性能模型"><a href="#2-3-过程或子过程性能模型" class="headerlink" title="2.3. 过程或子过程性能模型"></a>2.3. 过程或子过程性能模型</h2><ul><li><strong>过程或子过程性能模型</strong>：依据子过程的逻辑关系构建相应的数学模型，描述子过程性能基线和整体过程的性能输出（例如，质量、生产效率、成本等）之间的关系<ul><li>例如，Process Yield和Phase Yield</li></ul></li></ul><h1 id="3-定量模型构建的关键实践"><a href="#3-定量模型构建的关键实践" class="headerlink" title="3. 定量模型构建的关键实践"></a>3. 定量模型构建的关键实践</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F27%2F10-51-19-7b8f624c41ccbb6792f78d4d27b552cc-20240627105119-f31373.png" alt="image.png"></p><h1 id="4-定量模型应用（定量管理）的关键实践"><a href="#4-定量模型应用（定量管理）的关键实践" class="headerlink" title="4. 定量模型应用（定量管理）的关键实践"></a>4. 定量模型应用（定量管理）的关键实践</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F27%2F10-55-50-b8fc29c55ec659657ce950454361dc68-20240627105549-247234.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>软件系统设计-架构期末</title>
    <link href="http://example.com/posts/3ff9b627/"/>
    <id>http://example.com/posts/3ff9b627/</id>
    <published>2024-06-06T02:06:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-架构概念"><a href="#1-架构概念" class="headerlink" title="1. 架构概念"></a>1. 架构概念</h1><ol><li>架构定义<ul><li>架构定义：软件系统的系统，系统包含元素，元素之间的关系，软件的属性和动态行为</li><li>工业界定义：设计阶段最重要设计决定的集合</li></ul></li><li>软件架构师做什么</li><li>架构来源<ol><li>主要：NFR非功能需求</li><li>ASR</li><li>质量需求</li><li>利益相关者</li><li>技术环境</li></ol></li><li>视图 4+1<ol><li>逻辑视图：架构的静态关系</li><li>过程视图：运行过程种的变化行为</li><li>物理视图：和物理世界元素的对应关系</li><li>开发视图：开发活动</li><li>用例场景user case scenairos</li></ol></li><li>架构活动和演化</li><li>软件架构知识域</li></ol><h1 id="2-架构过程"><a href="#2-架构过程" class="headerlink" title="2. 架构过程"></a>2. 架构过程</h1><p>四个阶段，图</p><h2 id="2-1-架构活动"><a href="#2-1-架构活动" class="headerlink" title="2.1. 架构活动"></a>2.1. 架构活动</h2><p>架构实践、确认、维护、演化</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-08-47-0067f3b14e1c3d3853948c36015a7a1d-20240616170846-967e93.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-08-57-d8d00bc5524d00997b981af5fd1fa8c0-20240616170856-10f18d.png" alt="image.png"></p><h2 id="2-2-架构设计的活动"><a href="#2-2-架构设计的活动" class="headerlink" title="2.2. 架构设计的活动"></a>2.2. 架构设计的活动</h2><p>● 识别ASRs，指导架构设计的依据<br>● 考虑已有的框架、风格、模式、tactic<br>● 形成文档<br>● 架构的分析和评估 stakeholder参与，是否满足ASR要求</p><p>![[软件系统设计-架构期末#9.12. 简要描述在软件架构过程中涉及的⼀般活动，输入输出]]</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-09-06-dce21ed5882ec762dc38214bf132fe92-20240616170906-6800ff.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-09-13-5a8ff42941d1d7d1f678df31e4fa0d02-20240616170913-841a77.png" alt="image.png"></p><h1 id="3-质量属性"><a href="#3-质量属性" class="headerlink" title="3. 质量属性"></a>3. 质量属性</h1><ol><li>软件需求<ol><li>功能需求：系统行为</li><li>质量需求:系统完成工作好坏程度</li><li>约束：需求阶段预设的设计决定，不能妥协</li></ol></li><li>质量属性<ol><li>外部：用户把系统作为黑盒，可以从外部感受的</li><li>内部：可以知道系统内部怎么实现，开发人员，系统是否容易实现和维护</li><li>用刺激相应情景描述</li><li>tatics树和设计决定</li><li>checklist在七个方面评估质量属性</li></ol></li><li>ASR：<ol><li>如何从用户获取ASR？从需求文档（不能提供足够信息，尤其是质量需求），座谈会，商业目标，效用树（Utililty Tree）</li></ol></li></ol><h1 id="4-架构模式"><a href="#4-架构模式" class="headerlink" title="4. 架构模式"></a>4. 架构模式</h1><p>可以被复用的解决方案</p><p>涉及的架构元素<br>相互之间的关系<br>需要施加的设计决定</p><ul><li>分类<ol><li>Module 描述静态关系</li><li>CNC 组件连接器</li><li>系统动态关系</li><li>系统和外部（物理世界，人，组织….）</li></ol></li></ul><p>Tactic是最小粒度的基本设计决定<br>Pattern包含需要解决的问题，问题发生的场景，一系列设计决定</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F23%2F18-36-47-0c1c6e7e0532d0c03d3b5649b0d3ffbf-20240623183646-58a820.png" alt="image.png"></p><h1 id="5-设计架构"><a href="#5-设计架构" class="headerlink" title="5. 设计架构"></a>5. 设计架构</h1><ul><li><p><strong>通用设计策略</strong></p><ol><li>抽象abstraction</li><li>分解decomposition：分解成一个个问题</li><li>分治divide &amp; conquer</li><li>生成和测试generation and test：先根据ASR、质量属性选择一个初始的设计决定组合，然后看是不是能满足ASR要求</li><li>迭代iteration: 迭代，修正</li><li>重用reuse</li></ol></li><li><p><strong>设计需要覆盖7个方面</strong></p><ol><li>Responsibilities职责：如何分配，不等于功能<ul><li>还有质量要求，如Monitor是为了可用性而不是实现功能</li></ul></li><li>Coordination：系统元素如何协调通信</li><li>Data：数据存储，存储协议，不同介质上的分配</li><li>Resource：计算资源，网络，缓存，时间</li><li>Elements mapping：元素对应关系，从架构元素到软件元素</li><li>Binding time：元素之间的关系什么时候被确定下来<ul><li>绑定事件越往后，越灵活，但是系统的不确定性增加，测试负担增加</li></ul></li><li>Technology: 实现技术和技术栈的选择</li></ol></li><li><p><strong>ADD</strong></p><ol><li>输入：ASR</li><li>输出：在step 4生成的视图</li><li>8-step process: <ol><li>confirm requirements</li><li>choose an element to decompose,</li><li>identify ASRs, </li><li>choose a design satisfying ASRs, </li><li>instantiate elements &amp; allocate responsibilities, </li><li>define interface, </li><li>verify &amp; refine requirements, </li><li>repeat step 2-7 until all ASRs satisfied</li></ol></li><li>Step4: <ul><li>4.1 identify concerns, </li><li>4.2 list alternatives, </li><li>4.3 select patterns/tactics, </li><li>4.4 determine relations, </li><li>4.5 capture views, </li><li>4.6 resolve inconsistencies</li></ul></li></ol></li></ul><h1 id="6-架构文档化"><a href="#6-架构文档化" class="headerlink" title="6. 架构文档化"></a>6. 架构文档化</h1><ul><li>Views视图<ol><li>style(viewpoints), pattern and views</li><li>Structural views: module views, component and connector views, allocation views</li><li>Quality views</li></ol></li><li>文档化视图：<ol><li>确定stakeholder，保留提供了大部分stakehodler都关心的信息的视图</li><li>合并视图</li><li>优先级排序，把不重要的视图筛选掉</li></ol></li><li>视图补充信息</li></ul><h1 id="7-评估架构"><a href="#7-评估架构" class="headerlink" title="7. 评估架构"></a>7. 评估架构</h1><ul><li>ATAM方法的利益相关者（stackholder）</li><li>ATAM方法:Architecture Tradeoff Analysis Method<ul><li>阶段0：团队准备和建立</li><li>阶段1：评估1<ol><li>介绍ATAM</li><li>介绍商业驱动</li><li>介绍架构</li><li>识别架构方法：通过研究架构文档、听取架构师的展示、向架构师询问设计系统时使用的模式和策略</li><li>生成效用树：确定、排序和优化系统最重要的质量属性目标，并最终用质量属性效用树来详细阐述</li><li>分析架构方法</li></ol></li><li>阶段2：评估2<ol><li>介绍ATAM和之前取得的结果（除了效用树）</li><li>头脑风暴，排列场景的优先级</li><li>分析架构方法</li><li>呈现结果</li></ol></li><li>阶段3：后续<ul><li>评估团队制作一份书面报告，发给主要涉众</li></ul></li></ul></li><li>不同阶段参加的stackholder不同<ol><li>phase1 评估团队，决策者</li><li>phase2 评估团队，决策者，其他涉众</li><li>phase3 评估团队，主要涉众</li></ol></li><li>输入：架构文档</li><li>输出：风险（非风险，风险主题），敏感点，权衡点</li></ul><p>phase1<br>phase2 不能向stackholder透露效用树</p><p><a class="link" href="https://cloud.tencent.com/developer/article/2260280">软考系统架构设计师(十一)：软件架构评估 和 软件质量属性-腾讯云开发者社区-腾讯云 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h1 id="8-微服务架构"><a href="#8-微服务架构" class="headerlink" title="8. 微服务架构"></a>8. 微服务架构</h1><p>更多考虑他们之间的关系</p><p>这里有张图，注意图例</p><h1 id="9-往年题"><a href="#9-往年题" class="headerlink" title="9. 往年题"></a>9. 往年题</h1><blockquote><p>参考：<br><a class="link" href="https://wbl-z.github.io/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E5%BE%80%E5%B9%B4%E9%A2%98/#">软件系统设计复习往年题 | wbl-z’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Exam0-%E5%BE%80%E5%B9%B4%E8%80%83%E8%AF%95/">2021-软件系统设计-Exam0-往年考试 - SpriCoder的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h2 id="9-1-如何进行质量属性方案建模？请使用”刺激-相应”图的格式进行建模"><a href="#9-1-如何进行质量属性方案建模？请使用”刺激-相应”图的格式进行建模" class="headerlink" title="9.1. 如何进行质量属性方案建模？请使用”刺激-相应”图的格式进行建模"></a>9.1. 如何进行质量属性方案建模？请使用”刺激-相应”图的格式进行建模</h2><ul><li>如何建模：<ol><li>刺激源</li><li>刺激</li><li>工件</li><li>环境</li><li>响应</li><li>响应度量</li></ol></li><li>不同质量属性的刺激响应6要素：<ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F22%2F20-38-02-ce5478bec2c030a053f69f52dba2dbb9-20240622203801-07c59d.png" alt="image.png"></li></ul></li></ul><h2 id="9-2-描述软件需求、质量属性和架构攸关的需求-ASR-之间的区别和关系"><a href="#9-2-描述软件需求、质量属性和架构攸关的需求-ASR-之间的区别和关系" class="headerlink" title="9.2. 描述软件需求、质量属性和架构攸关的需求 (ASR) 之间的区别和关系"></a>9.2. 描述软件需求、质量属性和架构攸关的需求 (ASR) 之间的区别和关系</h2><ul><li>联系：<ol><li>软件需求包括质量属性和架构重要需求；</li><li>质量属性需求越困难、越重要，就越可能对架构产⽣重⼤影响，因此可能是 ASR；</li><li>ASR 的实现可能会影响质量属性</li></ol></li><li>区别：<ol><li>软件需求是总体的概念，质量属性是其中⼀部分内容，是整个系统的期望特性，是在功能需求之上的，强调系统需要达到的质量，ASR 是在架构上重要的需求，强调这个需求对于架构有重⼤影响；</li><li>质量属性侧重于描述需求要求的系统质量，ASR 侧重于描述需求可能影响系统架构</li></ol></li></ul><h2 id="9-3-什么是ASR？"><a href="#9-3-什么是ASR？" class="headerlink" title="9.3. 什么是ASR？"></a>9.3. 什么是ASR？</h2><p>Architecture Significant Requirement，架构攸关需求，是⼀种在架构上有深刻影响的需求。<br>质量属性需求越困难、越重要，就越有可能对架构产⽣重⼤影响，因此成为 ASR。</p><h2 id="9-4-ASR四个来源和方法"><a href="#9-4-ASR四个来源和方法" class="headerlink" title="9.4. ASR四个来源和方法"></a>9.4. ASR四个来源和方法</h2><ol><li>从需求文档获取：MoScoW方法和用户故事</li><li>涉众采访：质量属性工作坊（QAW）</li><li>业务目标：通过理解业务目标获取ASR</li><li>从质量属性效用树获取：通过方案量化描述需求后，逐渐对质量属性进行分解细化，直到包含量化指标为止。</li></ol><h2 id="9-5-设计软件时应用的通用设计策略-一般设计策略有哪些？为这些策略提供一个带有软件架构的简明工作示例"><a href="#9-5-设计软件时应用的通用设计策略-一般设计策略有哪些？为这些策略提供一个带有软件架构的简明工作示例" class="headerlink" title="9.5. 设计软件时应用的通用设计策略/一般设计策略有哪些？为这些策略提供一个带有软件架构的简明工作示例"></a>9.5. 设计软件时应用的通用设计策略/一般设计策略有哪些？为这些策略提供一个带有软件架构的简明工作示例</h2><ol><li>抽象abstraction  <ul><li>使用抽象让设计师关注本身结构而不关心实现，比如将系统抽象为组件和连接件或抽象为模块。</li></ul></li><li>分解decomposition：<ul><li>针对某一个系统关注点分解后处理，比如将整个系统分解或将某个模块分解，使满⾜给定的约束和安排，实现系统的质量和业务⽬标</li></ul></li><li>分治divide &amp; conquer  <ul><li>对各个模块分别处理</li></ul></li><li>生成和测试generation and test<ul><li>将一个特定的设计看作是一个假设；根据测试路径生成测试用例。</li></ul></li><li>迭代iteration: 迭代，修正  <ul><li>使用迭代的方法，ADD方法多次迭代直到满足所有ASR</li></ul></li><li>重用reuse<ul><li>提取设计中可以重用的元素</li></ul></li></ol><h2 id="9-6-ADD方法的过程"><a href="#9-6-ADD方法的过程" class="headerlink" title="9.6. ADD方法的过程"></a>9.6. ADD方法的过程</h2><ol><li>确定需求的信息充足</li><li>选择一个系统元素进行分解</li><li>识别候选的ASR</li><li>选择满足ASR的设计<ol><li>识别设计关注点</li><li>从从属关注点列出可选的pattern、tactic</li><li>从列表中选择pattern、tactic</li><li>合成初步架构试图</li><li>评估和解决不一致</li></ol></li><li>实例化元素并分配职责</li><li>定义实例化元素的接口</li><li>验证和细化需求，并使其成为实例化元素的约束</li><li>重复直到满足所有ASR</li></ol><h2 id="9-7-为什么应该使用不同视图来记录软件架构？给出四个示例视图的名称和目的"><a href="#9-7-为什么应该使用不同视图来记录软件架构？给出四个示例视图的名称和目的" class="headerlink" title="9.7. 为什么应该使用不同视图来记录软件架构？给出四个示例视图的名称和目的"></a>9.7. 为什么应该使用不同视图来记录软件架构？给出四个示例视图的名称和目的</h2><ul><li>原因：<ol><li>不同视图支持不同的目标和用户，突出不同的系统元素和关系</li><li>不同视图将不同质量属性暴露出不同的程度</li></ol></li><li>视图名称和目的：<ol><li>模块视图 Module View：如何构建为一组实现单元？</li><li>组件和连接器视图 C &amp; C View：如何构建为一组具有运行时行为和交互的元素的？</li><li>分配视图 Allocation View：与环境中的非软件结构有何关系？</li><li>质量视图 Quality Views，安全视图、性能视图、可靠性视图、沟通视图、异常（错误处理）视图</li><li>组合视图：将上述视图进行组合</li></ol></li></ul><h2 id="9-8-将以下每个问题（左侧）与解决该问题的架构风格-视图（右侧）对应起来。列出每个样式类别的四个视图"><a href="#9-8-将以下每个问题（左侧）与解决该问题的架构风格-视图（右侧）对应起来。列出每个样式类别的四个视图" class="headerlink" title="9.8. 将以下每个问题（左侧）与解决该问题的架构风格/视图（右侧）对应起来。列出每个样式类别的四个视图"></a>9.8. 将以下每个问题（左侧）与解决该问题的架构风格/视图（右侧）对应起来。列出每个样式类别的四个视图</h2><ul><li>连线题<ol><li>它是如何构建为一组实现单元的？How it is structed as a set of implementation of units(Module Styles)</li><li>它是如何构建为一组具有运行时行为和交互的元素的？How it is structed as a set of elements that have runtime behavior and interactions?(Component-Connector Styles)</li><li>它与环境中的非软件结构有何关系？How it relates to non-software structures in its environment?(Allocation Styles)</li></ol></li><li>Module Styles：分解视图、使用视图、泛化视图、分层视图、领域视图、数据模型视图</li><li>Component-Connector Styles：管道-过滤器视图、客户端-服务器视图、点对点视图、面向服务视图、发布-订阅视图</li><li>Allocation Styles：部署视图、安装视图、工作分配视图、其他分配视图。</li></ul><h2 id="9-9-描述4-1视图并绘制"><a href="#9-9-描述4-1视图并绘制" class="headerlink" title="9.9. 描述4+1视图并绘制"></a>9.9. 描述4+1视图并绘制</h2><p><a class="link" href="https://en.wikipedia.org/wiki/4%2B1_architectural_view_model">4+1 architectural view model - Wikipedia <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ol><li>逻辑视图：描述了对架构而言重要的元素和他们之间的关系（功能需求）<ul><li>UML的类图、状态图描述</li></ul></li><li>过程视图：描述了元素之间的并发和交互。<ul><li>UML的顺序图、通信图、活动图描述</li></ul></li><li>物理视图：描述了主要过程和组件是如何被映射到硬件上的。<ul><li>UML部署图</li></ul></li><li>开发视图：描述体系结构的需求，软件开发环境的静态结构<ul><li>UML包图、组件图</li></ul></li><li>用例场景（Use Case）：捕获架构需求，与一个或多个特定视图相关。<ul><li>刺激响应图</li></ul></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F22%2F20-34-45-14d72ba158440497c5924af3b864d689-20240622203444-c0bcfb.png" alt="image.png"></p><h2 id="9-10-什么区分了软件产品线架构和单个软件产品架构？"><a href="#9-10-什么区分了软件产品线架构和单个软件产品架构？" class="headerlink" title="9.10. 什么区分了软件产品线架构和单个软件产品架构？"></a>9.10. 什么区分了软件产品线架构和单个软件产品架构？</h2><ol><li>产品线的目的：实现高可重用性、高修改性。</li><li>产品线之所以有效是因为通过重用可以充分利用产品的共性，从而产生深长的经济性。</li><li>在产品线架构中有一组明确允许发生的变化，然而对于常规架构来说，只要满足了单个系统的行为和质量目标，几乎任何实例都是可以的。因此，识别允许的变化是架构责任的一部分，同时还需要提供内建的机制来实现它们。</li></ol><h2 id="9-11-软件架构涉及哪些风险、敏感点和权衡点？为每个点给出一个例子"><a href="#9-11-软件架构涉及哪些风险、敏感点和权衡点？为每个点给出一个例子" class="headerlink" title="9.11. 软件架构涉及哪些风险、敏感点和权衡点？为每个点给出一个例子"></a>9.11. 软件架构涉及哪些风险、敏感点和权衡点？为每个点给出一个例子</h2><ol><li>⻛险：可能对所需质量属性产⽣负⾯影响的架构决定；<ul><li>增加备份数据库导致性能下降；</li><li>⽤户的简单密码是安全性的⻛险</li></ul></li><li>敏感点：对于特定质量属性敏感的架构决定；<ul><li>可靠性对于增加备份数据库敏感；</li><li>⽤户的简单认证降低安全性</li></ul></li><li>权衡点：影响多个质量属性的架构决定；<ul><li>增加备份数据库让可靠性提升，让性能下降</li></ul></li></ol><h2 id="9-12-简要描述在软件架构过程中涉及的⼀般活动，输入输出"><a href="#9-12-简要描述在软件架构过程中涉及的⼀般活动，输入输出" class="headerlink" title="9.12. 简要描述在软件架构过程中涉及的⼀般活动，输入输出"></a>9.12. 简要描述在软件架构过程中涉及的⼀般活动，输入输出</h2><ol><li>创造系统的商业案例</li><li>理解需求</li><li>创造和选择架构</li><li>与涉众沟通架构</li><li>分析或评估架构<ol><li>总的方法</li><li>质量特定方法</li></ol></li><li>实现架构</li><li>确保架构符合要求</li></ol><hr><ol><li>识别ASRs<ol><li>输入：无</li><li>输出：优化的质量属性场景</li></ol></li><li>架构设计<ol><li>输入：优化的质量属性场景、需求和约束、模式和决策</li><li>输出：一组候选视图的草图（模式决定）</li></ol></li><li>架构文档化<ol><li>输入：一组模式决定的草图（由模式决定）</li><li>输出：View &amp; Beyond</li></ol></li><li>架构评估<ol><li>输入：View &amp; Beyond、优化的质量属性场景</li><li>输出：View &amp; Beyond</li></ol></li></ol><h2 id="9-13-典型的软件架构⽂档包中应该包括什么？简要描述各个组件及其⽤途"><a href="#9-13-典型的软件架构⽂档包中应该包括什么？简要描述各个组件及其⽤途" class="headerlink" title="9.13. 典型的软件架构⽂档包中应该包括什么？简要描述各个组件及其⽤途"></a>9.13. 典型的软件架构⽂档包中应该包括什么？简要描述各个组件及其⽤途</h2><ol><li>文档路线图：描述文档中有哪些信息，在哪里可以被找到</li><li>描述视图的文档结构<ol><li>主要展示：显示视图的元素及其关系，通常图形化</li><li>元素⽬录：详细描述元素及其属性、关系及其属性、元素接⼝和⾏为</li><li>上下⽂图：展示系统和其部分如何与环境关联</li><li>可变性指南：描述该视图如何应对未来架构的任何变化点</li><li>缘由：为什么这个视图反映了设计，提供⼀个令⼈信服的论据以说明它是 健全的</li></ol></li><li>系统概览：概要地描述系统</li><li>在视图间映射：描述每种视图的相似和映射</li><li>原因：描述最终选择试图的原因</li><li>目录：索引、词汇表、缩略词表</li></ol><h2 id="9-14-ATAM每个阶段的输出"><a href="#9-14-ATAM每个阶段的输出" class="headerlink" title="9.14. ATAM每个阶段的输出"></a>9.14. ATAM每个阶段的输出</h2><ul><li>阶段0：<ol><li>涉众的初步名单</li><li>逻辑：何时？何地？如何？</li><li>评估报告交给谁？</li><li>报告包含什么？</li></ol></li><li>阶段1：<ol><li>架构描述</li><li>商业驱动</li><li>作为场景实现的特定质量属性需求的优先级列表</li><li>效用树</li><li>风险和非风险点</li><li>敏感点和权衡点</li></ol></li><li>阶段2：<ol><li>涉众社区的场景优先级列表</li><li>风险主题</li><li>受到威胁的业务驱动因素</li></ol></li><li>阶段4：<ul><li>最终评估报告</li></ul></li></ul><h2 id="9-15-微服务和SOA的区别、相同点？"><a href="#9-15-微服务和SOA的区别、相同点？" class="headerlink" title="9.15. 微服务和SOA的区别、相同点？"></a>9.15. 微服务和SOA的区别、相同点？</h2><ol><li>区别<ol><li>SOA使用企业级总线通信，微服务使用清凉级通信机制</li><li>SOA每个服务职责较重，微服务每个服务职责单一</li><li>SOA强调中央管理，微服务去中心化</li><li>微服务的耦合比SOA小</li></ol></li><li>相同<ol><li>都采用分布式组件的形式</li><li>各个组件可以相互服务而无需知道细节</li><li>服务自身高内聚，服务间低耦合</li><li>微服务是SOA的一种</li></ol></li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SQL-期末</title>
    <link href="http://example.com/posts/48f5fee/"/>
    <id>http://example.com/posts/48f5fee/</id>
    <published>2024-06-03T06:06:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>SQL 3选2，标注使用哪个数据库</p><ul><li>常见函数：<ol><li>字符串replace</li><li>数值计算，考虑空值，平均值空值</li><li>日期，使用索引的三种写法</li></ol></li><li>递归查询，withas<ul><li>起始体，union all,递归体，视图</li></ul></li><li>外连接+数值计算</li></ul><p>结构合理、关键字、函数都有分</p><h1 id="论述"><a href="#论述" class="headerlink" title="论述"></a>论述</h1><ol><li>索引的叶节点<ul><li>结构：N个节点，N+1个link<ul><li>考试一般3扇出</li></ul></li><li>节点分裂/合并<ul><li>叶节点和内部节点</li><li>向上传递</li></ul></li></ul></li><li>日志<ul><li>Redo</li><li>Undo</li><li>区别，实现，问题</li></ul></li><li>分区，分表，分库<ul><li>原因</li><li>解决的问题</li><li>带来新的问题</li></ul></li><li>SQL解释器：<strong>可能会考一个基于成本优化器的成本计算方式</strong><ol><li>优化的基本逻辑</li><li>基于成本的优化器</li><li>基于规则的优化器</li></ol></li><li>建议和想法</li></ol><hr><p>B+Tree索引是大多DBMS缺省的索引类型，请详细描述以下几个问题：<br>1）B树索引的结构和使用方式  </p><p>有K个子树的中间结点包含K个元素，每个节点不保存数据只保存索引，所有的数据都存储在叶节点；<br>所有叶节点中包含了元素的信息，还有指向元素记录的指针，并且叶节点本身按照关键字大小从小到大的顺序连接；<br>使用方式是根据目标元素在B树中二分查找。</p><p>2）何时该使用B树索引，并分别说明原因；并详细说明为什么系统的为外键构建索引是普遍的要求？</p><p>何时使用：<br>仅需要通过索引访问基本表的一部分（检索的结果集与集体的百分比低于10%）<br>如果处理表的多列，可以使用索引而不使用表；<br>为什么系统的为外键构建索引是普遍的要求：<br>建立外键索引可以更快速地保证数据的一致性：比如A持有B的外键，B删除记录时需要检查A中相应的行；否则，需要对A全表遍历；<br>建立外键索引可以避免死锁：如上所述，对A全表遍历时间很长，导致其他进程与之死锁，导致双双失败；</p><p>3）针对2）有没有例外情况？如果有请简要说明情况  </p><p>如果表很小或者很少被修改，则不必建立；因为使用索引非常占用磁盘空间；</p><p>4）请描述Oracle中一种类似于B树索引结构的物理组织形式索引组织表（IOT）的基本结构和应用范围  </p><p>其中的记录是排序，按主键有序的。IOT中每个叶节点既有每行的主键值，又有非主键值。<br>数据的存放是严格规定的， 记录的存放是排序的，查询效率非常高。数据插入以前其实就已经确定了其位置，所以不管插入的先后顺序，它在那个物理上的哪个位置与插入的先后顺序无关。这样在进行查询的时候就可以少访问很多 blocks，但是插入的时候，速度就比普通的表要慢一些。<br>应用范围：经常查找的表；经常通过主键访问的表；按顺序进行物理存贮；构建自己的索引结构；对主键或者唯一键区间查询、分类查询；<br>不适用：经常更新的表；不经常使用主键访问的表；</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>07-Linux期末总结</title>
    <link href="http://example.com/posts/60504a0c/"/>
    <id>http://example.com/posts/60504a0c/</id>
    <published>2024-05-30T02:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ol><li>什么是Linux？<ul><li>类Unix，开源，免费，GNU协议，支持多平台</li></ul></li><li>常见Linux发行版有哪些？</li><li>GPL版权的特点<ol><li>开放源代码</li><li>自由使用</li><li>有传染性</li></ol></li><li>文件系统和后面的文件一起考</li><li>GRUB知道就行，细节不考</li><li>配置文件能读懂就行<ul><li>grun.conf</li><li>title, root, kernel, initrd</li></ul></li><li>安装软件步骤<ol><li>cmake： 用于生成makefile</li><li>make：编译</li><li>make install：从Makefile中读取指令，将编译好的文件复制到指定的安装目录中</li></ol></li><li>虚拟终端切换<ul><li>Alt-Fn (or Ctrl-Alt-Fn if in X)</li></ul></li><li>命令行提示符<ol><li>$：普通用户</li><li><h1 id="：root用户"><a href="#：root用户" class="headerlink" title="：root用户"></a>：root用户</h1></li><li>和环境变量<code>PS1</code>有关</li></ol></li><li><strong>命令都要</strong>，除了课上讲的不要求的命令</li><li>文件基本概念<ol><li>数据集合，可以读写的对象，有属性、类型、权限</li><li>字节流</li></ol></li><li><strong>7种文件类型</strong><ol><li>普通文件</li><li>文件夹</li><li>字符设备文件</li><li>块设备文件</li><li>网络接口文件</li><li>符号链接</li><li>管道文件</li></ol></li><li>知道统一目录结构</li><li><strong>文件权限</strong></li><li>进程</li></ol><p>MBR、GPT不考<br>常见目录一般不考<br>开机启动部分不考<br>命令行好处不靠<br>多任务多用户，不考<br>层次结构图，不作为重点</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><ol><li><strong>命令</strong>，除了上课讲不考的都要考<ul><li>不考：vdir，locate</li></ul></li><li><strong>重定向</strong></li><li>管道：会用就行</li><li>环节变量，和SHELL编程一起考</li><li>高级命令和正则表达式，会有一些比较简单的表达式，不是重点<ol><li>find</li><li>sed</li><li>grep</li></ol></li></ol><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>考试最多出现两题概念题</p><ol><li>Shell概念<ul><li>用户与操作系统之间的接口，是核外程序。</li><li>既是命令的解释程序，也是独立的程序设计语言解释器。</li></ul></li><li>Shell类型，除了bash再列出一两个名字<ul><li>zsh, ash, csh</li></ul></li><li>Shell机制<ol><li>哪些功能归shell管：重定向、管道</li></ol></li><li><strong>执行Shell三种方式的区别</strong></li><li>环境变量<ol><li>基本命令：export, env,</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="8.471ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 3744 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(888,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mi" transform="translate(1651,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(2702,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(3466,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>PS1, $PS2</li></ol></li><li>read</li><li>引号用法</li><li>参数变量</li><li>条件测试<ol><li>[]形式</li></ol></li><li>Shell算数比较，直接给脚本理解</li><li>Shell脚本会写</li><li>命令表<ol><li>分号串联</li><li>条件组合<ol><li>AND</li><li>OR</li></ol></li></ol></li><li>函数，只要求会读</li><li>杂项命令</li><li>参数扩展</li><li>即时文档</li></ol><p>语句块不要求</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><ol><li>编译器原理，连接，动态库静态库。考试和Makefile一起考，一般给一个实际程序<ol><li>调试原理：要加调试信息，关掉调试优化</li></ol></li><li><strong>gcc参数</strong></li><li>makefile读得懂，写考试比较简单<ol><li>预定义变量，多目标扩展，使用函数，不要求写</li></ol></li></ol><p>gdb不考</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><ol><li>文件和文件系统的概念</li><li><strong>7种文件类型</strong></li><li><strong>VFS的四个对象</strong><ol><li>super block</li><li>i-node object</li><li>file object</li><li>dentry object</li></ol></li><li><strong>硬链接，软连接</strong><ol><li>区别：一定要答全</li><li>常见命令</li><li>对应系统调用</li><li>ls -l的时候会影响哪些地方</li></ol></li><li>系统调用和库函数<ol><li>区别：缓存分配，</li><li>编程题会要求用系统调用写，或用库函数写</li></ol></li><li>各种系统调用<ol><li>fcntl参数和意思，意思对就行</li><li>ioctl在驱动考，和字符型驱动的关系</li><li>umask，权限</li></ol></li><li>C库<ol><li>缓存</li></ol></li><li>文件锁<ol><li>系统调用：fcntl</li><li>类型</li></ol></li></ol><p>编程题：尽可能高效-&gt;用系统调用</p><p>文件系统在磁盘分布不考</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>进程线程</p><ol><li>系统调用<ol><li>exec系列</li><li>fork</li><li>wait,waitpid</li><li><strong>kill,raise</strong></li><li>alarm, pause</li><li>mmap/munmap</li></ol></li><li>进程信息</li><li>信号，不会要求写，会问在代码里的效果</li><li>可靠信号和不可靠信号</li><li>可重入函数<ol><li>列表不需要背下来</li></ol></li><li>地址映射：文件映射到一段内存地址<ol><li>mmap/munmap描述参数</li></ol></li><li><strong>pthread</strong><ol><li>编程可能会考</li><li>信号量、互斥量、条件变量</li><li>cancel</li><li>多线程程序出现错误</li><li>TLS</li></ol></li></ol><p>编程题：文件、线程、进程</p><p>main函数入口出口，不考<br>可靠信号的设置细节不要求掌握<br>共享内存不考<br>设置线程属性不考</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>块设备不考，只考到字符设备之前</p><ol><li>Linux内核介绍</li><li>内核编译步骤，知道make menuconfig是可选的</li><li>grub引导菜单能读</li><li>驱动：工作在内核态<ol><li>加载模块命令</li><li>模块依赖命令</li></ol></li><li>用户态程序和内核态程序区别</li><li>内核代码，读</li><li>内核代码/Shell脚本没有类型浮点支持</li><li>模块间通信</li><li>驱动类型：只要求字符型设备<ol><li><strong>字符型设备驱动的步骤</strong></li><li><strong>应用程序怎么用驱动</strong></li><li>主设备号和次设备号</li></ol></li></ol><p>init不要求<br>make-kpkg不要求<br>内核代码，不要求写<br>内核编译模式，makefile，不用写<br>/proc文件系统不要求</p><h1 id="试卷结构"><a href="#试卷结构" class="headerlink" title="试卷结构"></a>试卷结构</h1><p>选择<br>填空<br>判断<br>随机</p><p>简答题：<br>0~2概念题，送分<br>描述题，尽可能写满<br>读程序题</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>08-SQL常识</title>
    <link href="http://example.com/posts/2243eb0e/"/>
    <id>http://example.com/posts/2243eb0e/</id>
    <published>2024-05-28T06:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Group-by"><a href="#1-Group-by" class="headerlink" title="1. Group by"></a>1. Group by</h1><p>group by是一个过程化操作</p><ol><li>筛选分组用having，</li><li>count(*)只要rowid存在都会算，count(name)会忽略NULL</li></ol><h1 id="2-字符串处理"><a href="#2-字符串处理" class="headerlink" title="2. 字符串处理"></a>2. 字符串处理</h1><p>清洗数据在数据库里处理的代价比在应用程序里处理的代价低</p><h2 id="2-1-遍历字符串"><a href="#2-1-遍历字符串" class="headerlink" title="2.1. 遍历字符串"></a>2.1. 遍历字符串</h2><p>数据透视表(T1,T10,T100,…)</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(e.ename,iter.pos, <span class="number">1</span>) <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> ename)</span><br></pre></td></tr></table></figure></div><h2 id="2-2-内嵌引号"><a href="#2-2-内嵌引号" class="headerlink" title="2.2. 内嵌引号"></a>2.2. 内嵌引号</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">' " '</span></span><br></pre></td></tr></table></figure></div><h2 id="2-3-统计字符出现的个数"><a href="#2-3-统计字符出现的个数" class="headerlink" title="2.3. 统计字符出现的个数"></a>2.3. 统计字符出现的个数</h2><p>问题：出现多少个逗号</p><p><strong>repalce</strong>+<strong>length</strong></p><p>len(replace) / len(‘,’)</p><h2 id="2-4-删除不想要的字符"><a href="#2-4-删除不想要的字符" class="headerlink" title="2.4. 删除不想要的字符"></a>2.4. 删除不想要的字符</h2><p>oracle：<code>translate</code><br>mysql：嵌套<code>replace</code></p><h2 id="2-5-分离数字和字符"><a href="#2-5-分离数字和字符" class="headerlink" title="2.5. 分离数字和字符"></a>2.5. 分离数字和字符</h2><p>oracle: translate对原来的字段处理两次<br>mysql：正则表达式<code>REGEXP_REPLACE</code></p><h2 id="2-6-判断含有数字和字母的数值"><a href="#2-6-判断含有数字和字母的数值" class="headerlink" title="2.6. 判断含有数字和字母的数值"></a>2.6. 判断含有数字和字母的数值</h2><p>mysql: 正则表达式，regexp</p><h2 id="2-7-提取姓名首字母"><a href="#2-7-提取姓名首字母" class="headerlink" title="2.7. 提取姓名首字母"></a>2.7. 提取姓名首字母</h2><p>需要找到空格的位置或大写的位置，然后把那个位置的字母提出来</p><h1 id="3-数值操作"><a href="#3-数值操作" class="headerlink" title="3. 数值操作"></a>3. 数值操作</h1><h2 id="3-1-计算平均值"><a href="#3-1-计算平均值" class="headerlink" title="3.1. 计算平均值"></a>3.1. 计算平均值</h2><p>难点在于空值</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span><span class="operator">%</span> 统计空值 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="built_in">coalesce</span>(sal,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">from</span> t2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> 不统计空值 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal)</span><br><span class="line"><span class="keyword">from</span> t2</span><br></pre></td></tr></table></figure></div><h2 id="3-2-累计求和"><a href="#3-2-累计求和" class="headerlink" title="3.2. 累计求和"></a>3.2. 累计求和</h2><p>sum over</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, sal</span><br><span class="line"><span class="built_in">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> sal,empno)</span><br><span class="line"><span class="keyword">as</span> running_total</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span>中的第二个字段</span><br></pre></td></tr></table></figure></div><h2 id="3-3-计算众数"><a href="#3-3-计算众数" class="headerlink" title="3.3. 计算众数"></a>3.3. 计算众数</h2><p>group by<br>count</p><h2 id="3-4-计算中位数"><a href="#3-4-计算中位数" class="headerlink" title="3.4. 计算中位数"></a>3.4. 计算中位数</h2><p>oracle: median()<br>mysql：分组，记录个数，找到中间位置的值</p><h2 id="3-5-去掉最大值最小值，然后计算平均值"><a href="#3-5-去掉最大值最小值，然后计算平均值" class="headerlink" title="3.5. 去掉最大值最小值，然后计算平均值"></a>3.5. 去掉最大值最小值，然后计算平均值</h2><p>where sal not in (min_sal, max_sal)</p><h1 id="4-日期处理"><a href="#4-日期处理" class="headerlink" title="4. 日期处理"></a>4. 日期处理</h1><h2 id="4-1-年月日加减法"><a href="#4-1-年月日加减法" class="headerlink" title="4.1. 年月日加减法"></a>4.1. 年月日加减法</h2><p>oracle: add_mounths()<br>mysql: date_add()</p><h2 id="4-2-两个日期之间的天数"><a href="#4-2-两个日期之间的天数" class="headerlink" title="4.2. 两个日期之间的天数"></a>4.2. 两个日期之间的天数</h2><p>mysql: datediff<br>oracle：两个日期直接相减</p><h2 id="4-3-两个日期之间的工作日天数"><a href="#4-3-两个日期之间的工作日天数" class="headerlink" title="4.3. 两个日期之间的工作日天数"></a>4.3. 两个日期之间的工作日天数</h2><p>需要获取日期是星期几，然后把星期六星期天去掉<br>date_format,date_add</p><h2 id="4-4-判断闰年"><a href="#4-4-判断闰年" class="headerlink" title="4.4. 判断闰年"></a>4.4. 判断闰年</h2><p>加一年，然后判断时间差是多少天；<br>判断二月份第一天到最后一天是几天</p><h1 id="5-常见SQL连接模式"><a href="#5-常见SQL连接模式" class="headerlink" title="5. 常见SQL连接模式"></a>5. 常见SQL连接模式</h1><h2 id="5-1-叠加行集（Union-Union-all）"><a href="#5-1-叠加行集（Union-Union-all）" class="headerlink" title="5.1. 叠加行集（Union & Union all）"></a>5.1. 叠加行集（Union &amp; Union all）</h2><p>不是关系代数</p><ul><li>约束：上下的select字段要一样，字段数量要一样</li><li>区别：<ul><li>Union：等同于针对Union all的输出再进行一次distinct操作</li><li>Union all：不去重</li></ul></li></ul><h2 id="5-2-查找只存在于一张表的数据（差）"><a href="#5-2-查找只存在于一张表的数据（差）" class="headerlink" title="5.2. 查找只存在于一张表的数据（差）"></a>5.2. 查找只存在于一张表的数据（差）</h2><p>MySQL: not in<br>Oracle: minus</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select deptno</span><br><span class="line">from dept</span><br><span class="line">where deptno not in (</span><br><span class="line">select deptno in emp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如果<code>deptno</code>不是主键：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select distinct deptno</span><br><span class="line">from dept</span><br><span class="line">where deptno not in (</span><br><span class="line">select deptno in emp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如果<code>not in</code>嵌套查询里有空值:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select deptno</span><br><span class="line">from dept</span><br><span class="line">where deptno not in (10, 50, null)</span><br></pre></td></tr></table></figure></div><p>no=20 not in (10, 50, null)-&gt;(F or F or null)=null，查询结果为空</p><h2 id="5-3-从一个表检索另一个不相关的行（外连接）"><a href="#5-3-从一个表检索另一个不相关的行（外连接）" class="headerlink" title="5.3. 从一个表检索另一个不相关的行（外连接）"></a>5.3. 从一个表检索另一个不相关的行（外连接）</h2><p>左外连接<br>右外连接</p><h2 id="5-4-确定两个表是否有相同的数据"><a href="#5-4-确定两个表是否有相同的数据" class="headerlink" title="5.4. 确定两个表是否有相同的数据"></a>5.4. 确定两个表是否有相同的数据</h2><p>很复杂</p><h2 id="5-5-从多个表种返回缺失的值"><a href="#5-5-从多个表种返回缺失的值" class="headerlink" title="5.5. 从多个表种返回缺失的值"></a>5.5. 从多个表种返回缺失的值</h2><p>全外连接</p><h2 id="5-6-连接和聚合函数的使用"><a href="#5-6-连接和聚合函数的使用" class="headerlink" title="5.6. 连接和聚合函数的使用"></a>5.6. 连接和聚合函数的使用</h2>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>07-项目支持活动</title>
    <link href="http://example.com/posts/3d73f14e/"/>
    <id>http://example.com/posts/3d73f14e/</id>
    <published>2024-05-28T03:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-配置管理"><a href="#1-配置管理" class="headerlink" title="1. 配置管理"></a>1. 配置管理</h1><h2 id="1-1-配置管理介绍"><a href="#1-1-配置管理介绍" class="headerlink" title="1.1. 配置管理介绍"></a>1.1. 配置管理介绍</h2><ul><li><p>配置管理目的：保证最终产品的完整性和一致性</p></li><li><p><strong>配置项</strong>：在配置管理当中作为<strong>单独实体进行管理和控制的工作产品集合</strong></p><ul><li>为了缩小需要管理的对象的范围，同时保证完整性</li><li><strong>配置项典型产物</strong>，需要保证完全一致：代码，测试用例，用户文档  <ul><li>代码整体是配置项还是每个模块是配置项？<strong>代码每个模块都是一个配置项</strong></li></ul></li><li><strong>不属于配置项典型产物</strong>，不需要保证一致：周会记录，开发计划</li></ul></li><li><p><strong>基线</strong>：基线是一个或多个配置项及相关的标识符的代表，是一组经正式审查同意的规格或工作产品集合， 是未来开发工作或交付的基础，而且只能经由严格的变更控制程序才能改变</p><ul><li>例子：需求结束会发布需求的基线，后续都以这个需求为准；设计结束会发布设计的基线，这时的基线包含了需求和设计的配置项</li><li>是配置持续演进的稳定基础</li></ul></li></ul><h2 id="1-2-配置管理活动"><a href="#1-2-配置管理活动" class="headerlink" title="1.2. 配置管理活动"></a>1.2. 配置管理活动</h2><p><strong>版本控制+变更控制</strong>，并不是有了版本控制系统可以了</p><ol><li>识别配置项</li><li>建立配置管理系统</li><li>创建和发布基线</li><li>跟踪变更请求</li><li>控制配置项变更</li><li>建立配置管理记录</li><li>配置审计</li></ol><p>第三方审计：有没有未授权的配置变更</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F11%2F10-31-35-2d40c04432e3f8cd35e43be8100ddd42-20240611103134-5e402c.png" alt="image.png"></p><h2 id="1-3-代码配置管理"><a href="#1-3-代码配置管理" class="headerlink" title="1.3. 代码配置管理"></a>1.3. 代码配置管理</h2><ul><li>代码配置管理的三库：<ol><li>工作库：可以<strong>随意读写</strong>，就算只写了一半也可以提交</li><li>配置库：<strong>经过单元测试</strong>的稳定版本代码，类比零部件仓库<ul><li><strong>修改只能串行</strong></li></ul></li><li>产品库：挑选出一些零部件组装成产品，可以<strong>支持回滚</strong><ul><li><strong>串行修改</strong></li><li>回滚：回到以前的实践证明可以有效工作的代码</li></ul></li></ol></li></ul><h1 id="2-度量与分析"><a href="#2-度量与分析" class="headerlink" title="2. 度量与分析"></a>2. 度量与分析</h1><p><strong>意义</strong>：基于客观的数据，可以显著消除错误决策的风险，度量和分析可以获取这些客观数据<br><strong>目的</strong>：建立与维持度量能力，以支持管理的信息需要。</p><h2 id="2-1-度量分析活动"><a href="#2-1-度量分析活动" class="headerlink" title="2.1. 度量分析活动"></a>2.1. 度量分析活动</h2><ol><li>建立度量目标</li><li>指定度量方式</li><li>指定数据收集和保存的流程</li><li>指定分析流程</li><li>收集度量数据</li><li>分析度量数据</li><li>保存数据和结果</li><li>交流度量结果</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F11%2F10-31-44-d4581a20f6fbbc38485a604a8191a30c-20240611103143-22d2a8.png" alt="image.png"></p><h2 id="2-2-GQM方法"><a href="#2-2-GQM方法" class="headerlink" title="2.2. GQM方法"></a>2.2. GQM方法</h2><p>从管理的目标出发，将目标归纳、分解为度量的指标，并把这些指标提炼成可以测量的值，是一种科学的、系统的思考问题的方式</p><ul><li>GQM(Goal Question Metric)方法<ol><li>概念层(目标)<ul><li>目标是为某个特定的对象而定义的。这里的对象是指软件产品、软件过程以及相关的资源等。定义的目标基于不同原因和不同质量模型,也要参考不同的角色视图与特定的环境。</li></ul></li><li>操作层(问题)<ul><li>基于一定的刻画上述目标是否达成或者目标达成的进展情况的模型，使用一系列的问题来定义所研究的对象, 然后得出评价或评估特定目标达成进展情况。所选择的问题应当尽量体现质量相关的话题。</li></ul></li><li>量化层( 度量)<ul><li>试图以量化的方式回答上述操作层识别出来的问题。</li></ul></li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F11%2F10-39-06-b84e36ce7bdff64e4c091fcd071d8aba-20240611103905-d43152.png" alt="image.png"></p><ul><li>GQM示例<ol><li>PM<ul><li>G：保持稳定性、可预测性的开发过程来满足计划的里程碑</li><li>Q：我的项目是否按照计划的轨迹前进，计划的里程碑都能实现吗？</li><li>M：软件项目开发工作的挥发性（分支、流、变更管理（UCM）活动）</li></ul></li><li>DM<ul><li>G：最大化所有团队贡献者的生产力</li><li>Q：开发人员能完成分配给他们的任务吗？里程碑能实现吗？</li><li>M：由个体或工作组产生的项目工件数量</li></ul></li></ol></li></ul><h1 id="3-决策分析"><a href="#3-决策分析" class="headerlink" title="3. 决策分析"></a>3. 决策分析</h1><ul><li><strong>意义</strong>：错误的决策会带来灾难性的后果，为了降低错误决策的风险，需要<strong>基于客观事实和正确的流程</strong>来展开决策与分析活动</li><li><strong>正式评估过程</strong>往往包含下列的活动：<ol><li>建立评估备选方案的准则</li><li>识别备选解决方案</li><li>选择评估备选方案的方法</li><li>使用已建立的准则与方法，评估备选解决方案</li><li>依据评估准则，从备选方案中选择建议方案</li></ol></li><li><strong>决策分析活动</strong>：<ol><li>建立决策分析指南</li><li>建立评价标准</li><li>识别候选方案</li><li>选择评价方法</li><li>评价候选方案</li><li>选择解决方案</li></ol></li></ul><p>一般商业环境中，招投标的过程</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F11%2F10-40-10-d12d50dc539b3b37fa87d18ff690f3c7-20240611104009-66c2a4.png" alt="image.png"></p><h1 id="4-根因分析与解决方案"><a href="#4-根因分析与解决方案" class="headerlink" title="4. 根因分析与解决方案"></a>4. 根因分析与解决方案</h1><ul><li>根因分析活动<ol><li>识别和选定问题</li><li>根因分析</li><li>建立改进的行动方案</li><li>实施改进，评估效果</li></ol></li></ul><p>分析到有明确的解决方案，或无法解决为止</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F11%2F10-47-18-5683e2ccdeb28e9f446d2b0199daa6fd-20240611104718-e2b7e8.png" alt="image.png"></p><ul><li>归因分析示例：技术角度、人员角度、培训角度、过程角度<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F11%2F10-52-29-8b5b41af11064b39a75a8a1a4ea94877-20240611105228-eac953.png" alt="image.png"></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>06-团队工程开发</title>
    <link href="http://example.com/posts/ba7b6d37/"/>
    <id>http://example.com/posts/ba7b6d37/</id>
    <published>2024-05-28T02:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求开发"><a href="#1-需求开发" class="headerlink" title="1. 需求开发"></a>1. 需求开发</h1><h2 id="1-1-为什么“需求是一切工程活动的基础”"><a href="#1-1-为什么“需求是一切工程活动的基础”" class="headerlink" title="1.1. 为什么“需求是一切工程活动的基础”"></a>1.1. 为什么“需求是一切工程活动的基础”</h2><ol><li>设计活动一定是依据需求而开展的</li><li>产品集成活动中，各个组件之间的接口也必须事先满足接口需求，否则会造成接口不匹配<ol><li>验证活动是检验产品和产品组件是否满足事先定义的需求规格</li><li>确认活动是确保产品可以满足用户需求和实际场景的要求</li></ol></li><li>需求也是项目计划活动的关键输入，如规模估算、成本估算等必须参考需求</li></ol><h2 id="1-2-需求分类"><a href="#1-2-需求分类" class="headerlink" title="1.2. 需求分类"></a>1.2. 需求分类</h2><ol><li>客户需求：问题，描述的是客户的期望，是客户解决问题的愿望</li><li>产品需求：答案，描述的是开发团队所提供的解决方案</li></ol><h2 id="1-3-需求开发过程"><a href="#1-3-需求开发过程" class="headerlink" title="1.3. 需求开发过程"></a>1.3. 需求开发过程</h2><ol><li>需求获取：采用诱导方式获取客户的隐式需求和显式需求，尽可能识别客户的期望与受到的限制</li><li>需求汇总：整理各个来源的信息，识别缺失的信息，解决冲突的信息<ol><li>需求转化和整理：客户需求-&gt;产品需求，产品组件需求</li><li>推导未显式描述的需求内容，例如使用某项技术的附属需求</li></ol></li><li>需求验证：对需求进行分析和确认，保证符合使用者的预期<ol><li>建立相关场景</li><li>分析需求，保证必要性、充分性和正确性</li><li>确认需求，在客户环境正常运行</li></ol></li><li>制作需求文档<ol><li>需求规格文档目的：用户和开发者对软件的初始规定有一个共同理解，使之成为整个开发工作的基础</li></ol></li></ol><h1 id="2-团队智慧-设计"><a href="#2-团队智慧-设计" class="headerlink" title="2. 团队智慧/设计"></a>2. 团队智慧/设计</h1><h2 id="2-1-团队智慧挑战"><a href="#2-1-团队智慧挑战" class="headerlink" title="2.1. 团队智慧挑战"></a>2.1. 团队智慧挑战</h2><ul><li>挑战<ul><li>确定整体架构之前很难进行分工</li><li>鼓励团队成员在讨论和评审会议中的参与程度</li></ul></li></ul><h2 id="2-2-设计考虑点"><a href="#2-2-设计考虑点" class="headerlink" title="2.2. 设计考虑点"></a>2.2. 设计考虑点</h2><h3 id="2-2-1-设计标准"><a href="#2-2-1-设计标准" class="headerlink" title="2.2.1. 设计标准"></a>2.2.1. 设计标准</h3><ul><li>命名规范：项目小组应当设计一个统一的命名规范来命令各个模块并建立系统词典</li><li>接口标准：组件之间的接口标准和格式也需要作为设计标准的内容之一加以定义</li><li>系统出错信息：标准化</li><li>设计表示标准：定义设计工作产物应当满足的标准</li></ul><h3 id="2-2-2-复用性考虑"><a href="#2-2-2-复用性考虑" class="headerlink" title="2.2.2. 复用性考虑"></a>2.2.2. 复用性考虑</h3><ul><li>复用接口标准  </li><li>复用文档标准  </li><li>复用质量保证机制</li></ul><h3 id="2-2-3-可测试性的考虑"><a href="#2-2-3-可测试性的考虑" class="headerlink" title="2.2.3. 可测试性的考虑"></a>2.2.3. 可测试性的考虑</h3><p>TDD提高的是设计。先写测试脚本再写代码让开发人员对测试脚本更认真。</p><ul><li>尽可能减少测试代码的数量</li><li>制定合理的测试计划</li></ul><h3 id="2-2-4-可用性的考虑"><a href="#2-2-4-可用性的考虑" class="headerlink" title="2.2.4. 可用性的考虑"></a>2.2.4. 可用性的考虑</h3><ul><li>设计阶段就开始考虑，而不是推迟到实现阶段</li><li>针对每一个关键功能都定义关键概念和操作场景</li><li>分析操作场景以确保软件系统开发完成之后，系统使用者会满意</li><li>必要时，要求最终用户参与场景的评审，使用模拟、原型等技术，更好把握用户真实意图</li></ul><h2 id="2-3-实现策略"><a href="#2-3-实现策略" class="headerlink" title="2.3. 实现策略"></a>2.3. 实现策略</h2><h3 id="2-3-1-评审的考虑"><a href="#2-3-1-评审的考虑" class="headerlink" title="2.3.1. 评审的考虑"></a>2.3.1. 评审的考虑</h3><ol><li><strong>设计</strong>时采用的策略是<strong>自顶向下</strong>，逐层精化，有利于建立系统的整体观</li><li><strong>实现</strong>的时候为了方便实现对结果的评审，建议<strong>自底向上</strong>，首先实现底层的内容，然后对底层模块评审，有利于复用策略的应用</li></ol><h3 id="2-3-2-复用策略"><a href="#2-3-2-复用策略" class="headerlink" title="2.3.2. 复用策略"></a>2.3.2. 复用策略</h3><p>采用自底向上的开发策略利于复用。</p><ul><li>经典复用策略<ol><li><strong>编码注释</strong>： 注释使用统一格式，标明功能、调用方式、异常信息等，利于复用</li><li><strong>站立式会议</strong>：团队讨论实现计划，识别可复用组件，了解现有的复用组件库内容</li></ol></li></ul><h3 id="2-3-3-可测试性考虑"><a href="#2-3-3-可测试性考虑" class="headerlink" title="2.3.3. 可测试性考虑"></a>2.3.3. 可测试性考虑</h3><p>实现计划必须与测试计划一致，不能出现集体测试时还有模块未实现的情况</p><h1 id="3-集成的策略选择"><a href="#3-集成的策略选择" class="headerlink" title="3. 集成的策略选择"></a>3. 集成的策略选择</h1><p>经典定义：把各种组件拼装到一起，测试，一直管到交付</p><p><font color="#c00000">CICD属于逐一添加</font><br>鼓励开发人员频繁提交代码，每次提交后都进行自动化测试，有助于发现和修复问题</p><h2 id="3-1-大爆炸集成策略"><a href="#3-1-大爆炸集成策略" class="headerlink" title="3.1. 大爆炸集成策略"></a>3.1. 大爆炸集成策略</h2><ul><li>把一堆待继承的组件放在一起，进行一次集成</li><li>优点：如果组件质量很高，一次集成代价低，需要的测试用例少</li><li>缺点：如果质量不高，定位问题困难</li></ul><h2 id="3-2-逐一添加策略"><a href="#3-2-逐一添加策略" class="headerlink" title="3.2. 逐一添加策略"></a>3.2. 逐一添加策略</h2><ul><li>一次添加一个组件进行集成</li><li>优点：容易定位问题</li><li>缺点：测试代价高，需要的测试用例最多</li></ul><h2 id="3-3-集簇集成策略"><a href="#3-3-集簇集成策略" class="headerlink" title="3.3. 集簇集成策略"></a>3.3. 集簇集成策略</h2><ul><li>把有相似功能或者有关联的模块优先进行集成，形成可以工作的组件。然后以组件为单位继续较高层次的集成</li><li>优点：可以尽早获得一些可以工作的组件，有利于其他组件测试工作的开展。</li><li>缺点：过于关注个别组件，而缺乏系统的整体观，不能尽早发现系统层面的缺陷。</li></ul><h2 id="3-4-扁平化集成策略"><a href="#3-4-扁平化集成策略" class="headerlink" title="3.4. 扁平化集成策略"></a>3.4. 扁平化集成策略</h2><ul><li>优先集成高层组件的部件，其他先打桩，然后逐步将各个组件、模块真正的是实现加入系统。打“桩”（stub），即提供一些直接提供返回值的伪实现</li><li>优点：提前暴露系统级错误，快速把系统跑起来  </li><li>缺点：需要大量打桩；对系统行为的描述很有限，发现错误能力有限</li></ul><h1 id="4-验证和确认-V-V"><a href="#4-验证和确认-V-V" class="headerlink" title="4. 验证和确认(V & V)"></a>4. 验证和确认(V &amp; V)</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1. 定义"></a>4.1. 定义</h2><ul><li>验证（Verification）：<strong>产品需求</strong>有没有被满足，<strong>解决方案</strong>有没有被正确地做出来  </li><li>确认（Validation）：<strong>客户需求</strong>有没有得到解决，<strong>问题</strong>有没有解决</li></ul><p>普遍认为<strong>需求评审、验收测试是Validation</strong>，<strong>单元测试、集成、系统测试是Verification</strong><br>但是ver和val贯穿始终，都是提高最终产品策略的措施</p><h2 id="4-2-活动"><a href="#4-2-活动" class="headerlink" title="4.2. 活动"></a>4.2. 活动</h2><p>评审<br>测试</p><ol><li>环境准备</li><li>对象选择  </li><li>活动实施  </li><li>结果分析</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F26%2F16-41-19-efa542057b11a04cbec92c847e2d996e-20240626164118-e5f7ec.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>06-微服务架构</title>
    <link href="http://example.com/posts/ab2d67c8/"/>
    <id>http://example.com/posts/ab2d67c8/</id>
    <published>2024-05-21T06:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<p>微服务架构：小，自治</p><h1 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h1><ol><li><p>分析用户故事中和场景中的名词</p></li><li><p>分析用户故事中和场景中的动词，确定系统操作</p><ol><li><font color="#c00000">命令型或查询型</font></li><li>前端给后端发出请求</li><li>后端进行业务逻辑的数据获取和处理</li><li>系统操作规范<ol><li>命令对应的参数、返回值</li><li>领域模型类的行为：<font color="#c00000">前置和后置条件</font></li></ol></li></ol></li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>07-SQL优化的基础</title>
    <link href="http://example.com/posts/b68ed7c/"/>
    <id>http://example.com/posts/b68ed7c/</id>
    <published>2024-05-13T06:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关系代数核心</strong>：等价变换-&gt;可以自动对表达式做等价变换，做查询路径优化</p><h1 id="1-SQL与查询优化器"><a href="#1-SQL与查询优化器" class="headerlink" title="1. SQL与查询优化器"></a>1. SQL与查询优化器</h1><p>group by, order by不属于关系代数，无法被查询优化器优化</p><ul><li><p>过程</p><ol><li>优化器借助关系理论提供的语义无误的原始查询进行<strong>有效的等价变换</strong></li><li>优化器根据数据库的实际情况对理论上等价的不同优化方案<strong>做出权衡</strong></li><li>产生可能的<strong>最优查询执行方案</strong></li><li>实际将一个SQL查询优化成更高效的方案</li></ol></li><li><p>类型</p><ol><li>RBO基于规则的优化器：给每个算子赋值一个权重，计算整个查询的总权重</li><li>CBO基于成本的优化器：还要考虑结果集大小<ul><li>优化目标：中间结果集的数量最少</li></ul></li></ol></li></ul><h1 id="2-基于规则的优化"><a href="#2-基于规则的优化" class="headerlink" title="2. 基于规则的优化"></a>2. 基于规则的优化</h1><ul><li><span style="background:rgba(3, 135, 102, 0.2)">要点：结构匹配和替换</span><ol><li>应用规则算法一般需要现在关系代数结构上匹配一部分局部结构</li><li>在根据结构的特点进行变换，替换</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F16-58-48-a760838c6f3725342a3536e93a7390d3-20240613165848-32932d.png" alt="image.png"></p><h1 id="3-基于成本的优化"><a href="#3-基于成本的优化" class="headerlink" title="3. 基于成本的优化"></a>3. 基于成本的优化</h1><p><span style="background:rgba(3, 135, 102, 0.2)">要点：执行计划的成本估算</span></p><p>遍历不同关系代数表示，枚举功能，得到最优方案。</p><h2 id="3-1-优化主要方向-连接"><a href="#3-1-优化主要方向-连接" class="headerlink" title="3.1. 优化主要方向-连接"></a>3.1. 优化主要方向-连接</h2><h3 id="3-1-1-嵌套循环连接（Nested-Loop-Join）"><a href="#3-1-1-嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="3.1.1. 嵌套循环连接（Nested-Loop Join）"></a>3.1.1. 嵌套循环连接（Nested-Loop Join）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-02-10-f24ab1df8bea51f8d89dcba316bcde3e-20240613170210-aeeba2.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-02-35-70192c6a4827b7a0f9f1af66c3e09f5f-20240613170235-750631.png" alt="image.png"></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1.m1 &gt; 1</span><br><span class="line">t1.m1 = t2.m2</span><br><span class="line">t2.n2 &lt; 'd'</span><br></pre></td></tr></table></figure></div><ul><li><p>左外连接</p><ul><li>T1 T2左外连接，T1记录都保留，T2如果没有相等的，结果集中是空值</li></ul></li><li><p><span style="background:rgba(3, 135, 102, 0.2)">驱动表只访问一次，但被驱动表却可能被多次访问</span>，访问次数取决于 对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为<span style="background:rgba(3, 135, 102, 0.2)">嵌套循环连接 ( Nested-Loop Join )</span></p></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-05-02-ce6ea7a731c15bd09390b2072d306728-20240613170502-db3580.png" alt="image.png"></p><h3 id="3-1-2-基于索引的连接优化"><a href="#3-1-2-基于索引的连接优化" class="headerlink" title="3.1.2. 基于索引的连接优化"></a>3.1.2. 基于索引的连接优化</h3><p>基于索引的连接优化：通过索引读取有限条的T2数据与T1连接</p><ol><li>被驱动表有索引的情况下，被驱动表被驱动表筛选的数据<strong>进行多次基于索引的查询</strong></li><li>如果有<strong>多个条件</strong>，需要多个索引，优化器选择某个索引进行执行</li><li>连接查询和过滤条件一般只涉及<strong>被驱动表的部分列</strong>，所以真实工作环境不要使用<code>*</code>作为查询列表<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-08-56-24a145188978dbfdd9725c4f22b6183a-20240613170856-d6e2ef.png" alt="image.png"></li></ol><h3 id="3-1-3-基于块的连接优化（Block-Nested-Loop-Join）"><a href="#3-1-3-基于块的连接优化（Block-Nested-Loop-Join）" class="headerlink" title="3.1.3. 基于块的连接优化（Block Nested-Loop Join）"></a>3.1.3. 基于块的连接优化（Block Nested-Loop Join）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-11-46-3ebf049bd6a19b2d509f9c8abba07ef4-20240613171146-3c374e.png" alt="image.png"></p><ol><li><strong>尽量减少访问被驱动表的次数</strong>（驱动表的记录不会都放入 join buffer，只会将部分列放入）</li><li>join buffer 足够大，就可以一次访问被驱动表完成连接</li><li>join buffer 一般 256KB（相比来看，索引仍然是最好的选择）</li></ol><h2 id="3-2-连接小结"><a href="#3-2-连接小结" class="headerlink" title="3.2. 连接小结"></a>3.2. 连接小结</h2><ol><li>本质上，连接就是把各个表中的路径都取出来依次进行匹配，并把匹配的组合返回 </li><li>外连接和内连接的本质都是确定驱动表  </li><li><strong>嵌套循环连接算法</strong>：驱动表连接一次，但被驱动表可能会访问多次，访问次数取决于被驱动表执行单表查询后结果集中有多少记录  </li><li>被驱动表会被连接多次，可以用索引加速</li><li>被驱动表很大，多次访问会导致更多的磁盘 I/O，基于块的嵌套循环算法来缓解</li></ol><h2 id="3-3-成本计算"><a href="#3-3-成本计算" class="headerlink" title="3.3. 成本计算"></a>3.3. 成本计算</h2><p>I/O成本：物理读写<br>CPU成本：比较，逻辑读写<br>…</p><h2 id="3-4-基于成本的优化步骤"><a href="#3-4-基于成本的优化步骤" class="headerlink" title="3.4. 基于成本的优化步骤"></a>3.4. 基于成本的优化步骤</h2><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算<strong>全表扫描的代价</strong>(row, data_length)</li><li>计算使用<strong>不同索引的代价</strong></li><li>对比各个查询优化方案的代价，找到成本最低的访问方式</li></ol><p><strong>好条件先做</strong></p><p>SQL-&gt;表达式-&gt;树-&gt;不断调整树的节点，找到最优执行路径-&gt;得到执行计划：可执行的代码</p><p><a class="link" href="https://juejin.cn/post/6990669704457093134">MySQL 是怎样运行的 - 基于成本的优化 - 掘金 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="3-4-1-全表扫描成本"><a href="#3-4-1-全表扫描成本" class="headerlink" title="3.4.1. 全表扫描成本"></a>3.4.1. 全表扫描成本</h3><ul><li>查询成本=<code>I/O</code>成本+<code>CPU</code>成本<ol><li><span style="background:rgba(3, 135, 102, 0.2)"> I/O成本</span>：聚簇索引占用的<strong>页面数</strong>，记录从磁盘到内存</li><li><span style="background:rgba(3, 135, 102, 0.2)">CPU成本</span>：该表中的<strong>记录行数</strong>，检测记录是否满足条件，对结果集排序</li></ol></li></ul><p>row：记录行数<br>data_length：占用字节数 = 页面数量 X 页面大小</p><p>物理读取一个页面默认成本是 1.0<br>逻辑读取和检测条件默认为 0.2</p><h3 id="3-4-2-使用不同索引执行查询的代价"><a href="#3-4-2-使用不同索引执行查询的代价" class="headerlink" title="3.4.2. 使用不同索引执行查询的代价"></a>3.4.2. 使用不同索引执行查询的代价</h3><ul><li>二级索引 + 回表<ol><li>估算范围区间数量：查询优化器认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的</li><li>需要回表的数量：优化器需要计算二级索引的某个范围区间到底包含多少条记录，可能是估算出来的</li></ol></li><li>I/O成本：范围区间的数量 （读取一个页的成本）+ 回表操作（二级索引记录条数）</li><li>CPU成本：计算二级索引记录条数的成本（二级索引记录条数，微调） + 读取并检测回表后聚簇索引记录的成本（二级索引记录条数）</li></ul><h3 id="3-4-3-两表连接的成本分析"><a href="#3-4-3-两表连接的成本分析" class="headerlink" title="3.4.3. 两表连接的成本分析"></a>3.4.3. 两表连接的成本分析</h3><ul><li><span style="background:rgba(3, 135, 102, 0.2)">连接查询的总成本</span> = 单次访问驱动表的成本 + 驱动表扇出 * 单次被驱动表的成本</li><li>不同驱动表的成本不一样，寻找成本最低的那个</li><li><span style="background:rgba(3, 135, 102, 0.2)">扇出值：根据条件占比计算</span></li><li>多表连接类似,，只是可选路径是 N 的阶乘</li></ul><h1 id="4-SQL的执行顺序"><a href="#4-SQL的执行顺序" class="headerlink" title="4. SQL的执行顺序"></a>4. SQL的执行顺序</h1><ol><li>SQL</li><li>语法语义检查</li><li><strong>解析</strong>：最消耗资源的步骤，选择最优执行路径，</li><li>执行计划</li><li>执行引擎</li><li>存储引擎</li><li>数据库</li></ol><h1 id="5-软解析：绑定变量"><a href="#5-软解析：绑定变量" class="headerlink" title="5. 软解析：绑定变量"></a>5. 软解析：绑定变量</h1><ul><li><strong>绑定变量</strong>：把所有常量变成变量<ul><li>数据库一般不默认启用</li><li>但ORM框架一般默认绑定变量，处于安全性考虑</li></ul></li><li>好处：<ol><li>相似查询使用变量，当成一个查询。实现软解析。</li><li>避免sql串的拼接，防止注入</li></ol></li><li>缺点：<ol><li>绑定变量之后，无法通过范围查询的范围估计扇出数量，进而估计最优查询路径。只能使用平均值估算。</li></ol></li></ul><h2 id="5-1-防止SQL注入攻击"><a href="#5-1-防止SQL注入攻击" class="headerlink" title="5.1. 防止SQL注入攻击"></a>5.1. 防止SQL注入攻击</h2><p>不把SQL串组合起来之后直接放到查询优化器里，而是先保留变量生成执行计划后再代入变量</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span> A<span class="operator">=</span>a</span><br></pre></td></tr></table></figure></div><p>变量a作为<strong>执行计划的参数</strong>传入，而不是直接拼到SQL串里</p><h2 id="5-2-把相似查询当成同一个查询，只是参数不同"><a href="#5-2-把相似查询当成同一个查询，只是参数不同" class="headerlink" title="5.2. 把相似查询当成同一个查询，只是参数不同"></a>5.2. 把相似查询当成同一个查询，只是参数不同</h2><ul><li>如果查询与数据值有关，<strong>绑定变量</strong>导致无法优化，如<code>WHERE 3 &lt; x &lt; 5</code></li></ul><p>硬解析：相似查询当成多条查询，单独执行，数据值固定。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> x <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> x <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>把所有常量编程变量</span><br><span class="line"><span class="keyword">WHERE</span> x <span class="operator">=</span> A<span class="operator">/</span><span class="operator">/</span>绑定变量</span><br></pre></td></tr></table></figure></div><h1 id="6-优化器只能对关系领域进行优化"><a href="#6-优化器只能对关系领域进行优化" class="headerlink" title="6. 优化器只能对关系领域进行优化"></a>6. 优化器只能对关系领域进行优化</h1><p>order by，group by等不属于关系代数的操作无法优化，是脱离关系代数独立执行的</p><p>例子：查询不适经理的员工中，工资最高的五个人？</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span><span class="operator">%</span> rownum是ORACLE方言 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> wrong <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> <span class="keyword">order</span> <span class="keyword">by</span>在前面的查询全部完成后再排序，就是只查询前<span class="number">5</span>条 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> empname, salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> status <span class="operator">!=</span> <span class="string">'EXEC'</span></span><br><span class="line"><span class="keyword">and</span> rownum <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> <span class="keyword">right</span> <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> 选择出符合条件并排序后，再选择前<span class="number">5</span>条 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> empname, salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> status <span class="operator">!=</span> <span class="string">'EXEC'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> rownum <span class="operator">&lt;=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>有效范围</strong><ol><li>优化器需要借助数据库中找到的信息</li><li>能够数据意义上等价变化</li><li>优化器考虑整体响应时间</li><li>优化器改善的是独立的查询</li></ol></li></ul><h1 id="7-优化器自动条件化解"><a href="#7-优化器自动条件化解" class="headerlink" title="7. 优化器自动条件化解"></a>7. 优化器自动条件化解</h1><ol><li>移除不必要的括号<ol><li>select from (t1, (t2, t3))</li><li>select from t1, t2, t3</li></ol></li><li>常量传递</li><li>移除没用的条件</li><li>表达式计算：<strong>只会对右侧修改，不会修改左侧</strong><ol><li>a=5+1</li><li>a=6</li><li>注意：-a&lt;8, a-1=6优化器不会优化<ul><li>语法语义检查的时候，无法预测左侧是不是函数索引f(x)</li></ul></li></ol></li><li>having子句和where子句合并<ol><li>没有聚合函数，group by子句时</li></ol></li><li>常量表检查，当成常量使用<ol><li>查询表中，只有一条或者没有记录</li><li>使用主键或唯一的二级索引键的等值查询</li></ol></li></ol><h1 id="8-使用SQL需要考虑的因素"><a href="#8-使用SQL需要考虑的因素" class="headerlink" title="8. 使用SQL需要考虑的因素"></a>8. 使用SQL需要考虑的因素</h1><ol><li>获得结果集所需访问的数据量（表大小）</li><li>定义结果集所需的查询条件<ul><li>过滤条件：where子句</li></ul></li><li>结果集的大小</li><li>获得结果集所涉及表的数量<ul><li>表的数量，from子句，不要超过5-8张表</li></ul></li><li>同时修改这些数据用户的多少</li></ol><h1 id="9-子查询"><a href="#9-子查询" class="headerlink" title="9. 子查询"></a>9. 子查询</h1><p>出现在某个查询语句的某个位置中的查询称为子查询</p><h2 id="9-1-嵌套子查询"><a href="#9-1-嵌套子查询" class="headerlink" title="9.1. 嵌套子查询"></a>9.1. 嵌套子查询</h2><ul><li>exist：<ol><li>关联嵌套子查询</li><li>内层查询绑定变量依赖外层查询，外层每有一个符合条件内查询都执行一次</li><li>外部条件好时，可以做到整个查询都在索引上完成，exist查询效率更高</li></ol></li><li>in：<ol><li>非关联嵌套子查询</li><li>内层查询不再依赖外层查询，只执行一次</li><li>内部结果集和外部结果集<strong>最差情况下要笛卡尔积</strong>。优化器要对内连接做优化。</li></ol></li></ul><h2 id="9-2-按返回结果区分子查询"><a href="#9-2-按返回结果区分子查询" class="headerlink" title="9.2. 按返回结果区分子查询"></a>9.2. 按返回结果区分子查询</h2><ol><li>标量子查询</li></ol><h2 id="9-3-优化"><a href="#9-3-优化" class="headerlink" title="9.3. 优化"></a>9.3. 优化</h2><ul><li>选择分辨率最大的条件</li><li>关键时In子查询的优化<ol><li>不相关子查询</li><li>如果子查询结果集记录少，内外层分别优化</li><li>子查询结果记录多，内存放不下。临时表，去重，构架哈希表。</li><li>大到内存放不下了临时表，磁盘物化表，构建B+树索引</li></ol></li></ul><h1 id="10-SQL优化的其他问题"><a href="#10-SQL优化的其他问题" class="headerlink" title="10. SQL优化的其他问题"></a>10. SQL优化的其他问题</h1>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>06-Linux内核</title>
    <link href="http://example.com/posts/612388c4/"/>
    <id>http://example.com/posts/612388c4/</id>
    <published>2024-05-13T03:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-编译内核"><a href="#1-编译内核" class="headerlink" title="1. 编译内核"></a>1. 编译内核</h1><p>有很多复杂的configure</p><ol><li>配置</li><li>make</li><li>启用内核</li></ol><h2 id="1-1-编译选项"><a href="#1-1-编译选项" class="headerlink" title="1.1. 编译选项"></a>1.1. 编译选项</h2><ul><li>config模式<ol><li>Y：加入内核</li><li>N：不加入内核</li><li>M：模块形式，先留一个地址，<code>.ko</code>文件。需要功能的时候可以去加载。</li></ol></li></ul><h2 id="1-2-启用新内核"><a href="#1-2-启用新内核" class="headerlink" title="1.2. 启用新内核"></a>1.2. 启用新内核</h2><ul><li>make install：把内核复制到\boot目录下<ul><li><font color="#c00000">慎用</font>，一般手动做这个操作</li></ul></li></ul><p>grub的引导菜单会多一个刚编译的内核</p><h2 id="1-3-初始化程序的建立"><a href="#1-3-初始化程序的建立" class="headerlink" title="1.3. 初始化程序的建立"></a>1.3. 初始化程序的建立</h2><ul><li>initrd<ul><li>系统启动时的第一个用户态程序，没有父进程的进程</li></ul></li></ul><h1 id="2-驱动"><a href="#2-驱动" class="headerlink" title="2. 驱动"></a>2. 驱动</h1><p>常见驱动的源代码集成在内核源码中</p><p>也有第三方驱动的开发，可以单独编译成模块<code>.ko</code></p><p>编译需要内核头文件的支持</p><h2 id="2-1-加载模块"><a href="#2-1-加载模块" class="headerlink" title="2.1. 加载模块"></a>2.1. 加载模块</h2><p>系统开机时没有加载，但可以在运行的时候加载模块</p><p>e.g. U盘驱动</p><ul><li>底层命令<ol><li><font color="#c00000">insmod</font>：<strong>把模块装载到内核里</strong></li><li>rmmod：从内核里释放模块</li></ol></li><li>高层命令<ol><li>modprobe：装载</li><li>modprobe -r：释放</li></ol></li></ul><h2 id="2-2-模块依赖"><a href="#2-2-模块依赖" class="headerlink" title="2.2. 模块依赖"></a>2.2. 模块依赖</h2><ul><li>lsmod：看当前已经装载到内核的模块<ul><li>和<code>cat /proc/modules</code>等价</li></ul></li><li>modinfo</li><li>moddep</li></ul><p>模块依赖：模块A引用模块B导出的符号，即模块B被模块A引用。如果要装载模块A，就要先装载模块B。</p><p>高层命令会解决依赖关系，而底层命令不会。</p><h2 id="2-3-模块通信"><a href="#2-3-模块通信" class="headerlink" title="2.3. 模块通信"></a>2.3. 模块通信</h2><ol><li>共享变量</li><li>调用函数</li></ol><h2 id="2-4-👍Linux内核模块与应用程序模块的区别"><a href="#2-4-👍Linux内核模块与应用程序模块的区别" class="headerlink" title="2.4. 👍Linux内核模块与应用程序模块的区别"></a>2.4. 👍Linux内核模块与应用程序模块的区别</h2><table><thead><tr><th></th><th>C</th><th>Linux内核模块</th></tr></thead><tbody><tr><td>运行</td><td>用户空间</td><td>内核空间</td></tr><tr><td>入口</td><td>main()</td><td>module_init()指定</td></tr><tr><td>出口</td><td>无</td><td>module_exit()指定</td></tr><tr><td>运行</td><td>直接指定</td><td>insmod</td></tr><tr><td>调试</td><td>gdb</td><td>kdbug,kdb,kgdb等</td></tr></tbody></table><ol><li>内核模块其实并不存在入口出口，init做初始化，exit做释放，加载后一直在内存里待命</li><li>内核模块真正执行的时候是用户态程序调用相关功能<ul><li>e.g. 内核加载了一段打印机的驱动，一直在内存里待命，在用户态程序（如Word）里点了打印，这段驱动才会被调用（通过系统调用）</li><li>要考虑并行会出现的问题，可能有多个用户同时打印</li></ul></li></ol><h2 id="2-5-内核程序注意事项"><a href="#2-5-内核程序注意事项" class="headerlink" title="2.5. 内核程序注意事项"></a>2.5. 内核程序注意事项</h2><ol><li>不能调用C库来开发驱动程序</li><li>没有内存保护机制</li><li>小内核栈<ul><li>内核一般不用递归否则会占用大量内存空间</li></ul></li><li>并发考虑</li><li>内核代码/Shell脚本没有类型浮点支持</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO <span class="string">"Hello world\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO <span class="string">"Goodbye world\n"</span>);</span><br><span class="line">}</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure></div><h2 id="2-6-编译"><a href="#2-6-编译" class="headerlink" title="2.6. 编译"></a>2.6. 编译</h2><p>内核Makefile和一般的不一样，而且经常更新</p><h2 id="2-7-模块参数传递"><a href="#2-7-模块参数传递" class="headerlink" title="2.7. 模块参数传递"></a>2.7. 模块参数传递</h2><ul><li>传递方式<ol><li>参数在模块加载时传递<ul><li>shell: <code>insmod hello.ko test=2</code></li></ul></li><li>参数需要使用module_param宏来声明<ul><li><code>module_param(变量名称，类型, 访问许可掩码)</code></li></ul></li></ol></li><li>支持参数类型<ul><li>Byte, short, ushort, int, uint, long, ulong, bool, charp</li><li>Array (module_param_array(name, type, nump, perm))</li></ul></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> test;</span><br><span class="line">module_param(test, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO “Hello world test=%d \n” , test);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO <span class="string">"Goodbye world\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Test"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"xxx"</span>);</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure></div><h1 id="3-字符型设备"><a href="#3-字符型设备" class="headerlink" title="3. 字符型设备"></a>3. 字符型设备</h1><h2 id="3-1-驱动程序的初始化加载过程"><a href="#3-1-驱动程序的初始化加载过程" class="headerlink" title="3.1. 驱动程序的初始化加载过程"></a>3.1. 驱动程序的初始化加载过程</h2><ol><li><strong>申请设备号</strong></li><li>定义<strong>文件操作结构体</strong> file_operations</li><li>创建并初始化定义<strong>结构体 cdev</strong><ol><li><code>struct cdev *my_cdev = cdev_alloc();</code></li><li><code>my_cdev-&gt;ops = &amp;my_fops;</code></li><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops);</code>和2功能差不多。</li></ol></li><li>将<strong>cdev注册到系统</strong>，并和对应的<strong>设备号绑定</strong><ul><li><code>int cdev_add(struct cdev *dev, dev_t num, unsigned int count);</code></li></ul></li><li>在/dev文件系统中用<strong>mknod创建设备文件</strong>，并将该文件<strong>绑定到设备号上</strong><ul><li><code>mknod {{path/to/device_file}} c {{major_device_number}} {{minor_device_number}}</code></li></ul></li></ol><h2 id="3-2-主设备号和次设备号"><a href="#3-2-主设备号和次设备号" class="headerlink" title="3.2. 主设备号和次设备号"></a>3.2. 主设备号和次设备号</h2><ul><li>一个字符设备或者块设备都有一个主设备号和次设备号。</li><li>主设备号和次设备号统称为设备号。</li><li>主设备号用来表示<strong>一个特定的驱动程序</strong>。</li><li>次设备号用来表示<strong>使用该驱动程序的各设备</strong>。</li></ul><h2 id="3-3-应用程序调用驱动"><a href="#3-3-应用程序调用驱动" class="headerlink" title="3.3. 应用程序调用驱动"></a>3.3. 应用程序调用驱动</h2><ol><li><strong>加载设备驱动</strong>：应用程序需要加载一个驱动模块（.ko文件），这个过程会生成一个设备文件，该文件代表了驱动程序控制的硬件设备或本地设备</li><li><strong>打开设备文件</strong>：应用程序使用系统提供的函数（如<code>open()</code>）来打开设备文件。这些函数最终会通过内核转发到相应的驱动函数。每个设备文件都有一个对应的inode结构体，包含了设备的主次设备号，是设备的唯一标识</li><li><strong>执行系统调用</strong>：应用程序通过执行系统调用（如<code>read()</code>, <code>write()</code>, <code>ioctl()</code>等）与设备驱动进行交互。这些调用最终会通过内核转发到相应的驱动函数</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>05-架构设计</title>
    <link href="http://example.com/posts/9e04b6b3/"/>
    <id>http://example.com/posts/9e04b6b3/</id>
    <published>2024-05-09T02:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ASR"><a href="#1-ASR" class="headerlink" title="1. ASR"></a>1. ASR</h1><p>Architecturally SIgnificant Requirement(ASR)：对架构有重要影响的需求</p><h2 id="1-1-获取"><a href="#1-1-获取" class="headerlink" title="1.1. 获取"></a>1.1. 获取</h2><h3 id="1-1-1-从需求文档"><a href="#1-1-1-从需求文档" class="headerlink" title="1.1.1. 从需求文档"></a>1.1.1. 从需求文档</h3><ul><li>MoSCoW：需求的四个级别，判断优先级和重要性<ol><li>Master</li><li>Should</li><li>Could</li><li>Won’t</li></ol></li></ul><p>仅仅从需求文档无法获得完整、充分、详细的信息</p><h3 id="1-1-2-座谈会-研讨会"><a href="#1-1-2-座谈会-研讨会" class="headerlink" title="1.1.2. 座谈会/研讨会"></a>1.1.2. 座谈会/研讨会</h3><p>Quality Attribute Workshop(QAW)</p><h1 id="2-设计决策👍"><a href="#2-设计决策👍" class="headerlink" title="2. 设计决策👍"></a>2. 设计决策👍</h1><p>七要素：</p><h2 id="2-1-分解"><a href="#2-1-分解" class="headerlink" title="2.1. 分解"></a>2.1. 分解</h2><p>把系统为了实现功能需求和非功能需求的责任进行分解，分配给被分解的元素</p><h2 id="2-2-设计ASR"><a href="#2-2-设计ASR" class="headerlink" title="2.2. 设计ASR"></a>2.2. 设计ASR</h2><ul><li>适用非ASR需求<ol><li>架构设计不影响非ASR的需求</li><li>需要对架构设计做调整，小范围调整</li><li>非ASR需求无法满足，要做一些妥协<ol><li>接近满足需求</li><li>调整需求</li><li>无法满足这些需求</li></ol></li></ol></li><li>是否要一次性设计所有的ASR？<ol><li>从经验判断</li><li>是完全从零开发，还是已经完成一部分，或是有框架</li></ol></li></ul><h2 id="2-3-生成和测试"><a href="#2-3-生成和测试" class="headerlink" title="2.3. 生成和测试"></a>2.3. 生成和测试</h2><p>验证和评估</p><ul><li><p>如何测试</p><ol><li>分析技术：静态建模，动态仿真技术</li><li>设计checklist</li></ol></li><li><p>什么时候完成验证</p><ol><li>设计满足ASR</li><li>预算不够，实现目前为止最佳的设计</li></ol></li></ul><h1 id="3-Attribute-Driven-Design-ADD"><a href="#3-Attribute-Driven-Design-ADD" class="headerlink" title="3. Attribute-Driven Design(ADD)"></a>3. Attribute-Driven Design(ADD)</h1><p>通用场景下的软件系统设计</p><h2 id="3-1-ADD的输入"><a href="#3-1-ADD的输入" class="headerlink" title="3.1. ADD的输入"></a>3.1. ADD的输入</h2><ol><li>是否有足够的需求？</li><li>是否已经筛选出ASR？</li><li>是否已经排序？</li><li>使用基于场景（刺激响应）的描述方式精确描述？</li></ol><h2 id="3-2-选择一个系统元素进行分解"><a href="#3-2-选择一个系统元素进行分解" class="headerlink" title="3.2. 选择一个系统元素进行分解"></a>3.2. 选择一个系统元素进行分解</h2><ul><li>分类<ol><li>greenfield开发：所有需求，整个系统作为设计焦点</li><li>partially designed system：在当前已经设计过的系统里选择一些元素作为设计焦点</li></ol></li></ul><h2 id="3-3-选择和当前迭代相关的ASR"><a href="#3-3-选择和当前迭代相关的ASR" class="headerlink" title="3.3. 选择和当前迭代相关的ASR"></a>3.3. 选择和当前迭代相关的ASR</h2><p>说明对用户的重要程度<br>说明对开发者的难易程度</p><p>排序：<br>(H,H)(H,M)(H,L)(M,H)…</p><h2 id="3-4-生成局部设计"><a href="#3-4-生成局部设计" class="headerlink" title="3.4. 生成局部设计"></a>3.4. 生成局部设计</h2><ol><li><strong>设计焦点</strong>承载的ASR怎么解决</li><li>列出所有patterns和tactics<ol><li>定义可配置的参数。e.g.ping/echo的timeout时间</li><li>估计参数值</li></ol></li><li>选择pattern和tactic<ol><li>对整体（当前设计焦点的各个ASR）的影响</li><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F09%2F11-08-06-b5b07ddb02853be9baf16f2cac386b1a-20240509110805-cc752b.png" alt="image.png"></li></ol></li><li>决定pattern/tactic和ASR的关系<ol><li>哪些要做调整，结合</li></ol></li><li>设计决定可视化成一个或一组视图</li><li>评估<ol><li>哪些ASR没有被考虑到</li><li>是否需要做额外修正</li><li>所有设计决定会不会不一致</li></ol></li></ol><h2 id="3-5-实例化架构元素，分配职责"><a href="#3-5-实例化架构元素，分配职责" class="headerlink" title="3.5. 实例化架构元素，分配职责"></a>3.5. 实例化架构元素，分配职责</h2><ol><li>实例化每一个架构元素</li><li>把设计焦点承担的责任分配到架构元素</li><li>把实例化和责任记录下来</li></ol><h2 id="3-6-为实例化元素定义接口"><a href="#3-6-为实例化元素定义接口" class="headerlink" title="3.6. 为实例化元素定义接口"></a>3.6. 为实例化元素定义接口</h2><p>交互哪些数据<br>元素之间的交互关系</p><h2 id="3-7-验证和完善需求，并使其成为实例化元素的约束"><a href="#3-7-验证和完善需求，并使其成为实例化元素的约束" class="headerlink" title="3.7. 验证和完善需求，并使其成为实例化元素的约束"></a>3.7. 验证和完善需求，并使其成为实例化元素的约束</h2><ol><li>验证设计需求是不是都分配到元素上</li><li>把每个元素的职责翻译成功能需求</li></ol><h2 id="3-8-重复直到所有ASR都满足"><a href="#3-8-重复直到所有ASR都满足" class="headerlink" title="3.8. 重复直到所有ASR都满足"></a>3.8. 重复直到所有ASR都满足</h2><p>每一次迭代都满足一些ASR，如果还有ASR没有完成回到第二步，选择系统中一个元素作为设计新的焦点</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F09%2F11-18-13-9377fac25e8135c67c87d8dcc3b099a3-20240509111812-df4de9.png" alt="image.png"></p><h2 id="3-9-ADD的输出"><a href="#3-9-ADD的输出" class="headerlink" title="3.9. ADD的输出"></a>3.9. ADD的输出</h2><ol><li>软件元素：履行各种角色和<strong>职责</strong>，具有预定<strong>属性</strong>并与其他软件元素相关以组成系统架构的计算或开发工件</li><li>角色</li><li>职责</li><li>性质</li><li>关系：使用视图表示元素之间的关联</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F09%2F11-22-20-c0b9137fbe7364b63e9e02a1583542ab-20240509112220-2a2a8b.png" alt="image.png"></p><h1 id="ADD例子"><a href="#ADD例子" class="headerlink" title="ADD例子"></a>ADD例子</h1><p><a class="link" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Lec15-Design/#3-%E5%9F%BA%E4%BA%8Eadd%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%9E%E4%BE%8B">2021-软件系统设计-Lec15-Design - SpriCoder的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>04-架构模式</title>
    <link href="http://example.com/posts/12c16a93/"/>
    <id>http://example.com/posts/12c16a93/</id>
    <published>2024-05-07T06:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<p>解决特定问题的设计决定的集合，但是可以参数化配置。</p><ul><li><p>DSSA 领域特定软件架构</p><ol><li>面向特定任务(task/domain)</li><li>在这个领域里是通用的</li><li>标准结构</li></ol></li><li><p>架构模式</p><ol><li>背景</li><li>问题</li><li>解决方案（Element + Relations + Constraints）</li></ol></li><li><p>设计模式  </p><ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-09-51-8b4e00572f757ad428e4008f69aa83da-20240507140950-fa7584.png" alt="image.png"></li></ul></li><li><p>架构模式分类</p><ol><li>Module</li><li>Component-Connector<ol><li>在Runtime动态建立联系</li></ol></li><li>Allocation</li></ol></li></ul><h1 id="1-Layered-Pattern"><a href="#1-Layered-Pattern" class="headerlink" title="1. Layered Pattern"></a>1. Layered Pattern</h1><ul><li>Module类架构</li><li>解释<ol><li>一个Layer里包含多个Module，不存在跨层的Module</li><li>限制层与层之间的依赖关系，质量属性的可修改性策略就使用了分层</li><li>各层之间不能跨层调用，只能上面调下面，<font color="#ff0000">关注点分离</font></li></ol></li><li>影响的质量属性：可修改性、可模块化、可维护性、可复用性</li></ul><h2 id="1-1-Solution"><a href="#1-1-Solution" class="headerlink" title="1.1. Solution"></a>1.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-16-47-b199ddcbdff99b04e268ba2e7d332b4c-20240507141646-1ef7b2.png" alt="image.png"></p><ul><li>元素：层，包含一些模块</li><li>关系：allowed-to-use</li><li>限制<ol><li>每个模块只能被分配到一层</li><li>至少有两层</li><li>allowed-to-use关系不能是环，低层不能调用高层</li></ol></li><li>弱点<ol><li>增加层很复杂</li><li>性能</li></ol></li></ul><h2 id="1-2-Pattern"><a href="#1-2-Pattern" class="headerlink" title="1.2. Pattern"></a>1.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-18-30-444d6cbeb1cdbf4fa785de6b61092876-20240507141829-67d177.png" alt="image.png"></p><hr><p>如果D是sidecar，那么也是分层；但如果D也有一定业务，则不是分层<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-25-46-741bf1a29993aa374ab8a6754a9fb3bd-20240507142545-72c020.png" alt="image.png"></p><h1 id="2-Broker-Pattern"><a href="#2-Broker-Pattern" class="headerlink" title="2. Broker Pattern"></a>2. Broker Pattern</h1><ul><li>Component-Connector类模式</li></ul><h2 id="2-1-Solution"><a href="#2-1-Solution" class="headerlink" title="2.1. Solution"></a>2.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-34-43-2c21c09e9de3e3b8c04404d72a18db01-20240507143442-cee395.png" alt="image.png"></p><ul><li>元素<ol><li>Client</li><li>Server</li><li>Broker：中介，帮助client找到server，传递请求</li></ol></li><li>约束：一个客户端只能连接一个中介，服务端也是</li><li>分析<ol><li>提升了互操作性、可修改性</li><li>现代场景下如果有多个broker实例，可以提高扩展性、安全性、可用性（补充设计）</li><li>可能<strong>单点失效，减低性能、安全性、可用性</strong></li><li>减低可测试性，无法预先确定client和server的状态</li></ol></li></ul><h2 id="2-2-Pattern"><a href="#2-2-Pattern" class="headerlink" title="2.2. Pattern"></a>2.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-36-41-5112182333c844cc84ff216ca67d7c03-20240507143641-9c99b5.png" alt="image.png"></p><h1 id="3-Model-View-Controller-Pattern"><a href="#3-Model-View-Controller-Pattern" class="headerlink" title="3. Model-View-Controller Pattern"></a>3. Model-View-Controller Pattern</h1><ul><li>类型<ol><li>从动态看属于Component-Connector  </li><li>从开发态看属于Module</li></ol></li></ul><h2 id="3-1-Solution"><a href="#3-1-Solution" class="headerlink" title="3.1. Solution"></a>3.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-54-35-cc6e1787efc5b7097c73cbb1ae914782-20240507145434-fb3e5b.png" alt="image.png"></p><ul><li>元素<ol><li>model：业务逻辑</li><li>view：向用户展示，接受用户操作</li><li>controller：对用户操作进行处理，把消息通知给model</li></ol></li><li>关系：通知</li><li>约束：<ol><li>每个元素至少有一个实例</li><li>model不能直接和controller交互，controller单向操作Model</li></ol></li><li>弱点：对于简单的用户界面过于复杂</li></ul><h2 id="3-2-Pattern"><a href="#3-2-Pattern" class="headerlink" title="3.2. Pattern"></a>3.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-54-49-7e40f48489e84a51c5331bf99eb8f877-20240507145448-7baa06.png" alt="image.png"></p><h1 id="4-Pipe-and-Filter-Pattern"><a href="#4-Pipe-and-Filter-Pattern" class="headerlink" title="4. Pipe-and-Filter Pattern"></a>4. Pipe-and-Filter Pattern</h1><ul><li>类别：Component-Connector</li></ul><h2 id="4-1-Solution"><a href="#4-1-Solution" class="headerlink" title="4.1. Solution"></a>4.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-56-07-9ecaef916b1c000ee9724bf806272c79-20240507145607-deab29.png" alt="image.png"></p><ul><li><p>元素</p><ol><li>pipe<ul><li>相当于Connector</li><li>必须有数据的输入和输出</li><li>连接一系列的数据处理/计算</li></ul></li><li>filter<ul><li>相当于Component，通过pipe连起来</li><li>处理数据，计算</li><li>有input和多个output</li></ul></li></ol></li><li><p>限制</p><ol><li>系统里不可能只有孤立的pipe</li></ol></li><li><p>弱点</p><ol><li>不适合交互式系统</li><li>有大量的独立过滤器会增加计算开销</li><li>不适合长时间运行的计算</li></ol></li></ul><h2 id="4-2-Pattern"><a href="#4-2-Pattern" class="headerlink" title="4.2. Pattern"></a>4.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-57-55-2764955e71cac24cc8a6b8df474c15a6-20240507145754-7b1c94.png" alt="image.png"></p><h1 id="5-Client-Server-Pattern"><a href="#5-Client-Server-Pattern" class="headerlink" title="5. Client-Server Pattern"></a>5. Client-Server Pattern</h1><ul><li>类型：CC</li></ul><h2 id="5-1-Solution"><a href="#5-1-Solution" class="headerlink" title="5.1. Solution"></a>5.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-59-19-36800fe2562f1df5520f11d28f81167d-20240507145918-c888d4.png" alt="image.png"></p><ul><li><p>元素</p><ol><li>Client</li><li>Server</li></ol></li><li><p>不需要broker：在有限的网络中，有哪些服务是预先知道的,client和server的关系不需要动态改变</p></li><li><p>分析：</p><ul><li>CS架构导致互操作性降低，没有broker需要，人为连接。</li><li>可能被拦截</li></ul></li></ul><h2 id="5-2-Pattern"><a href="#5-2-Pattern" class="headerlink" title="5.2. Pattern"></a>5.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-03-13-fe3a35814348e258c7bcbf1c77e4d792-20240507150312-39032f.png" alt="image.png"></p><h1 id="6-Peer-to-Peer-Pattern"><a href="#6-Peer-to-Peer-Pattern" class="headerlink" title="6. Peer-to-Peer Pattern"></a>6. Peer-to-Peer Pattern</h1><ul><li>类型：CC</li></ul><p>没有明确的地位差距</p><p>节点可以自由加入退出</p><h2 id="6-1-Solution"><a href="#6-1-Solution" class="headerlink" title="6.1. Solution"></a>6.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-04-53-895cb73111b3ab647bb300595b8a7a2a-20240507150452-821875.png" alt="image.png"></p><ul><li>元素：<ol><li>peer即可以发送也可以接受数据</li><li>request/reply connector</li></ol></li><li>关系：peer之间的连接器</li><li>约束<ol><li>每个节点的最大连接数</li><li>节点的hops(hops：限制可感知的范围)</li><li>哪个节点知道其他节点的信息，有一些p2p网络时星型拓扑</li></ol></li><li>分析<ol><li>提高了系统的可伸缩性</li><li>牺牲安全性：检点既是客户端又是服务端，被攻击可能增加</li><li>可用性：数据分布在不同节点上，可能导致数据不一致，但个别数据有问题不影响整体</li><li>性能：多个节点同时提供服务，新能好</li></ol></li></ul><h2 id="6-2-Pattern"><a href="#6-2-Pattern" class="headerlink" title="6.2. Pattern"></a>6.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-07-03-98cf5b4315536a76cde2239249b648c1-20240507150702-8ce395.png" alt="image.png"></p><h1 id="7-Service-Oriented-SOA-Pattern"><a href="#7-Service-Oriented-SOA-Pattern" class="headerlink" title="7. Service-Oriented/SOA Pattern"></a>7. Service-Oriented/SOA Pattern</h1><ul><li>类型：cc</li><li>计算是使用一组<strong>通过网络提供消费服务的协作组件</strong>实现的。计算通常使用工作流语言进行描述。</li></ul><h2 id="7-1-Solution"><a href="#7-1-Solution" class="headerlink" title="7.1. Solution"></a>7.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-15-38-887fee6231c05c8479e0b486f04e1aaf-20240507151537-92c286.png" alt="image.png"></p><ul><li>Component<ol><li>Service Provider</li><li>Service Consumer</li><li>Registry：注册服务</li><li>ESB：企业服务总线，client到server的通信路由，类似broker</li><li>Orchestration server：编排组织业务</li></ol></li><li>Connector:<ol><li>SOAP（简单对象访问协议）</li><li>REST</li><li>异步消息传递（即忘即发）：参与者不必等待确认。</li></ol></li><li>弱点<ol><li>SOA系统构建很复杂，无法控制独立服务的演变</li><li>中间件存在性能开销，服务可能还曾为性能瓶颈，通常不提供性能开销</li></ol></li></ul><p>可以访问到其他组织，不同技术实现的服务<br>质量属性：提高互操作性</p><h2 id="7-2-Pattern"><a href="#7-2-Pattern" class="headerlink" title="7.2. Pattern"></a>7.2. Pattern</h2><p>虚线：组织边界，内部可以完全由组织控制</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-20-03-4ccbe77739cadb305da03a2116dd50eb-20240507152003-12bdce.png" alt="image.png"></p><h1 id="8-Publish-Subscribe-Pattern"><a href="#8-Publish-Subscribe-Pattern" class="headerlink" title="8. Publish-Subscribe Pattern"></a>8. Publish-Subscribe Pattern</h1><ul><li>类型：CC</li></ul><h2 id="8-1-Solution"><a href="#8-1-Solution" class="headerlink" title="8.1. Solution"></a>8.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-25-01-b1aa62975ac9705c2737a903557f5e59-20240507152501-de822f.png" alt="image.png"></p><ul><li>元素<ol><li>事件分发器：connector/component</li><li>发布者/订阅者：component，存在多对多的关系</li></ol></li><li>弱点：<ol><li>增加延迟</li><li>降低可扩展性</li><li>难以预测消息什么时候收到】</li><li>不能保证一定会接收到，或即时接收到</li></ol></li></ul><h2 id="8-2-Pattern"><a href="#8-2-Pattern" class="headerlink" title="8.2. Pattern"></a>8.2. Pattern</h2><p>在OS中事件处理普遍使用</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-25-11-dda2131381aa560a984e411503e4faf0-20240507152510-7f26d2.png" alt="image.png"></p><h1 id="9-Shared-Data-Pattern"><a href="#9-Shared-Data-Pattern" class="headerlink" title="9. Shared-Data Pattern"></a>9. Shared-Data Pattern</h1><ul><li>类型：CC</li></ul><h2 id="9-1-Solution"><a href="#9-1-Solution" class="headerlink" title="9.1. Solution"></a>9.1. Solution</h2><p>存在中心的被共享的数据</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-27-04-13c8a8d1b5b7924a527dee2dca6ab41c-20240507152703-ca7333.png" alt="image.png"></p><ul><li>元素<ol><li>共享数据存储Shared-data store.</li><li>数据访问组件Data accessor component.</li><li>数据读写连接器Data readin and writin connector.</li></ol></li><li>限制：只能通过数据访问组件和数据交互</li><li>分析<ol><li>星型结构，可能单点失效，性能瓶颈</li><li>想要获取数据高一致性、实时性时的妥协</li></ol></li></ul><h2 id="9-2-Pattern"><a href="#9-2-Pattern" class="headerlink" title="9.2. Pattern"></a>9.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-28-17-8bc18054676d4840b527b2b0f755f94d-20240507152816-a848b3.png" alt="image.png"></p><h1 id="10-Map-Reduce-Pattern"><a href="#10-Map-Reduce-Pattern" class="headerlink" title="10. Map-Reduce Pattern"></a>10. Map-Reduce Pattern</h1><ul><li>类型：Allocation<br>通过并行提高了性能</li></ul><h2 id="10-1-Solution"><a href="#10-1-Solution" class="headerlink" title="10.1. Solution"></a>10.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-34-47-8ff14e9d91dc5c25f1491a01e2d84019-20240507153447-99021c.png" alt="image.png"></p><ul><li>元素<ol><li>Map：任务分割，一组相同的任务并行，每一个任务都在一个Map上处理 。信息抽取，转换。</li><li>Reduce：把Map的输出整合在一起，变成单一输出</li></ol></li><li>关系：<ol><li>Deploy on是 map 或 Reduce 函数实例与安装该函数的处理器之间的关系。</li><li>实例化、监视和控制是基础架构与 map 和 Reduce 实例之间的关系。</li></ol></li><li>约束<ol><li>要分析的数据必须以一组文件的形式存在</li><li>map 函数是无状态的，彼此之间不通信</li><li>map 实例和 Reduce 实例之间的唯一通信是从 map 实例以 &lt;key, value&gt;对形式发出的数据。</li></ol></li><li>弱点<ol><li>要求数据是大量的，否则map-reduce的代价不划算  </li><li>如果不能把数据集划分成多个相似的子集，无法发挥并行的优势</li><li>需要多次reduce的操作协调起来很复杂。</li></ol></li></ul><h2 id="10-2-Pattern"><a href="#10-2-Pattern" class="headerlink" title="10.2. Pattern"></a>10.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-35-10-c5969942e099ae089a1227eaf43e1fc7-20240507153509-36694f.png" alt="image.png"></p><h1 id="11-Multi-Tier-Pattern"><a href="#11-Multi-Tier-Pattern" class="headerlink" title="11. Multi-Tier Pattern"></a>11. Multi-Tier Pattern</h1><ul><li>类型：Allocation</li></ul><h2 id="11-1-Solution"><a href="#11-1-Solution" class="headerlink" title="11.1. Solution"></a>11.1. Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-37-11-613758ec02833ece319fcc0f8b7892df-20240507153710-1a1259.png" alt="image.png"></p><p>Tier：逻辑的分层，不是真实存在的层，没有分层模式的强依赖关系。软件的每一个计算资源作为一个Tier。<br>分层模式中的Layer时真实存在的</p><ul><li>元素<ol><li>Tier</li></ol></li><li>关系：<ul><li>Is part of：把组件组织成层</li><li>Communicates with，层和组件之间通信</li><li>Allocated to：为了把层映射到计算平台</li></ul></li><li>约束<ul><li>一个软件组件只能属于一个层</li></ul></li><li>弱点<ul><li>前期成本高且复杂</li></ul></li></ul><h2 id="11-2-Pattern"><a href="#11-2-Pattern" class="headerlink" title="11.2. Pattern"></a>11.2. Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-38-03-070c12b3a26b2de121f315cd2e0ca9ce-20240507153803-a48a52.png" alt="image.png"></p><h1 id="12-Pattern和Tactic"><a href="#12-Pattern和Tactic" class="headerlink" title="12. Pattern和Tactic"></a>12. Pattern和Tactic</h1><p>Pattern：一组设计决定<br>Tactic：最小单元</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-41-41-6ecf53de649ae4edf390216d51159112-20240507154140-dc2113.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>05-质量管理</title>
    <link href="http://example.com/posts/8294aeb9/"/>
    <id>http://example.com/posts/8294aeb9/</id>
    <published>2024-05-07T02:05:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#c00000">管理定义：目标定义，状态跟踪，纠偏</font></p><h1 id="1-质量策略"><a href="#1-质量策略" class="headerlink" title="1. 质量策略"></a>1. 质量策略</h1><h2 id="1-1-质量概念"><a href="#1-1-质量概念" class="headerlink" title="1.1. 质量概念"></a>1.1. 质量概念</h2><ol><li>软件质量为“与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体”。[ANSI/IEEE STd 729]</li><li>软件质量为内外两部分的特性：其外部质量特性面向软件产品的最终用户，其内部质量特性则不直接面向最终用户。 《代码大全》</li><li>软件质量为软件产品可以改变世界，使世界更加美好的程度。从用户的角度考察软件质量，用户满意度是最为重要的判断标准。 [Tom Demarco]</li><li>软件质量为对人（用户）的价值。这一定义强调了质量的主观性，即对同一款软件而言，不同的用户对其质量有不同的体验。 [Gerald Weinberg]</li></ol><p>内部，外部，主观</p><h2 id="1-2-面向用户的质量观"><a href="#1-2-面向用户的质量观" class="headerlink" title="1.2. 面向用户的质量观"></a>1.2. 面向用户的质量观</h2><ul><li>面向用户的质量观：<font color="#ff0000">定义质量为满足用户需求的程度</font><ol><li>用户是谁？<ul><li>客户不一定是用户</li></ul></li><li>用户需求是否有优先级？<ul><li>和用户对软件的期望有关</li></ul></li><li>这种用户优先级对软件产品的开发过程产生什么样的影响？</li><li>怎样来度量这种质量观下的质量水平？</li></ol></li></ul><p><strong>软件可工作，可度量：优先级高</strong></p><ul><li>典型的用户期望<ol><li>产品必须能工作</li><li>产品最好有比较快的执行速度</li><li>产品在安全性、保密性、可用性、可靠性、兼容性、可维护性、可移植性等方面表现优异</li></ol></li></ul><h2 id="1-3-PSP质量策略"><a href="#1-3-PSP质量策略" class="headerlink" title="1.3. PSP质量策略"></a>1.3. PSP质量策略</h2><ol><li>首先确保基本没有缺陷，在考察其他质量目标</li><li><font color="#c00000">用缺陷管理代替质量管理</font><ol><li><strong>缺陷管理的正当性</strong>：如果软件没有缺陷，其他质量属性也会比较好。</li><li>安全，隐私，交互友好等几乎都无法有效管理</li></ol></li><li>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷</li><li>各组件的高质量是通过<strong>高质量评审</strong>来实现的<ol><li><strong>测试是获取质量状态的手段</strong>，而不是提高质量的手段</li><li>经验数据：假设项目缺陷综述确定（但我们不知道），测试团队的消除缺陷能力稳定，测试的时候发现一个错误就有一个没发现的错误，所以<strong>希望暴露出来的错误越少越好</strong></li></ol></li></ol><p>重视Code Review<br>一旦缺陷到了系统级，消除成本会很高，所以要在早期消除</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F11-30-25-59455ef6704a5fcaf74d7e6dfb12abdb-20240507113024-e75a5a.png" alt="image.png"></p><h2 id="1-4-消除缺陷的典型流程"><a href="#1-4-消除缺陷的典型流程" class="headerlink" title="1.4. 消除缺陷的典型流程"></a>1.4. 消除缺陷的典型流程</h2><h3 id="1-4-1-测试消除缺陷的典型流程"><a href="#1-4-1-测试消除缺陷的典型流程" class="headerlink" title="1.4.1. 测试消除缺陷的典型流程"></a>1.4.1. 测试消除缺陷的典型流程</h3><ol><li>发现待测程序的一个异常行为</li><li>理解程序的工作方式<ul><li>Measure twice, cut once</li></ul></li><li>调试程序，找出出错的位置，确定出错原因<ul><li>耗时</li></ul></li><li>确定修改方案，修改缺陷</li><li>回归测试，以确认修改有效</li></ol><h3 id="1-4-2-评审消除缺陷典型流程"><a href="#1-4-2-评审消除缺陷典型流程" class="headerlink" title="1.4.2. 评审消除缺陷典型流程"></a>1.4.2. 评审消除缺陷典型流程</h3><p>经过适当培训和基类，有经验的评审者可以发现80%左右的缺陷</p><ol><li>遵循评审者的逻辑来理解程序流程</li><li>发现缺陷，知道缺陷的位置和原因</li><li>修正缺陷</li></ol><p>评审时机：先评审，再编译</p><h2 id="1-5-质量指标"><a href="#1-5-质量指标" class="headerlink" title="1.5. 质量指标"></a>1.5. 质量指标</h2><p>过程度量：在过程中度量出来数值，根据这个数值还有机会在过程中修正<br>结果度量：算出来就没法修改</p><h3 id="1-5-1-Yield"><a href="#1-5-1-Yield" class="headerlink" title="1.5.1. Yield"></a>1.5.1. Yield</h3><p><strong>结果度量</strong><br><strong>缺陷消除的效率</strong>，度量每个阶段在消除缺陷方面的效率，Yield 指标越高越好，Process Yield 我们期望在 80 以上</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="74.438ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 32901.4 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(751,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(1327,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1856,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(2325,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(2791,0)"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"></path></g><g data-mml-node="mi" transform="translate(3554,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3899,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4365,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(4663,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(5460.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(6516.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path></g><g data-mml-node="mo" transform="translate(8238.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(9239,0)"><g data-mml-node="mrow" transform="translate(6831.2,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">某</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">阶</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">发</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">现</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缺</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">陷</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">某</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">阶</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">注</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">入</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缺</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">陷</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mo" transform="translate(9222.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(10222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">进</text></g><g data-mml-node="mi" transform="translate(11222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">入</text></g><g data-mml-node="mi" transform="translate(12222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">该</text></g><g data-mml-node="mi" transform="translate(13222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">阶</text></g><g data-mml-node="mi" transform="translate(14222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="mi" transform="translate(15222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">前</text></g><g data-mml-node="mi" transform="translate(16222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">遗</text></g><g data-mml-node="mi" transform="translate(17222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">留</text></g><g data-mml-node="mi" transform="translate(18222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(19222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缺</text></g><g data-mml-node="mi" transform="translate(20222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">陷</text></g><g data-mml-node="mi" transform="translate(21222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(22222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="23422.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="52.968ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 23412 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(751,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1202,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1687,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(2120,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(2586,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(3055,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(3524,0)"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"></path></g><g data-mml-node="mi" transform="translate(4287,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4632,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(5098,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(5396,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(6193.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(7249.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path></g><g data-mml-node="mo" transform="translate(8971.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mfrac" transform="translate(9972,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">第</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">次</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">编</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">译</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">前</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">发</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">现</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缺</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">陷</text></g><g data-mml-node="mi" transform="translate(11000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(12000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">第</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">次</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">编</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">译</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">前</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">注</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">入</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">缺</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">陷</text></g><g data-mml-node="mi" transform="translate(11000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(12000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="13200" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p>问题：知道分子，但是不知道分母</p><p>设计、编码注入缺陷<br>评审、测试消除缺陷</p><h3 id="1-5-2-A-FR"><a href="#1-5-2-A-FR" class="headerlink" title="1.5.2. A/FR"></a>1.5.2. A/FR</h3><p><strong>过程度量</strong><br><strong>质检失效时间比</strong>:理论上 A/FR越大，意味着质量越高，说明评审越充分<br>2.0是比较理想的值，ASR过大说明开发效率低下</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.059ex;" xmlns="http://www.w3.org/2000/svg" width="58.087ex" height="5.285ex" role="img" focusable="false" viewBox="0 -1426 25674.6 2336"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(750,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(1250,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(1999,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(3035.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4091.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(751,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(1396,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(2147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">质</text></g><g data-mml-node="mi" transform="translate(3147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">检</text></g><g data-mml-node="mi" transform="translate(4147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(5147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">本</text></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(751,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(1396,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(2147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">失</text></g><g data-mml-node="mi" transform="translate(3147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">效</text></g><g data-mml-node="mi" transform="translate(4147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mi" transform="translate(5147,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">本</text></g></g><rect width="6347" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(10956.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(12012.1,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">设</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">计</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">评</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">审</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(6222.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(7222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">代</text></g><g data-mml-node="mi" transform="translate(8222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">码</text></g><g data-mml-node="mi" transform="translate(9222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">评</text></g><g data-mml-node="mi" transform="translate(10222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">审</text></g><g data-mml-node="mi" transform="translate(11222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(12222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(1220,-710)"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">编</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">译</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(4222.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">单</text></g><g data-mml-node="mi" transform="translate(6222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">元</text></g><g data-mml-node="mi" transform="translate(7222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">测</text></g><g data-mml-node="mi" transform="translate(8222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">试</text></g><g data-mml-node="mi" transform="translate(9222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(10222.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="13422.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><h3 id="1-5-3-PQI"><a href="#1-5-3-PQI" class="headerlink" title="1.5.3. PQI"></a>1.5.3. PQI</h3><p><font color="#c00000">最全面</font>，123过程，45结果，在一个指标里<strong>包含了过程和结果</strong></p><ul><li>组成：5个数据的<strong>乘积</strong>，每个分量都在[0,1]内，结果越接近1说明质量越高<ol><li>设计质量：设计时间应该大于编码时间<ul><li>min{设计时间/编码时间, 1}</li></ul></li><li>设计评审质量：设计评审的时间应该大于设计时间的50%<ul><li>min{(2 * 设计评审时间 / 设计时间), 1}</li></ul></li><li>代码评审质量：代码评审时间应该大于编码时间的50%<ul><li>min{(2 * 代码评审时间)/编码时间 , 1}</li></ul></li><li>代码质量：代码的编译缺陷密度应该小于10个/千行<ul><li>min{20/(编译缺陷密度 + 10), 1}</li></ul></li><li>程序质量：代码单元测试的缺陷密度应该小于5个/千行<ul><li>min{10/(单元测试缺陷密度 + 5), 1}</li></ul></li></ol></li><li>用途<ol><li>判断模块开发质量</li><li>规划质量活动计划</li><li>过程改进</li></ol></li></ul><p>PQI达到0.4，说明模块很不错<br>大部分人的PQI都是0</p><h3 id="1-5-4-Review-Rate"><a href="#1-5-4-Review-Rate" class="headerlink" title="1.5.4. Review Rate"></a>1.5.4. Review Rate</h3><p><strong>过程度量</strong><br><strong>评审速度</strong>：一个用于指导软件工程师有效评审的指标，高质量的评审需要软件工 程师投入足够的时间进行评审</p><p>高质量的评审需要软件工程师投入足够的时间进行评审</p><p>在PSP的实践中，代码评审速度小于200LOC/H，文档评审速度小于4 Page/H</p><h3 id="1-5-5-DRL"><a href="#1-5-5-DRL" class="headerlink" title="1.5.5. DRL"></a>1.5.5. DRL</h3><p><strong>结果度量</strong><br><strong>缺陷消除效率比值</strong>：不同缺陷消除手段消除缺陷的效率</p><p>计算：某个阶段每小时消除缺陷个数 / 单元测试每小时消除个数</p><p>期望：所有DRL都大于1，即单元测试缺陷个数最少</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F25%2F22-48-48-38d05f278b1db4b244a5214db77d2627-20240625224847-9f535c.png" alt="image.png"></p><h3 id="1-5-6-其他质量"><a href="#1-5-6-其他质量" class="headerlink" title="1.5.6. 其他质量"></a>1.5.6. 其他质量</h3><p>个人评审和小组评审（标志重捕法）</p><p>Z：总缺陷<br>a 评审者1独立发现的缺陷<br>b 评审者2发现缺陷<br>c 评审者2发现的1发现的缺陷</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.738ex;" xmlns="http://www.w3.org/2000/svg" width="15.322ex" height="4.267ex" role="img" focusable="false" viewBox="0 -1118 6772.4 1886"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(1192.7,676)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D44D" d="M58 8Q58 23 64 35Q64 36 329 334T596 635L586 637Q575 637 512 637H500H476Q442 637 420 635T365 624T311 598T266 548T228 469Q227 466 226 463T224 458T223 453T222 450L221 448Q218 443 202 443Q185 443 182 453L214 561Q228 606 241 651Q249 679 253 681Q256 683 487 683H718Q723 678 723 675Q723 673 717 649Q189 54 188 52L185 49H274Q369 50 377 51Q452 60 500 100T579 247Q587 272 590 277T603 282H607Q628 282 628 271Q547 5 541 2Q538 0 300 0H124Q58 0 58 8Z"></path></g><g data-mml-node="mo" transform="translate(945.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1945.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g><rect width="2674.4" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3192.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4248,0)"><g data-mml-node="mi" transform="translate(1045.7,676)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(651.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1651.4,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g><rect width="2284.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p><font color="#c00000">先评审再单元测试</font>：先评审解决一些问题，测试时需要修复的问题少一些，需要的时间也少</p><h2 id="1-6-质量路径"><a href="#1-6-质量路径" class="headerlink" title="1.6. 质量路径"></a>1.6. 质量路径</h2><p><strong>为了追求高质量的手段</strong>：</p><ol><li>各种测试</li><li>进入测试之前的产物质量提升<ul><li>各种评审</li></ul></li><li>评审过程度量和稳定<ul><li>评审阶段yield稳定</li></ul></li><li>质量意识和主人翁意识</li><li>个体Review的态度和稳定</li><li>诉诸设计<ul><li>终极手段，review测试都用上了还是没达到质量要求</li></ul></li><li>缺陷预防<ul><li>从这一步开始不是针对特定项目</li><li>根据历史项目制定checklist</li></ul></li><li>用户质量观——其他质量属性<ul><li>前面都是解决缺陷问题，从8开始解决用户质量观的其他质量问题</li></ul></li></ol><h1 id="2-设计与质量的关系"><a href="#2-设计与质量的关系" class="headerlink" title="2. 设计与质量的关系"></a>2. 设计与质量的关系</h1><h2 id="2-1-设计的过程"><a href="#2-1-设计的过程" class="headerlink" title="2.1. 设计的过程"></a>2.1. 设计的过程</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F26%2F10-48-08-cacd445fa281a755cebbe96e72460daa-20240626104807-1c6fda.png" alt="image.png"></p><h2 id="2-2-设计的内容"><a href="#2-2-设计的内容" class="headerlink" title="2.2. 设计的内容"></a>2.2. 设计的内容</h2><p><strong>完整设计</strong>（可评审设计）包含以下4个方面:</p><table><thead><tr><th></th><th align="left">动态信息</th><th>静态信息</th></tr></thead><tbody><tr><td>外部信息</td><td align="left">交互信息（服务、消息等）</td><td>功能（继承、类结构等）</td></tr><tr><td>内部信息</td><td align="left">行为信息（状态机）</td><td>结构信息（属性、业务逻辑等）</td></tr></tbody></table><h2 id="2-3-UML常用图"><a href="#2-3-UML常用图" class="headerlink" title="2.3. UML常用图"></a>2.3. UML常用图</h2><table><thead><tr><th></th><th>动态信息</th><th>静态信息</th></tr></thead><tbody><tr><td>外部信息</td><td>用例图，时序图</td><td>类图（只有signature，没有实现）</td></tr><tr><td>内部信息</td><td>状态机图</td><td><strong>缺失</strong></td></tr></tbody></table><h2 id="2-4-PSP设计模板"><a href="#2-4-PSP设计模板" class="headerlink" title="2.4. PSP设计模板"></a>2.4. PSP设计模板</h2><table><thead><tr><th></th><th>动态信息</th><th>静态信息</th></tr></thead><tbody><tr><td>外部信息</td><td>操作，功能</td><td>功能</td></tr><tr><td>内部信息</td><td>状态</td><td>逻辑</td></tr></tbody></table><ol><li>操作规格模板<ol><li>描述系统与外界交互，用于场景描述：也就是用户与待设计系统的正常情况和异常情况下的交互</li><li>定义测试场景和测试用例，用来与用户讨论需求的基础，特别是操作相关的需求描述</li><li>与UML比较：用例图、时序图</li></ol></li><li>功能规格模板<ol><li>描述系统的对外接口，是一种静态信息的展现</li><li>提供的典型信息有类和继承关系、外部可见的属性和方法等</li><li>用形式化符号描述方法等行为，消除二义性</li><li>与UML比较：UML类图，<strong>但类图的方法行为没有描述</strong></li></ol></li><li>状态规格模板<ol><li>精确定义程序的所有状态、状态之间的转换以及伴随着每次状态转换的动作</li><li>包含信息：状态名称、状态描述、参数和方法的名称与描述、状态转换条件、状态转换发生的动作</li><li>UML：状态图</li></ol></li><li>逻辑规格模板<ol><li>可以精确描述系统中的静态逻辑。</li><li>为了消除描述的二义性，一般用伪代码配合形式化符号来描述设计结果</li><li>包含信息：关键方法静态逻辑、方法调用、外部引用、关键数据的类型和定义</li><li>UML没有对应图</li></ol></li></ol><h2 id="2-5-设计的层次"><a href="#2-5-设计的层次" class="headerlink" title="2.5. 设计的层次"></a>2.5. 设计的层次</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F26%2F20-06-54-82f8bc5162ce4786e4924764d95dd8c2-d7ad30e6ebf7fcaa8139b10b7691263-d01992.png" alt="d7ad30e6ebf7fcaa8139b10b7691263.png"></p><h2 id="2-6-设计验证方法"><a href="#2-6-设计验证方法" class="headerlink" title="2.6. 设计验证方法"></a>2.6. 设计验证方法</h2><ul><li>意义<ul><li><strong>简单评审不足以发现复杂缺陷</strong></li></ul></li><li>方法<ol><li>状态机验证</li><li>符号化执行验证</li><li>执行表验证</li><li>跟踪表验证</li><li>正确性验证</li></ol></li></ul><h3 id="2-6-1-状态机验证"><a href="#2-6-1-状态机验证" class="headerlink" title="2.6.1. 状态机验证"></a>2.6.1. 状态机验证</h3><p>PSP的状态机用文本描述</p><ul><li>检查状态机的完整性和正交性<ol><li>完整性：对于状态机中任何一个状态，对应的所有条件组合，下一个状态的转换都有定义</li><li>正交性：对于状态机中任何一个状态，所有下一个状态的转换条件不能相同</li></ol></li><li>验证步骤<ol><li>检查状态机，消除死循环和陷阱状态</li><li>检查状态转换，验证完整性和正交性</li><li>评价状态机，检验是否体现设计意图</li></ol></li></ul><h3 id="2-6-2-符号化执行"><a href="#2-6-2-符号化执行" class="headerlink" title="2.6.2. 符号化执行"></a>2.6.2. 符号化执行</h3><ul><li>用符号替换关键的变量，带入伪码程序，分析行为</li><li>优点：<ol><li>实施简单，可以给出一般化结果</li><li>适合不复杂的算法，特别是遗漏系统改造中，应用这种方法世界和理解原有的设计</li></ol></li><li>缺点<ol><li>不适合复杂逻辑的场景</li><li>纯手工验证容易出错</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F23%2F15-38-07-974e78db785a3ca75c18e9f637815699-20240523153806-fe65a9.png" alt="image.png"></p><h3 id="2-6-3-执行表验证"><a href="#2-6-3-执行表验证" class="headerlink" title="2.6.3. 执行表验证"></a>2.6.3. 执行表验证</h3><ul><li>主要争对伪代码：<ol><li>识别伪码程序的关键变量；</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量；</li><li>初始化被选定的变量；</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol></li></ul><p>伪代码+关键变量<br><strong>问题：只能检验一个样例</strong>  </p><ul><li>优点：实施简单；结果可靠，可用于验证复杂逻辑</li><li>缺点：每次只能验证一个用例；手工验证比较耗时，容易引入错误<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F23%2F15-41-05-d96a2bf74aac7c649fddb16cf2d896a8-20240523154105-9e1e9c.png" alt="image.png"></li></ul><h3 id="2-6-4-跟踪表"><a href="#2-6-4-跟踪表" class="headerlink" title="2.6.4. 跟踪表"></a>2.6.4. 跟踪表</h3><p>伪代码+关键变量</p><ol><li>识别伪码程序的关键变量；</li><li>构建表格，表格左侧填入主要程序步骤（伪代码），右侧填入关键变量；</li><li>初始化被选定的变量；</li><li><strong>识别将伪码程序符号化的机会，并加以符号化</strong>；</li><li><strong>定义并且优化用例组合</strong>；</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h3 id="2-6-5-正确性检验"><a href="#2-6-5-正确性检验" class="headerlink" title="2.6.5. 正确性检验"></a>2.6.5. 正确性检验</h3><ul><li>用形式化语言描述程序，加以验证和推理<ol><li>分析和识别用例；</li><li>对于复杂伪码程序的结构，应用正确性检验的标准问题逐项加以验证；</li><li>对于不能明确判断的复杂程序结构，使用跟踪表等辅助验证</li></ol></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>03-质量属性</title>
    <link href="http://example.com/posts/7a0fc498/"/>
    <id>http://example.com/posts/7a0fc498/</id>
    <published>2024-04-23T06:04:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h1><h2 id="1-1-功能需求"><a href="#1-1-功能需求" class="headerlink" title="1.1. 功能需求"></a>1.1. 功能需求</h2><p>约定系统行为</p><p>功能独立于结构</p><h2 id="1-2-质量需求"><a href="#1-2-质量需求" class="headerlink" title="1.2. 质量需求"></a>1.2. 质量需求</h2><p>系统完成功能好坏程度</p><h2 id="1-3-约束"><a href="#1-3-约束" class="headerlink" title="1.3. 约束"></a>1.3. 约束</h2><p>约束是完全没有自由的设计决定，在设计之前就确定下来。</p><h1 id="2-质量属性"><a href="#2-质量属性" class="headerlink" title="2. 质量属性"></a>2. 质量属性</h1><p>质量属性替代术语：可以表述成非功能需求或者架构需求</p><h2 id="2-1-要素"><a href="#2-1-要素" class="headerlink" title="2.1. 要素"></a>2.1. 要素</h2><ul><li>六元素：作为架构设计的输入<ol><li>刺激 stimulus：到达系统时需要考虑的<strong>条件</strong><ul><li>外部的变化、输入，发出者可能是人也可能是外部系统</li></ul></li><li>源 source：产生刺激的<strong>实体</strong></li><li>响应 response：刺激到达后采取的<strong>活动</strong></li><li>响应度量 measure: 我们会对响应做可以量化的度量</li><li>工件 artifact：需求适用的<strong>整个</strong>系统或系统的一部分</li><li>环境 environment：发生刺激时系统的状况，例如过载，运行等</li></ol></li><li>设计决定：<ul><li><strong>最小单元</strong>是tactic</li><li>几个tactic可以组合成pattern/strategy</li></ul></li></ul><h2 id="2-2-可用性-Avaliability"><a href="#2-2-可用性-Avaliability" class="headerlink" title="2.2. 可用性 Avaliability"></a>2.2. 可用性 Avaliability</h2><h3 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1. 概述"></a>2.2.1. 概述</h3><p>在两次Failure之间：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F10-22-27-3fa32d7c9b3e50f3244c917f315d27cc-20240425102226-752219.png" alt="image.png"></p><p>Unabaliable(Detect-Repair-Restart)-Avaliable<br>MTTR——MTBF</p><p>MTTR: mean time to repair<br>MTBF: mean time between failures  </p><p>提高可以性：降低MTTR,提高MTBF</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.738ex;" xmlns="http://www.w3.org/2000/svg" width="25.432ex" height="4.812ex" role="img" focusable="false" viewBox="0 -1359 11241 2127"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(1235,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2041.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(3097.6,0)"><g data-mml-node="mrow" transform="translate(2440.2,676)"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(1755,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(2514,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(1755,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(2514,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mo" transform="translate(3485.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4485.4,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(5536.4,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(6240.4,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(6944.4,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g><rect width="7903.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F05%2F13-22-19-cc71e1c4e715a1e93f8b217fad590e04-20240505132219-0989a6.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F05%2F13-22-31-eeea4718e2d42049c6bc20bc0c6cc8cd-20240505132230-f91baa.png" alt="image.png"></p><h3 id="2-2-2-可用性策略"><a href="#2-2-2-可用性策略" class="headerlink" title="2.2.2. 可用性策略"></a>2.2.2. 可用性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F10-26-26-4700e0c1f4eeecda5b7b0a03139d2c4e-20240425102625-15d799.png" alt="image.png"></p><h4 id="2-2-2-1-Detect"><a href="#2-2-2-1-Detect" class="headerlink" title="2.2.2.1. Detect"></a>2.2.2.1. Detect</h4><ol><li>Ping/Echo: Monitor主动给Server询问，Server响应。<ol><li>需要应答，带宽利用率更低</li></ol></li><li>Heartbeat: Server按照一定频率主动给Monitor发消息。</li><li>Timestamp:<ul><li>收到一系列的消息应该在时间上有先后顺序</li><li>进行常识的信息的检查，如果和常识不符合那么可能是出现了问题</li></ul></li><li>Sanity Checking: 如果数据超出合理范围，认为系统出现问题</li><li>Condition Monitoring: 对运行的环境进行检查，如网络带宽、占用内存等。当环境达到某些阈值时，产生可用性问题的概率较大。</li><li>Voting: Voter之间不一致，认为系统出现问题。基本上使用奇数个Voter。<ol><li>Clone: 多个Voter完全一致，只根据结果投票。</li><li>Voter实现不同，为了防止组件的实现影响可用性。如果没有发生可用性问题，输入一致，输出也一致。</li><li>Voter实现不同，输入也不同，但是输出在合理范围内，也认为系统可用。</li></ol></li><li>Exception Delection: 发生错误时抛出异常，异常的处理过程通常和抛出异常的地方在同一个进程中。</li><li>Self-Test</li></ol><ul><li>Ping/Echo和Heartbeat区别：<ol><li>始终检测，heartbeat比ping/echo的带宽开销更小  </li><li>偶发请求，不需要时刻保证可用性，请求前ping/echo</li></ol></li></ul><h4 id="2-2-2-2-Recover"><a href="#2-2-2-2-Recover" class="headerlink" title="2.2.2.2. Recover"></a>2.2.2.2. Recover</h4><p>优先级：让系统恢复正常状态&gt;组件恢复</p><ul><li>Preparation and Repair<ol><li>Active redundancy：所有冗余组件并行处理输入，但是只是用一个组件的返回结果。<ul><li>发生故障时，通常不存在停机时间，因为备份是最新的，恢复时间就是切换时间。</li></ul></li><li>Passive redundancy：主组件响应输入，并通知其他组件当前的状态<ul><li>发生故障时，系统必须首先确保备份在恢复服务之前，状态足够新。</li><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F10-46-24-5d427223ec0ef63efac9ba31a7400ddc-20240425104623-32b5a7.png" alt="image.png"></li></ul></li><li>Spare：备用计算平台替换发生故障的组件</li><li>Exception Handling: 捕获异常，处理。和redundancy配合，主机发生异常后，启动副本。</li><li>Rollback：按照一定时间间隔，记录系统的正常状态checkpoint，发生意外时可以回滚。</li><li>Software Upgrade: 软件提供商已经解决了问题</li><li>Retry: 问题不是系统造成，而是由于环境问题，如网络不稳定，一段时间后retry可能就可用了。<ul><li>会设置最大retry次数</li></ul></li><li>Ignore faluts behavior: 把有问题的输入屏蔽掉<ul><li>白名单，黑名单</li></ul></li><li>Degradation: 服务水平降级</li><li>Reconfiguration: 系统重新配置。<ul><li>基于微服务的系统，每个微服务有众多实例</li></ul></li></ol></li><li>Reintroduction<ol><li>Shadow operation：之前发生过错误的组件会有一段时间的shadow mode，如果出现问题立刻恢复。<ul><li>组件恢复之后有一段监视期，防止再次出现问题。</li></ul></li><li>State re-synchronisation<ul><li>被动和主动冗余策略要求要恢复的组件在恢复服务之前对其状态进行升级。</li></ul></li><li>Escalating restart：扩大重启范围，但先从最小范围开始。只重启出现错误的组件可能无法解决问题。</li><li>Non-Stop Forwarding：设备发生主备切换时最大程度地减少中断时间</li></ol></li></ul><h4 id="2-2-2-3-Prevent"><a href="#2-2-2-3-Prevent" class="headerlink" title="2.2.2.3. Prevent"></a>2.2.2.3. Prevent</h4><p>目的：延长系统正常运行的时间MTBF。</p><ol><li>Removal from service：把带病工作的组件尽早替换掉</li><li>Transaction：事务</li><li>Predictive Model：使用基于以往数据的概率模型预测</li><li>Exception Prevention：在异常捕获上提供更高级的处理能力</li><li>Increase Competence Set：对可能会出现faults的原因进行针对性设计</li></ol><h2 id="2-3-互操作性-Interoperability"><a href="#2-3-互操作性-Interoperability" class="headerlink" title="2.3. 互操作性 Interoperability"></a>2.3. 互操作性 Interoperability</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1. 概述"></a>2.3.1. 概述</h3><ul><li><p>互操作性：是指两个或多个系统可以在特定的上下文中通过<strong>接口</strong>有效交换有意义的信息的程度。互操作性需要确定谁，什么以及在什么情况下（上下文）。</p></li><li><p>要素</p><ol><li>Discovery：发现服务。和哪个对象互操作，怎么查找。<ol><li>location</li><li>identity</li><li>interface of service</li></ol></li><li>Handling of response：处理响应<ol><li>reports back to the requester</li><li>sends its response on to another system</li><li>broadcasts</li></ol></li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-27-23-e24963fb38ef335e5a0929875103ee2d-20240425112722-1f7428.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-28-49-04751e4f3259e6415b58535b09e68d81-20240425112848-9dce66.png" alt="image.png"></p><h3 id="2-3-2-互操作性策略"><a href="#2-3-2-互操作性策略" class="headerlink" title="2.3.2. 互操作性策略"></a>2.3.2. 互操作性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-30-18-565bdb570d67ae4e40a0d211c005114a-20240425113017-9a2720.png" alt="image.png"></p><h4 id="2-3-2-1-Locate"><a href="#2-3-2-1-Locate" class="headerlink" title="2.3.2.1. Locate"></a>2.3.2.1. Locate</h4><ol><li>Discover Service：服务要在注册中心注册才能被找到</li></ol><h4 id="2-3-2-2-Manage-Interfaces"><a href="#2-3-2-2-Manage-Interfaces" class="headerlink" title="2.3.2.2. Manage Interfaces"></a>2.3.2.2. Manage Interfaces</h4><ol><li>Orchestrate: 工作流编排，通过编排不同服务提供数据交换能力</li><li>Tailor Interface：在interface上增加和删减一些能力<ol><li>e.g.区分付费用户和免费用户</li></ol></li></ol><h2 id="2-4-可修改性-Modifiability"><a href="#2-4-可修改性-Modifiability" class="headerlink" title="2.4. 可修改性 Modifiability"></a>2.4. 可修改性 Modifiability</h2><h3 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1. 概述"></a>2.4.1. 概述</h3><p>可修改性涉及到更改以及进行更改所需花费的时间或金钱，包括这种可变更性影响其他功能或质量属性的程度。</p><p>设计的时候就要考虑未来的变化。</p><p>预先针对变化设计，还是变化发生之后再去修改，取决于成本。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-39-58-0264100979bdb60ba4f3c304068a8f63-20240425113957-842a8a.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-40-36-bcbb77559343010d9f84807f5c36d81a-20240425114035-2af04a.png" alt="image.png"></p><h3 id="2-4-2-可修改性策略"><a href="#2-4-2-可修改性策略" class="headerlink" title="2.4.2. 可修改性策略"></a>2.4.2. 可修改性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-42-54-1659105ca675aaf8586ad10d242eaa00-20240425114253-47bd1d.png" alt="image.png"></p><ol><li>Reduce Size of Moudle：减小模块的规模</li><li>Increase Cohesion：提高内聚<ol><li>语义相近的部分往往需要同时修改</li></ol></li><li>Reduce Coupling<ol><li>Encapsulate：封装可能的变化</li><li>Use an Intermediary：使用中间件</li><li>Restrict Dependencies：<strong>使用分层结构简化依赖关系</strong></li><li>Refactor：不是针对系统内部重构，是<strong>架构层面的重构</strong>，把责任放到最合适的地方</li><li>Abstract Common Services：把相似的服务放在一起，修改对外参数</li></ol></li><li>Defer Binding：推迟绑定时间<ol><li>有越多的时间确定关系</li><li>但是也会对其他质量属性造成负面影响</li></ol></li></ol><h2 id="2-5-性能-Performance"><a href="#2-5-性能-Performance" class="headerlink" title="2.5. 性能 Performance"></a>2.5. 性能 Performance</h2><p>系统满足时间需求的能力，单位时间可以做多少事情</p><ul><li>决定性能的时间<ol><li>processing time 处理时间</li><li>blocked time 阻塞时间</li></ol></li></ul><h3 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1. 概述"></a>2.5.1. 概述</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-05-49-7c9ec4af005d63037d71db0ab770cd75-20240430140546-cb09ff.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-06-01-e431136370746160356a85aa199757e1-20240430140558-cf1dec.png" alt="image.png"></p><h3 id="2-5-2-性能策略"><a href="#2-5-2-性能策略" class="headerlink" title="2.5.2. 性能策略"></a>2.5.2. 性能策略</h3><p>减少任务<br>增加处理能力</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-09-32-65db085871dd299a4e9c055fd3bd4a13-20240430140930-acc202.png" alt="image.png"></p><ul><li>demand side<ol><li>降低采样频率</li><li>限制事件响应，如果系统来不及响应，把事件放入等待队列</li><li>优先级</li><li>使用中间层，提高资源利用效率</li></ol></li><li>resource side<ol><li>提升资源</li><li>并发</li><li>复制多个实例，使用负载均衡器把任务分配到实例上</li><li>复制多份数据，缓存、数据冗余</li></ol></li></ul><h2 id="2-6-安全-Security"><a href="#2-6-安全-Security" class="headerlink" title="2.6. 安全 Security"></a>2.6. 安全 Security</h2><h3 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1. 概述"></a>2.6.1. 概述</h3><p>保护系统不被未授权的访问影响</p><ul><li>特征<ol><li>Confidentiality：数据和服务不能被未授权访问</li><li>Integrity：数据和服务不能被未授权操作</li><li>Availability：系统对合法用户可以正常使用</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-31-07-341098559fc7f205a8d7d451575fd08f-20240430143105-c26ce4.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-31-20-8a217de96bc3f58a32aa3a566258e208-20240430143118-a33992.png" alt="image.png"></p><h3 id="2-6-2-安全性策略"><a href="#2-6-2-安全性策略" class="headerlink" title="2.6.2. 安全性策略"></a>2.6.2. 安全性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-41-22-5a25f3505c77c7d8064f7c26e4f317d6-20240430144120-1f1b76.png" alt="image.png"></p><p>与可用性区别：检测到攻击时，还处在攻击状态，系统不一定失效</p><ul><li>Detect<ol><li>根据历史攻击的特征，检测识别攻击</li><li>检测服务拒绝<strong>DoS attack</strong>，白名单/黑名单</li><li>验证消息合法性</li><li>检测消息延迟</li></ol></li><li>Resist<ol><li>用户识别，宣称自己是谁</li><li>用户身份认证，看用户是不是真的那个人<ul><li>e.g.手机号是identity, 验证码是authentication</li></ul></li><li>用户权限认证</li><li>限制访问，过滤从外部到系统内部的访问</li><li>限制对外暴露</li><li>加密数据</li><li>分离数据，把敏感数据和公告访问数据分开</li><li>改变默认设置</li></ol></li><li>React<ol><li>撤回访问，限制攻击能访问的范围</li><li>系统上锁停止服务，攻击和普通用户都不能访问<ul><li>e.g.密码错误超过十次，对设备上锁</li></ul></li><li>通知使用者</li></ol></li><li>Recover</li></ul><h2 id="2-7-可测试性-Testability"><a href="#2-7-可测试性-Testability" class="headerlink" title="2.7. 可测试性 Testability"></a>2.7. 可测试性 Testability</h2><h3 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1. 概述"></a>2.7.1. 概述</h3><p>系统是不是容易被测试，把问题暴露出来的能力<br>系统内部的质量属性，用户并不会关心</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F15-12-29-7ed103a346d781a0f4deb1e145d71ff9-20240430151226-6f3be5.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F15-12-42-d203be97b5b9d8818765ce660d9b9c86-20240430151240-b84085.png" alt="image.png"></p><h3 id="2-7-2-可测试性策略"><a href="#2-7-2-可测试性策略" class="headerlink" title="2.7.2. 可测试性策略"></a>2.7.2. 可测试性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F15-16-05-46f1cef5a5879bd7ee25b52984c34204-20240430151602-ac435a.png" alt="image.png"></p><h2 id="2-8-易用性-Usability"><a href="#2-8-易用性-Usability" class="headerlink" title="2.8. 易用性 Usability"></a>2.8. 易用性 Usability</h2><p>外部质量属性</p><p>系统使用学习的难易程度</p><ul><li>层次<ol><li><strong>学习</strong>软件使用</li><li><strong>高效</strong>地使用系统</li><li>最小化<strong>出错</strong>的影响</li><li>让系统<strong>适应</strong>用户的需要</li><li>提升用户使用系统时的<strong>信心和满足感</strong></li></ol></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>06-数据库设计（一致性保障）</title>
    <link href="http://example.com/posts/30ebc364/"/>
    <id>http://example.com/posts/30ebc364/</id>
    <published>2024-04-22T06:04:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据库范式"><a href="#1-数据库范式" class="headerlink" title="1. 数据库范式"></a>1. 数据库范式</h1><ol><li>1NF：属性的原子性  </li><li>2NF：属性的主键完全依赖  </li><li>3NF：不存在传递函数依赖  <ul><li>冗余最小化</li></ul></li><li>BCNF、4NF、5NF（完美范式）</li></ol><h1 id="2-数据库反范式"><a href="#2-数据库反范式" class="headerlink" title="2. 数据库反范式"></a>2. 数据库反范式</h1><p>规范化的结果是一个结构上一致，且拥有最小冗余的结构，但未必是性能最优的设计。</p><ul><li>反范式本质是——考虑引入可控制的冗余<ol><li>实现更复杂，需要手动控制冗余</li><li>减低灵活性</li><li><strong>加快读取</strong>，降低更新</li></ol></li><li>主要动作：<strong>复制</strong></li><li><font color="#c00000">核心目标</font>：<strong>减低连接次数</strong>，提高查询效率</li></ul><h1 id="3-数据库反范式模式"><a href="#3-数据库反范式模式" class="headerlink" title="3. 数据库反范式模式"></a>3. 数据库反范式模式</h1><ol><li>合并1:1关系</li><li>复制1:*关系的非Key、FK及值</li><li>复制*:*关系的属性</li><li>引入重复组</li><li>创建提取临时表</li></ol><h2 id="3-1-合并1-1关系"><a href="#3-1-合并1-1关系" class="headerlink" title="3.1. 合并1:1关系"></a>3.1. 合并1:1关系</h2><p>部分参与会大量引入空值，处理复杂</p><h2 id="3-2-复制1-关系的非Key、FK及值"><a href="#3-2-复制1-关系的非Key、FK及值" class="headerlink" title="3.2. 复制1:*关系的非Key、FK及值"></a>3.2. 复制1:*关系的非Key、FK及值</h2><p>多代码表的连接基本上都是通过<strong>复制代码值</strong>，而不是外键id，来减少表连接</p><p>适用于，代码表的值比较固定，值的数量不多</p><h2 id="3-3-复制-关系的属性"><a href="#3-3-复制-关系的属性" class="headerlink" title="3.3. 复制*:*关系的属性"></a>3.3. 复制*:*关系的属性</h2><h2 id="3-4-引入重复组"><a href="#3-4-引入重复组" class="headerlink" title="3.4. 引入重复组"></a>3.4. 引入重复组</h2><p>4NF要求</p><ul><li>地址，电话</li><li>静态，数量小</li></ul><p>e.g.：淘宝，选择收获地址，在customer主表里加一列常用地址。当用户点击更多地址时，才查询用户的全部地址。</p><h2 id="3-5-创建提取临时表"><a href="#3-5-创建提取临时表" class="headerlink" title="3.5. 创建提取临时表"></a>3.5. 创建提取临时表</h2><p>静态，时间切片，不是实时数据<br>实时计算，物化视图，代价极大<br>不推荐</p><h1 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4. 数据库设计"></a>4. 数据库设计</h1><p>基本满足3NF，可能产生多种设计结果</p><h2 id="4-1-树状结构"><a href="#4-1-树状结构" class="headerlink" title="4.1. 树状结构"></a>4.1. 树状结构</h2><p>对象类型相同，而对象的层次可变，其关系就应该被建模为树结构</p><p>树状结构复杂度在于：树的访问</p><ul><li>实际实现：<ol><li>邻接模型</li><li>物化路径模型</li><li>嵌套集合模型</li></ol></li></ul><h3 id="4-1-1-临接模型"><a href="#4-1-1-临接模型" class="headerlink" title="4.1.1. 临接模型"></a>4.1.1. 临接模型</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-34-38-06846e7ba7d8cee19acef8e6c934d650-20240506143438-c20582.png" alt="image.png"></p><p>满足单父节点</p><ul><li>T(id,pid,attr…)<ul><li>id标记当前节点，pid标记父节点</li></ul></li><li>问题：<ol><li>会丢失子节点的顺序</li><li><strong>不符合归一化原则（一事，一地，一次）</strong>，无法通过数据库保证一致性<ul><li>pid存在多处修改也需要多次</li><li>insert时数据库无法检查是否是有圈，无法检查是树而不是图，需要再应用系统检查</li><li>delete复杂</li></ul></li><li>要找所有子节点很复杂</li></ol></li></ul><h3 id="4-1-2-物化路径模型"><a href="#4-1-2-物化路径模型" class="headerlink" title="4.1.2. 物化路径模型"></a>4.1.2. 物化路径模型</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-33-53-c3e2181ff81f828c5e79ba5b6a54a2ad-20240506143352-43562c.png" alt="image.png"></p><ul><li>T(m_path,attr…)把路径存成一个字段</li></ul><ol><li>解决了子节点顺序问题</li><li>insert时更容易控制</li><li>找所有子节点简单，只需要字符串匹配</li><li>无法满足归一化，父节点路径存在多个子节点里，发生修改还是要多次修改</li><li>不容易变成图</li><li>delete数据还是要手动处理</li></ol><p>路径id是字符串，处理性能差<br>读写性能最平衡</p><h3 id="4-1-3-嵌套集合模型"><a href="#4-1-3-嵌套集合模型" class="headerlink" title="4.1.3. 嵌套集合模型"></a>4.1.3. 嵌套集合模型</h3><p>T(left_num,right_num,attr…)，基于集合论，在[left,num]内的都是该节点的子节点</p><ol><li>可以保存子节点顺序</li><li>delete节点，可以自动缺省处理</li><li><strong>insert要修改很多，所有右边的节点都要改</strong></li><li>是归一化模型</li></ol><p>现实里使用往往更新比较少，而且保留range</p><h3 id="4-1-4-闭包表模型"><a href="#4-1-4-闭包表模型" class="headerlink" title="4.1.4. 闭包表模型"></a>4.1.4. 闭包表模型</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F08%2F10-34-24-6ea9584f1a11e2c1867bdc5693f26d17-20240508103424-84e55e.png" alt="image.png"></p><ul><li>整棵树在两张表里记录，节点表和节点关系表。</li><li>NodeRelation(id, ancester, descendant, distance)，定义了所有节点之间的关系</li></ul><p>闭包模型不仅可以处理树也可以处理图，可读性更差，通用性和扩展性强</p><p>场景：论坛回帖，典型的树状结构</p><h2 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2. 查询"></a>4.2. 查询</h2><h3 id="4-2-1-自顶向下"><a href="#4-2-1-自顶向下" class="headerlink" title="4.2.1. 自顶向下"></a>4.2.1. 自顶向下</h3><p>查询所有子节点，缩进排序</p><ol><li>邻接模型<ol><li>oracle的connect by,mysql递归查询</li><li>手动union，在一个查询中多次连接，前提是知道深度</li><li>单独设计一张关系表，T(id,pid,distance)，保存节点到所有父节点的距离</li></ol></li><li>物化路径模型<ol><li>字符串前缀比较，深度就是<code>.</code>的个数</li></ol></li><li>嵌套集合模型<ol><li>遍历整张表，只要在[left,right]内，一定是子节点。但是缩排很复杂。</li></ol></li></ol><p>效率指标： t/s，每秒做了几个事务，兼顾容量和时间</p><p>资源消耗：from表连接&gt;字符串处理&gt;数值比较</p><h3 id="4-2-2-自底向上查询"><a href="#4-2-2-自底向上查询" class="headerlink" title="4.2.2. 自底向上查询"></a>4.2.2. 自底向上查询</h3><ol><li>邻接模型<ul><li>connect by, 递归</li></ul></li><li>物化路径</li><li>嵌套集合<ol><li>动态计算深度仍然是问题，计算量大</li><li>可以按照left_num排序</li></ol></li></ol><h3 id="4-2-3-问题"><a href="#4-2-3-问题" class="headerlink" title="4.2.3. 问题"></a>4.2.3. 问题</h3><p>select 投影，只做一次<br>where 选择，对查询时遍历的每一条记录都做一次，如果在where里写复杂函数代价很大</p><ol><li>物化路径不该是KEY，既是有唯一性</li><li>物化路径和邻接模型等价使用时，不该按时任何兄弟父子节点的排序</li><li>所选择的编码方式不需要完全中立</li></ol><h2 id="4-3-效率比较"><a href="#4-3-效率比较" class="headerlink" title="4.3. 效率比较"></a>4.3. 效率比较</h2><ol><li>邻接模型<ul><li>简单，成熟，深度是最大障碍</li></ul></li><li>物化路径<ul><li>读写平很，稳定的输出</li></ul></li><li>嵌套集合<ul><li>读取频率远高于修改频率，只在乎上下关系，不在乎层级</li></ul></li><li>闭包表模型<ul><li>额外表存储，维护细节和成本高，查询效率优秀</li></ul></li></ol><h2 id="4-4-其他查询要求"><a href="#4-4-其他查询要求" class="headerlink" title="4.4. 其他查询要求"></a>4.4. 其他查询要求</h2><h3 id="4-4-1-对保存叶节点的值做聚合"><a href="#4-4-1-对保存叶节点的值做聚合" class="headerlink" title="4.4.1. 对保存叶节点的值做聚合"></a>4.4.1. 对保存叶节点的值做聚合</h3><p>邻接模型的connect by无法使用，只能递归<br>物化路径比较简单</p><h3 id="4-4-2-物料单问题"><a href="#4-4-2-物料单问题" class="headerlink" title="4.4.2. 物料单问题"></a>4.4.2. 物料单问题</h3><p>任何一个节点都可能包含多个子节点，也可能有多个父节点<br><strong>递归难以避免</strong></p><ul><li>多叉树<ol><li>复杂的层次模型</li><li>每个节点都有多父节点，多子节点</li><li>边列表结构库设计（Edge List），也是图结构的基础数据库设计</li><li>也是闭包模型的扩展，具体应用中需要增加一些实体</li></ol></li></ul><p>原子化实体和组合化实体要分开</p><ul><li>例：计算分散在各层的百分比<ul><li>A(aa 20%,bb,cc,B 30%)</li><li>B(aa 50%,bb,cc)</li><li>计算A中aa含量：20% + 30% *  50%</li></ul></li></ul><h2 id="树状结构的问题"><a href="#树状结构的问题" class="headerlink" title="树状结构的问题"></a>树状结构的问题</h2><p>要有条件地控制深度，否则都会很慢</p><h1 id="5-递归SQL语法"><a href="#5-递归SQL语法" class="headerlink" title="5. 递归SQL语法"></a>5. 递归SQL语法</h1><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte_name (column_list) <span class="keyword">AS</span> (</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>初始查询</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>递归查询</span><br><span class="line">)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>主查询</span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> cte_name</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure></div><p>引入层次</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>05-Linux MultiCore Programming</title>
    <link href="http://example.com/posts/e2194f69/"/>
    <id>http://example.com/posts/e2194f69/</id>
    <published>2024-04-22T03:04:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux进程"><a href="#1-Linux进程" class="headerlink" title="1. Linux进程"></a>1. Linux进程</h1><h2 id="1-1-exec"><a href="#1-1-exec" class="headerlink" title="1.1. exec"></a>1.1. exec</h2><ol><li>exec：直接执行新的程序</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ..., (<span class="type">char</span> *)<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg0, ..., (<span class="type">char</span> *)<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ..., (<span class="type">char</span> *)<span class="number">0</span>, <span class="type">char</span> *<span class="type">const</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span><br></pre></td></tr></table></figure></div><h2 id="1-2-fork"><a href="#1-2-fork" class="headerlink" title="1.2. fork"></a>1.2. fork</h2><ol><li>fork：创建一个一样的新进程</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div><p>使用：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">{子进程执行的代码段；}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{父进程执行的代码段；}</span><br></pre></td></tr></table></figure></div><h2 id="1-3-进程退出方式"><a href="#1-3-进程退出方式" class="headerlink" title="1.3. 进程退出方式"></a>1.3. 进程退出方式</h2><ol><li>正常退出<ol><li>return from main</li><li>call exit 库函数（有终止处理）</li><li>call _exit 系统调用（立即退出）</li><li>线程终止</li></ol></li><li>异常退出<ol><li>call abort</li><li>被信号取消</li><li>线程被取消</li></ol></li></ol><p>exit：最终会调用_exit，但之前会有一堆终止处理程序(aexit function)</p><h2 id="1-4-Process-resources"><a href="#1-4-Process-resources" class="headerlink" title="1.4. Process resources"></a>1.4. Process resources</h2><p>每个进程都有一个进程描述符</p><h2 id="1-5-wait-waitpid"><a href="#1-5-wait-waitpid" class="headerlink" title="1.5. wait & waitpid"></a>1.5. wait &amp; waitpid</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> * status)</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span>  pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span></span><br></pre></td></tr></table></figure></div><ul><li><p>作用</p><ol><li>父进程等待子进程结束</li><li>回收僵尸进程</li></ol></li><li><p>结果</p><ol><li>阻塞</li><li>立即返回</li><li>出错</li></ol></li><li><p>waitpid</p><ol><li>指定pid</li><li><strong>非阻塞</strong></li><li>waitpid的pid参数<ol><li>pid==-1：对应wait</li><li>pid&gt; 0: 指定pid</li><li>pid==0：指定父进程的group</li><li>pid&lt;0：指定group id，等待对应组里的进程</li></ol></li></ol></li></ul><h2 id="1-6-signal"><a href="#1-6-signal" class="headerlink" title="1.6. signal"></a>1.6. signal</h2><p>进程之间通信</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal.h</span><br></pre></td></tr></table></figure></div><h3 id="1-6-1-信号"><a href="#1-6-1-信号" class="headerlink" title="1.6.1. 信号"></a>1.6.1. 信号</h3><p>SIGKILL：终止，不能被捕获或忽略<br>SIGINT：终端中断符 , 等价于ctrl + c<br>SIGTERM：终止（kill发出的默认系统终止信号），可以改</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">//Returned Value: the previous handler if success, SIG_ERR if error</span></span><br></pre></td></tr></table></figure></div><h3 id="1-6-2-可靠性"><a href="#1-6-2-可靠性" class="headerlink" title="1.6.2. 可靠性"></a>1.6.2. 可靠性</h3><ul><li>信号可靠性<ol><li>连续重复信号能不能收到<ol><li>可能会丢失，SIG对应的int值较大对应早期Linux版本不可靠，int值较小对应早期版本;后期版本有可靠机制</li></ol></li><li>阻塞信号</li><li>复位机制</li></ol></li></ul><h3 id="1-6-3-发信号"><a href="#1-6-3-发信号" class="headerlink" title="1.6.3. 发信号"></a>1.6.3. 发信号</h3><ul><li><strong>kill</strong>: send signal to a process</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 if success, -1 if failure pid:取值</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>raise</strong>: send a signal to the <strong>current process</strong></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 if success, -1 if failure</span></span><br></pre></td></tr></table></figure></div><ul><li>alarm: set an alarm clock for delivery of a signal<ol><li>每个进程只能有一个闹钟</li><li>可以用来做超时处理</li></ol></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">//Returned value: 0, or the number of seconds remaining of previous alarm </span></span><br><span class="line"><span class="comment">//SIGALRM</span></span><br></pre></td></tr></table></figure></div><ul><li>pause: wait for a signal<ol><li>挂起，等到有信号来才执行</li><li>e.g. CTRL+Z的实现</li></ol></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//Returned value: -1, errno is set to be EINTR</span></span><br></pre></td></tr></table></figure></div><hr><ul><li>例子：</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span>{</span><br><span class="line"><span class="built_in">printf</span>(“alarm received\n”);</span><br><span class="line">}</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nsecs)</span> {</span><br><span class="line"><span class="keyword">if</span> ( signal(SIGALARM, sig_alrm) == SIG_ERR)</span><br><span class="line"><span class="keyword">return</span>(nsecs);</span><br><span class="line">alarm(nsecs); <span class="comment">/* start the timer */</span></span><br><span class="line">pause(); <span class="comment">/*next caught signal wakes us up*/</span></span><br><span class="line"><span class="keyword">return</span>(alarm(<span class="number">0</span>) ); <span class="comment">/*turn off timer, return unslept time */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="1-6-4-可靠信号"><a href="#1-6-4-可靠信号" class="headerlink" title="1.6.4. 可靠信号"></a>1.6.4. 可靠信号</h3><ul><li>信号集</li></ul><p>给一个信号注册一个结构体，而不是直接注册处理函数</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">//Return value: 0 if success, -1 if error</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">//Return value: 1 if true, 0 if false</span></span><br></pre></td></tr></table></figure></div><hr><ul><li>sigprocmask：检测或更改(或两者)进程的信号掩码</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">//Return Value: 0 is success, -1 if failure</span></span><br></pre></td></tr></table></figure></div><ul><li>参数“<strong>how</strong>”决定对信号掩码的操作<ol><li>SIG_BLOCK: 将set中的信号<strong>添加</strong>到信号掩码(并集)</li><li>SIG_UNBLOCK: 从信号掩码中<strong>去掉</strong>set中的信号(差集)</li><li>SIG_SETMASK: 把信号掩码<strong>设置为</strong>set中的信号</li></ol></li><li>在sigprocmask调用后任何未阻塞并且pending的信号，在函数返回前，至少有一个信号会送达进程</li><li>例外: SIGKILL, SIGSTOP</li></ul><hr><ul><li>sigpending: 返回当前未决的信号集</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 is success, -1 if failure</span></span><br></pre></td></tr></table></figure></div><hr><ul><li><strong>sigaction</strong>：检查或修改与指定信号的关联处理动作</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 is success, -1 if failure)</span></span><br></pre></td></tr></table></figure></div><ul><li>struct sigaction成员：</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> sa_handler; <span class="comment">/* addr of signal handler, or SIG_IGN, </span></span><br><span class="line"><span class="comment">or SIG_DEL */</span></span><br><span class="line"><span class="type">sigset_t</span> sa_mask; <span class="comment">/* additional signals to block */</span></span><br><span class="line"><span class="type">int</span> sa_flags; <span class="comment">/* signal options */</span></span><br></pre></td></tr></table></figure></div><hr><ul><li><code>sigsuspend</code>：使用临时信号替代信号掩码，在捕获一个信号或发生终止该进程的信号前，进程挂起</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> sigset *sigmask)</span>;</span><br><span class="line"><span class="comment">//Returned value: -1, errno is set to be EINTR</span></span><br></pre></td></tr></table></figure></div><h2 id="1-7-可重入函数"><a href="#1-7-可重入函数" class="headerlink" title="1.7. 可重入函数"></a>1.7. 可重入函数</h2><ul><li>可重入：可以被打断的函数</li><li>不可重入函数：<ol><li>系统资源</li><li>全局变量</li><li>使用静态数据结构</li><li>调用malloc或者free</li><li>标准IO函数</li></ol></li></ul><h1 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2. 共享内存"></a>2. 共享内存</h1><ol><li>共享内存是内核为进程创建的一个特殊内存段，它可连接(attach)到自己的地址空间，也可以连接到其它进程的地址空间</li><li><strong>最快的进程间通信方式</strong></li><li>不提供任何同步功能</li></ol><h2 id="2-1-mmap-munmap"><a href="#2-1-mmap-munmap" class="headerlink" title="2.1. mmap/munmap"></a>2.1. mmap/munmap</h2><p>把文件/设备，映射/取消映射到内存。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr,<span class="type">size_t</span> length,<span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span></span><br></pre></td></tr></table></figure></div><ul><li>flags<ol><li>MAP_SHARED</li><li>MAP_ANONYMOUS：忽略掉fd，虚拟了一个文件</li><li>MAP_PRIVATE：只有当前进程可以写</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F29%2F10-49-59-a380e5e4559554e6c4bd764939c0322a-20240429104958-5ac065.png" alt="image.png"></p><h2 id="2-2-shared-memory-system-calls"><a href="#2-2-shared-memory-system-calls" class="headerlink" title="2.2. shared memory system calls"></a>2.2. shared memory system calls</h2><h3 id="2-2-1-申请共享内存"><a href="#2-2-1-申请共享内存" class="headerlink" title="2.2.1. 申请共享内存"></a>2.2.1. 申请共享内存</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> size, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>key：区分共享内存。</li><li>flag：<ol><li>0：必须找</li><li>IPC_CREAT：找不到就创建</li><li>IPC_EXCL：只创建不找</li></ol></li></ol><h3 id="2-2-2-共享内存地址映射"><a href="#2-2-2-共享内存地址映射" class="headerlink" title="2.2.2. 共享内存地址映射"></a>2.2.2. 共享内存地址映射</h3><p>使用共享内存的时候也需要map，和文件类似:</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">void</span> *addr, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>addr</li><li>flag: <ol><li>SHM_RND：可读可写</li><li>SHM_RDONLY：只读</li></ol></li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_memory = shmat(shmid, (<span class="type">void</span> *)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shared_memory == (<span class="type">void</span> *)<span class="number">-1</span>) {</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="2-2-3-共享内存解除映射"><a href="#2-2-3-共享内存解除映射" class="headerlink" title="2.2.3. 共享内存解除映射"></a>2.2.3. 共享内存解除映射</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">void</span> * addr)</span>;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shmdt(shared_memory) == <span class="number">-1</span>) {</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="2-2-4-共享内存释放"><a href="#2-2-4-共享内存释放" class="headerlink" title="2.2.4. 共享内存释放"></a>2.2.4. 共享内存释放</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>cmd：<ol><li>IPC_STAT：获取共享内存属性</li><li>IPC_SET：为共享内存设置属性</li><li><strong>IPC_RMID：释放</strong>，buf参数</li></ol></li></ol><p>e.g.:</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) {</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmctl(IPC_RMID) failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h1 id="3-POSIX-thread"><a href="#3-POSIX-thread" class="headerlink" title="3. POSIX thread"></a>3. POSIX thread</h1><ul><li>和普通thread区别<ol><li>POSIX thread不是系统调用，是Linux下的标准库</li><li>Linux下可以用clone创建thread，但是比较复杂很少用</li></ol></li></ul><p>线程共享地址空间，轻量级</p><ul><li>pthread library<ul><li>/usr/lib/libpthread.so, /usr/lib/libpthread.a</li></ul></li><li>pthread.h header file<ul><li>/usr/include/pthread.h</li></ul></li><li>Compiler options<ul><li>gcc thread.c –o thread –lpthread</li><li>-l: link，链接本地二进制码</li></ul></li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -lpthread</span><br><span class="line">//libpthread.so,libpthread.a</span><br></pre></td></tr></table></figure></div><h2 id="3-1-命名"><a href="#3-1-命名" class="headerlink" title="3.1. 命名"></a>3.1. 命名</h2><p>pthread下的所有函数都以<code>pthread_</code>开头</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F29%2F11-31-51-7c6da78deef9bd2d44a457253224f8cc-20240429113150-2588f6.png" alt="image.png"></p><h2 id="3-2-线程操作"><a href="#3-2-线程操作" class="headerlink" title="3.2. 线程操作"></a>3.2. 线程操作</h2><h3 id="3-2-1-生命周期"><a href="#3-2-1-生命周期" class="headerlink" title="3.2.1. 生命周期"></a>3.2.1. 生命周期</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F29%2F11-40-13-c1cd41e1edb023fd1ea6491d58ea4140-20240429114012-6287c9.png" alt="image.png"></p><h3 id="3-2-2-pthread-create"><a href="#3-2-2-pthread-create" class="headerlink" title="3.2.2. pthread_create"></a>3.2.2. pthread_create</h3><p>创建线程</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">pthread_t</span> *thread, </span></span><br><span class="line"><span class="params"><span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params"><span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), </span></span><br><span class="line"><span class="params"><span class="type">void</span> *arg)</span>；</span><br></pre></td></tr></table></figure></div><ol><li>thread：输出线程ID</li><li>attr：创建线程的时候可以传属性，默认可以传<code>NULL</code></li><li><code>start_routine</code>：线程的入口函数</li><li>arg</li></ol><h3 id="3-2-3-pthread-exit"><a href="#3-2-3-pthread-exit" class="headerlink" title="3.2.3. pthread_exit"></a>3.2.3. pthread_exit</h3><p>结束线程</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> * retval)</span>;</span><br></pre></td></tr></table></figure></div><p>可以在线程里调用<code>pthread_exit</code>，也可以在线程<code>main</code>函数<code>return</code></p><h3 id="3-2-4-pthread-join"><a href="#3-2-4-pthread-join" class="headerlink" title="3.2.4. pthread_join"></a>3.2.4. pthread_join</h3><ul><li>等待另一个线程结束<ul><li>pthread库并没有限制只能主线程join子线程，但是推荐</li></ul></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> th, <span class="type">void</span> **thread_return)</span>;</span><br></pre></td></tr></table></figure></div><ol><li><code>th</code>：需要等待的线程</li><li><code>thread_return</code>：指向线程返回值的指针<ul><li>返回值是<code>void*</code></li></ul></li></ol><h3 id="3-2-5-pthread-detach"><a href="#3-2-5-pthread-detach" class="headerlink" title="3.2.5. pthread_detach"></a>3.2.5. pthread_detach</h3><ul><li>线程自己回收自己的资源，不和任何线程做join</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> th)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="3-3-线程同步"><a href="#3-3-线程同步" class="headerlink" title="3.3. 线程同步"></a>3.3. 线程同步</h2><h3 id="3-3-1-信号量"><a href="#3-3-1-信号量" class="headerlink" title="3.3.1. 信号量"></a>3.3.1. 信号量</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> </span></span><br><span class="line"><span class="params">value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">//P</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">//V</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">// 释放</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">//不阻塞的P</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure></div><ul><li>sem_init参数<ol><li>sem：指向信号量指针</li><li>pshared：是否共享</li><li>value：初始值</li></ol></li></ul><h3 id="3-3-2-互斥量"><a href="#3-3-2-互斥量" class="headerlink" title="3.3.2. 互斥量"></a>3.3.2. 互斥量</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> </span></span><br><span class="line"><span class="params"><span class="type">pthread_mutexattr_t</span> *mutexattr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div><p>互斥量里只有一份资源，内部是Boolean变量。</p><h3 id="3-3-3-条件变量"><a href="#3-3-3-条件变量" class="headerlink" title="3.3.3. 条件变量"></a>3.3.3. 条件变量</h3><p> 等待某个变量满足条件，和<strong>互斥量一起使用</strong></p><h4 id="3-3-3-1-初始化"><a href="#3-3-3-1-初始化" class="headerlink" title="3.3.3.1. 初始化"></a>3.3.3.1. 初始化</h4><ol><li>静态初始化<code>pthread_cond_t convar = PTHREAD_COND_INITIALIZER;</code></li><li><code>pthread_cond_init()</code></li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destory</span><span class="params">(<span class="type">pthread_cond_t</span> cond)</span>;</span><br></pre></td></tr></table></figure></div><h4 id="3-3-3-2-操作"><a href="#3-3-3-2-操作" class="headerlink" title="3.3.3.2. 操作"></a>3.3.3.2. 操作</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> mutex)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> cond)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> cond)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>等待：等到条件变量被通知或广播<ul><li><strong>等待时会unlock互斥量（原子操作）</strong></li><li>当重新开始执行，会lock互斥量</li></ul></li><li>通知：随机唤醒<ol><li>调用时互斥量必须是被加锁的，signal会释放互斥量</li></ol></li><li>广播：唤醒所有</li></ol><h4 id="3-3-3-3-例子"><a href="#3-3-3-3-例子" class="headerlink" title="3.3.3.3. 例子"></a>3.3.3.3. 例子</h4><p>加数据，拿数据并发修改index，len</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F13%2F10-14-29-585bba0567fdf55505009b82a7129584-20240513101428-8e6943.png" alt="image.png"></p><p><em>这代码不知道哪来的，好像不是ppt上的</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> condition;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrement_count</span><span class="params">()</span> {</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line">    count = count - <span class="number">1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment_count</span><span class="params">()</span> {</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        pthread_cond_signal(&amp;condition);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><code>pthread_cond_wait</code>之后的代码仍然在互斥区里，不用担心等待被唤醒后有并发问题。</p><h2 id="3-4-Thread-attributes"><a href="#3-4-Thread-attributes" class="headerlink" title="3.4. Thread attributes"></a>3.4. Thread attributes</h2><ul><li>线程属性对象</li><li>初始化：<code>int pthread_attr_init(pthread_attr * attr);</code></li><li>get/set族函数，获取/设置属性</li></ul><p>e.g.修改detachstate，schedpolicy属性</p><h2 id="3-5-Thread-cancellation"><a href="#3-5-Thread-cancellation" class="headerlink" title="3.5. Thread cancellation"></a>3.5. Thread cancellation</h2><p>线程强制终止。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> </span></span><br><span class="line"><span class="params">*oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="3-6-Multithread-program"><a href="#3-6-Multithread-program" class="headerlink" title="3.6. Multithread program"></a>3.6. Multithread program</h2><ul><li>容易出现错误<ol><li>共享变量缺乏保护，未互斥使用</li><li>特别的，创建线程时传递指针，指针指向的变量可能时共享的</li></ol></li></ul><p>系统不隔离，用起来方便，但不安全</p><h2 id="3-7-Thread-Local-Storage-TLS"><a href="#3-7-Thread-Local-Storage-TLS" class="headerlink" title="3.7. Thread Local Storage (TLS)"></a>3.7. Thread Local Storage (TLS)</h2><p>线程局部存储：变量是<strong>线程私有</strong>的，对于线程内部的函数是全局变量</p><p>函数内的局部变量在线程的函数调用栈里，本来就不存在全局共享</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>pthread_key_create：key相当于变量名，每一个线程都创建了这个变量，只是隔离了<ul><li>在每个线程中<strong>同时创建，同时释放</strong></li></ul></li><li>delete：会调用create时传入的析构函数                                                  </li><li>get/set：对TLS读写操作</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>02-软件架构intro</title>
    <link href="http://example.com/posts/46b5218b/"/>
    <id>http://example.com/posts/46b5218b/</id>
    <published>2024-04-16T06:04:00.000Z</published>
    <updated>2024-06-27T08:47:20.962Z</updated>
    
    <content type="html"><![CDATA[<ul><li>软件的四个本质难题<ol><li>复杂度</li><li>一致性 </li><li>可变性 </li><li>不可见性：没有几何结构</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F16%2F14-49-29-00d7cb1dc073a5a241fb8794c7cb365d-20240416144928-c3fd7b.png" alt="image.png"></p><h1 id="架构来源"><a href="#架构来源" class="headerlink" title="架构来源"></a>架构来源</h1><ul><li><p>Architecture:</p><ol><li>Component interfaces</li><li>Component communications and dependencies</li><li>Component responibilities<ol><li>性能，可用……</li></ol></li></ol></li><li><p>communication</p><ol><li>Data passing</li><li>Control flow</li></ol></li></ul><h2 id="NFR"><a href="#NFR" class="headerlink" title="NFR"></a>NFR</h2><ul><li>架构强调非功能需求NFR：how well a system works</li><li>包括<ol><li>技术限制</li><li>商业限制</li><li>质量属性</li></ol></li></ul><h1 id="architecture-views"><a href="#architecture-views" class="headerlink" title="architecture views"></a>architecture views</h1><p>有多个视图<br>解决不可见</p><h2 id="4-1-view-model"><a href="#4-1-view-model" class="headerlink" title="4+1 view model"></a>4+1 view model</h2><p>Logical view ：架构的重要元素和他们之间的关系<br>Process view  ：<br>Physical view<br>Development view</p><p>Architecture use cases: 四个视图是关于某个场景的</p><h2 id="generic-design-strategies"><a href="#generic-design-strategies" class="headerlink" title="generic design strategies"></a>generic design strategies</h2><ol><li>Decomposition</li><li>Abstraction</li><li>Stepwise: Divid and Conquer</li><li>Generate and Test，先生成一个设计，再对它测试</li><li>Iteration: Incremental Refinement</li><li>Reuseable elements，重用现有的设计</li></ol><h1 id="what-does-a-software-architect-do"><a href="#what-does-a-software-architect-do" class="headerlink" title="what does a software architect do?"></a>what does a software architect do?</h1><ol><li>Liaison<ol><li>调和用户、市场、开发等</li></ol></li><li>software engineering</li><li>technology knowledge</li><li>risk management</li></ol><h1 id="架构设计过程"><a href="#架构设计过程" class="headerlink" title="架构设计过程"></a>架构设计过程</h1><ol><li>识别和架构相关的重要需求</li><li>架构设计</li><li>文档化，以视图为中心</li><li>架构评估</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
