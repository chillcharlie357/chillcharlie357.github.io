<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Charlie</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-05T13:41:47.781Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Charlie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>6-Spring Security</title>
    <link href="http://example.com/posts/b9233e24/"/>
    <id>http://example.com/posts/b9233e24/</id>
    <published>2024-01-03T11:13:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JAAS: Java Authentication Authorization Service. JDK提供的认证授权服务</li></ul><h1 id="1-👍Spring-Security"><a href="#1-👍Spring-Security" class="headerlink" title="1. 👍Spring Security"></a>1. 👍Spring Security</h1><ul><li><p>划分为两类：</p><ol><li>针对客户web请求权限控制</li><li>针对方法级的权限控制<ul><li>针对业务层代码</li><li>调用前控制，调用后控制</li><li>例：对数据库delete操作做权限控制</li></ul></li></ol></li><li><p>在spring中使用：添加依赖<code>spring-boot-starter-security</code>后会自动加载安全相关的bean</p></li></ul><h1 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h1><p>维持客户端与服务端长时间的会话。</p><ul><li>http是无状态的协议，cookie可以保存状态<ul><li>例：保持用户登录状态</li></ul></li></ul><p>用户登录后，服务端会返回session-id，作为cookie存在本地每次请求都带上cookie</p><h1 id="3-Web请求拦截"><a href="#3-Web请求拦截" class="headerlink" title="3. Web请求拦截"></a>3. Web请求拦截</h1><ul><li>spring data权限认证的原理：使用servlet容器的filter</li></ul><p>Spring Security是一种基于Spring AOP和Servlet过滤器的安全框架，它在Web请求级和方法调用级处理身份确认和授权1。Spring Security通过一系列的Servlet Filter实现这些功能1。当添加了@EnableWebSecurity注解之后，Spring会创建一个名为springSecurityFilterChain的Bean，其类型为DelegatingFilterProxy1。这是一个特殊的Servlet Filter，它将工作委托给一个javax.servlet.Filter的实现类（其类型为FilterChainProxy），这个实现类作为一个Bean注册在Spring的应用的上下文中1。</p><p>对于一个请求，其处理顺序是：<code>DelegatingFilterProxy =&gt; FilterChainProxy =&gt; 一系列的Filter =&gt; Controller</code></p><p><a class="link" href="https://zhuanlan.zhihu.com/p/72305502">深入了解Spring Security的实现原理 - 知乎 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F10%2F26%2F092f577948a6053f598961fe1a329feb_20231026184400.png" alt="image.png"></p><h1 id="4-👍开发人员还要做什么"><a href="#4-👍开发人员还要做什么" class="headerlink" title="4. 👍开发人员还要做什么"></a>4. 👍开发人员还要做什么</h1><p><font color="#ff0000">除了框架提供的，开发人员还需要做什么，很重要</font></p><ol><li>实现接口<ul><li><code>UserDetailsService</code>接口：给Spring框架提供用户详细信息。用户信息注册存储，需要用到用户信息的时候从数据访问层获取<ul><li>这里用到之前讲到数据访问层实现技术。</li><li>和spring security解耦，只需要提供用户信息但不关心怎么实现。</li></ul></li><li>被Spring Security调用</li></ul></li><li>实现密码加密/解密对象<ul><li>PasswordEncoder</li><li>Bean对象</li></ul></li><li>(optional)实现登录页面<ul><li>有默认页面</li><li><code>/login</code>, Spring已经自动实现了对应的<code>Controller</code></li></ul></li><li>权限设定<ol><li><code>SecurityFilterChain</code>，基于注入的<code>httpSecurity</code>对象</li><li>继承父类<code>WebSecurityConfigurerAdapter</code>，实现<code>configure</code>方法</li></ol></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F10%2F26%2F4875ccdece8ae8892f54cde6042a6fef_20231026184427.png" alt="image.png"></p><ul><li>PasswordEncoder：<font color="#ff0000">密码不能明文存储</font>，需要加密后再存到数据库里<ul><li>需要定义<code>Bean</code></li></ul></li></ul><h1 id="5-框架实现了什么"><a href="#5-框架实现了什么" class="headerlink" title="5. 框架实现了什么"></a>5. 框架实现了什么</h1><ol><li>实现用户登录控制器get post</li><li>请求重定向到用户登录页面<ul><li>eg.用户未登录时，访问URL，服务端重定向到登录页面</li></ul></li><li>通过Filter对用户设定的权限进行权限控制</li></ol><h1 id="6-👍用户信息存储"><a href="#6-👍用户信息存储" class="headerlink" title="6. 👍用户信息存储"></a>6. 👍用户信息存储</h1><p>来自多个渠道，spring security不关心。</p><ol><li>内存用户数据库</li><li>JDBC用户存储<ul><li>不止是JDBC、关系型数据库，只要是持久化的都算</li></ul></li><li>LDAP用户数据库<ul><li>轻量级目录数据库</li></ul></li></ol><h1 id="7-权限分类"><a href="#7-权限分类" class="headerlink" title="7. 权限分类"></a>7. 权限分类</h1><ul><li>Authority，权限</li><li>Role，角色<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container>权限，加<strong>前缀</strong>：ROLE_<ul><li>从角色到权限</li></ul></li></ul><h1 id="8-自定义登录页面"><a href="#8-自定义登录页面" class="headerlink" title="8. 自定义登录页面"></a>8. 自定义登录页面</h1><p>使用<code>HttpSecurity</code>对象配置。</p><ul><li>当需要认证时转向的登录页：<code>.loginPage("/login")</code></li><li>视图控制器，定义login请求对应的视图：<code>registry.addViewController("/login")</code>;</li><li>登录的post请求由Spring Security自动处理，名称默认：<code>username</code>、<code>password</code>，可配置</li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formLogin()</span><br><span class="line">.loginPage(<span class="string">"/login"</span>).usernameParamrter(<span class="string">'username'</span>).passwordParameter(<span class="string">'password'</span>)</span><br></pre></td></tr></table></figure></div><h1 id="9-👍启用HTTP-Basic认证"><a href="#9-👍启用HTTP-Basic认证" class="headerlink" title="9. 👍启用HTTP Basic认证"></a>9. 👍启用HTTP Basic认证</h1><p>HTTP协议内容，与Spring框架无关。<br>由于用户 ID 与密码是是以明文的形式在网络中进行传输的（尽管采用了 base64 编码，但是 base64 算法是可逆的），所以基本验证方案并<strong>不安全</strong>。</p><ul><li>启用HTTP basic认证: <code>httpBasic()</code><ul><li>默认关闭</li></ul></li><li>在请求时带上用户名密码，一般在测试的时候使用<ul><li><code>Authorization</code>属性</li><li><code>https://username:password@www.example.com/</code></li></ul></li></ul><p><a class="link" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">HTTP authentication - HTTP | MDN <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h1 id="10-CSRF"><a href="#10-CSRF" class="headerlink" title="10. CSRF"></a>10. CSRF</h1><ul><li>跨站请求伪造<ul><li>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</li></ul></li><li>默认开启</li><li>如何关闭：<code>.csrd().disable()</code></li><li>如何忽略：<code>.ignoringAntMatchers("/admin/**")</code></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F10%2F16%2F485966b40e6bb369ce1b793d15d48bf1_20231016205535.png" alt="image.png"></p><ul><li><p>例子：</p><ol><li>受害者登录a.com，并保留了登录凭证（Cookie）。</li><li>攻击者引诱受害者访问了b.com。</li><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li></ol></li><li><p>解决：C每次提交表单A，<strong>_csrf 字段</strong>有唯一ID，无法伪造</p><ul><li>get得到<code>_csrf</code>， post请求携带<code>_csrf</code> ，防止第三方伪造</li><li>不在cookie中</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F10%2F16%2F6a1a8a2f1ac8edf6f33638931d9d15b6_20231016210157.png" alt="image.png"></p><p><a class="link" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">前端安全系列（二）：如何防止CSRF攻击？ - 美团技术团队 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h1 id="11-CORS：跨域资源共享"><a href="#11-CORS：跨域资源共享" class="headerlink" title="11. CORS：跨域资源共享"></a>11. CORS：跨域资源共享</h1><ul><li>是由浏览器定义的协议<ul><li>是一种基于 <a class="link" href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 头的机制，该机制通过允许服务器标示除了它自己以外的其他<a class="link" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</li></ul></li><li>常用于客户端与服务端分离的场景<ul><li>例：A提供静态页面，B提供Rest接口</li></ul></li></ul><h1 id="12-在后端代码获得当前登录的用户信息"><a href="#12-在后端代码获得当前登录的用户信息" class="headerlink" title="12. 在后端代码获得当前登录的用户信息"></a>12. 在后端代码获得当前登录的用户信息</h1><ol><li>注入<code>Principal</code>对象<ul><li>来自<code>java.security</code>，是JDK中JASS的低层框架</li><li><code>String username = principal.getName()</code>获取用户名</li></ul></li><li><code>@AuthenticationPrincipal</code>注解<ul><li>来自<code>Spring Security</code></li><li><code>@AuthenticationPrincipal User user</code>作为函数参数获得user对象</li></ul></li><li>安全上下文获取</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication(); <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) authentication.getPrincipal();</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>商业模式部分复习</title>
    <link href="http://example.com/posts/a8a21419/"/>
    <id>http://example.com/posts/a8a21419/</id>
    <published>2024-01-01T13:01:00.000Z</published>
    <updated>2024-01-05T13:41:47.785Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>概述：基于给定背景和题目的知识点运用</p></li><li><p>商业模式画布绘制+需求类型 – 20</p></li><li><p>商业模式类型讨论 – 10</p><ul><li>优先考察与互联网最相关的三个</li></ul></li><li><p>商业模式设计 – 10</p><ul><li>六种设计手段选一个考核</li></ul></li><li><p>商业模式评估 – 10</p><ul><li>四种评估手段选一个考核（复杂的手段会被适当地提示和约减）</li></ul></li></ul><h1 id="1-商业模式画布绘制"><a href="#1-商业模式画布绘制" class="headerlink" title="1. 商业模式画布绘制"></a>1. 商业模式画布绘制</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F10%2F12%2Fb4e83f1d6413767f73baec4b9dbc2fe2_20231012110808.png"></p><p>可能考定义</p><ol><li>客户细分：企业想要获得的和期望服务的不同的目标人群和机构<ul><li>小众 大众 求同存异 多元化 多边</li></ul></li><li>价值主张：为客户群体提供能为其创造价值的产品和服务</li><li>渠道通路：企业如何同他的客户群体沟通并建立联系，以及向对方传递自生的价值主张</li><li>客户关系：企业针对某一个客户群体建立的客户关系的类型<ul><li>私人服务，专属私人服务，自助服务，自动化服务，社区，与客户协作共同创造</li></ul></li><li>收入来源：企业从客户群体获得的现金收益</li><li>核心资源：保证一个商业模式顺利运行所需要的最重要的资产<ul><li>实物性资源，知识性资源，人力资源，金融资源</li></ul></li><li>关键业务：保障其商业模式正常运行所需要的最重要的事情</li><li>重要合作：保证一个商业模式顺利所需的供应商和合作伙伴网络<ul><li>优化及规模效应 ，降低风险和不确定性，特殊资源及活动的获得</li></ul></li><li>成本结构：运营一个商业模式所发生的全部成本<ul><li>固定成本、可变成本、规模经济、范围经济</li></ul></li></ol><h1 id="2-需求类型"><a href="#2-需求类型" class="headerlink" title="2. 需求类型"></a>2. 需求类型</h1><p>？</p><h1 id="3-商业模式类型讨论（互联网相关的3个优先）"><a href="#3-商业模式类型讨论（互联网相关的3个优先）" class="headerlink" title="3. 商业模式类型讨论（互联网相关的3个优先）"></a>3. 商业模式类型讨论（互联网相关的3个优先）</h1><p>优先考察与互联网最相关的三个</p><h2 id="3-1-多边平台商业模式"><a href="#3-1-多边平台商业模式" class="headerlink" title="3.1. 多边平台商业模式"></a>3.1. 多边平台商业模式</h2><ul><li>定义：多边平台将两个或多个独立但相互依存的客户群体进行连接，通过促进不同客户群体之间的互动创造价值。</li></ul><h2 id="3-2-长尾商业模式"><a href="#3-2-长尾商业模式" class="headerlink" title="3.2. 长尾商业模式"></a>3.2. 长尾商业模式</h2><ul><li>定义：它致力于提供相当多种类的小众产品，而其中的每一种卖出量相对很少。，即大量的小众产品但汇总的销售收入可以与传统模式销售媲美。</li></ul><h2 id="3-3-免费商业模式"><a href="#3-3-免费商业模式" class="headerlink" title="3.3. 免费商业模式"></a>3.3. 免费商业模式</h2><ul><li><p>定义：至少有一个客户群体可以持续地免费享受服务，不付费的客户群体所得到的财政支持来自于付费的客户群体。</p></li><li><p>三种可行的免费商业模式</p><ol><li>广告模式</li><li>免费增值模式</li><li>陷阱诱饵模式</li></ol></li></ul><h2 id="3-4-开放商业模式"><a href="#3-4-开放商业模式" class="headerlink" title="3.4. 开放商业模式"></a>3.4. 开放商业模式</h2><ul><li>定义：适用于通过与外部合作伙伴系统性地配合而创造和收获价值的企业。<ul><li>由外而内：将外部的理念、技术或知识产权引入内部</li><li>由内而外：向外部合作伙伴输出公司无用的理念和资产，用于将企业内部的闲置资产变现，主要针对的是专利和技术</li></ul></li></ul><h2 id="3-5-分拆商业模式"><a href="#3-5-分拆商业模式" class="headerlink" title="3.5. 分拆商业模式"></a>3.5. 分拆商业模式</h2><ul><li>定义：将企业从事的活动分为三种不同类型，客户关系管理，新产品开发以及基础设施管理。这三种类型可能共存于同一家企业中，但理想情况下，它们各自存在于相互独立的实体中以避免冲突或不必要的消长。</li></ul><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6. 总结"></a>3.6. 总结</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F24%2F20-22-43-8d955f97fd26df785a3ff6fa5a22e6c5-20231224202243-7fce94.png" alt="image.png"></p><h1 id="4-商业模式设计（6选1）"><a href="#4-商业模式设计（6选1）" class="headerlink" title="4. 商业模式设计（6选1）"></a>4. 商业模式设计（6选1）</h1><ol><li>客户洞察<ul><li>客户视角是指导性原则</li><li>需求 情感 功能</li><li>移情图</li></ul></li><li>构思<ul><li>步骤：产生大量商业模式创意，对创意进行整合并挑选</li><li>创新焦点：客户驱动，财政驱动，资源驱动，供给驱动，多点驱动</li><li>团队流程： 团队构建， 钻研， 开拓， 甄选，构建商业模型</li></ul></li><li>视觉化<ul><li>复杂变得简单化，抽象变得具象</li><li>两个技术：便利贴，草图</li><li>四个流程：理解，对话，探索，沟通</li></ul></li><li>模型构建<ul><li>可以使抽象的概念具体化，帮助探索新的创意。有助于实际商业模式的探索。</li><li>设计态度：专注探索，全面考虑，快速放弃，选出值得优化的想法，接受不确定性</li><li>不同规模：随手素描，精心设计的画布，商业案例，实地验证</li></ul></li><li>讲故事<ul><li>故事是一个理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备。</li><li>为什么：介绍新想法，向投资人推销，吸引员工</li><li>视角：公司视角，员工视角</li></ul></li><li>场景<ul><li>将模型构建中明确的方向具体化，从而给出有见地的设计</li><li>两种场景：不同的客户结构，未来商业模式可能面临的竞争环境</li><li>如何为一个故事设计并补充场景：了解与评估，购买与传递，交互，售后，评价与复购</li></ul></li></ol><p>讲故事和场景都是商业模式设计中的重要工具，它们各自有着不同的侧重点和应用场景。讲故事主要是为了更好地传达和解释新的商业模式，而场景则是为了更深入地理解和应用商业模式。</p><h1 id="5-商业模式评估（4选1）"><a href="#5-商业模式评估（4选1）" class="headerlink" title="5. 商业模式评估（4选1）"></a>5. 商业模式评估（4选1）</h1><ol><li>外部环境评估<ul><li>市场影响力：市场问题 市场分类 切换成本 市场需求 收入影响力</li><li>行业影响力：现在的竞争对手 新的竞争对手 供应商和价值链上的其他厂商 有可以替代的产品 利益相关者</li><li>关键趋势：技术趋势 行业管理趋势 经济趋势 社会文化趋势</li><li>宏观经济：资本市场 全球市场 大宗商品 经济基础设施</li></ul></li><li>总体评估<ul><li>针对画布各个模块分析加分项和减分项</li></ul></li><li>SWOT<ul><li>四个评估角度：价值主张，用户界面，基础设施，成本收入</li><li>SW 优势劣势</li><li>O 机遇</li><li>T 威胁</li></ul></li><li>蓝海战略<ul><li>三个方向：探索价值主张，探索成本影响，探索对客户的影响</li><li>四项基本行动：提升 削减 创造 删除</li></ul></li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_需求与商业模式创新" scheme="http://example.com/categories/2023-Fall-%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_需求与商业模式创新" scheme="http://example.com/tags/2023-Fall-%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"/>
    
    <category term="ikuang" scheme="http://example.com/tags/ikuang/"/>
    
  </entry>
  
  <entry>
    <title>需求部分复习</title>
    <link href="http://example.com/posts/e27123b2/"/>
    <id>http://example.com/posts/e27123b2/</id>
    <published>2023-12-31T12:12:00.000Z</published>
    <updated>2024-01-05T13:41:47.785Z</updated>
    
    <content type="html"><![CDATA[<ul><li>需求获取（30分）<ul><li>需求获取上半段（20分）<ul><li>确定项目前景与范围（10分） – 目标模型</li><li>涉众分析（10分） – <del>涉众识别之ADM模型</del>、涉众评估之Power-Interest、Power-Attitude模型</li><li>涉众共赢之Stakeholder-Issue模型</li></ul></li><li>需求获取下半段（10分）<ul><li>面谈、原型、观察三大获取手段的联系与区别</li><li>面谈问题的设计</li></ul></li></ul></li><li>需求分析（10分）<ul><li>需求分析基本任务</li><li><del>基于UML软件建模的需求细化 – 概念类图、顺序图、状态图</del></li></ul></li><li>需求规格说明</li><li>需求验证与管理（10分）<ul><li>需求验证基本活动</li><li>需求管理任务与活动</li><li>需求变更控制过程、组织与注意事项</li></ul></li></ul><h1 id="1-需求分类"><a href="#1-需求分类" class="headerlink" title="1. 需求分类"></a>1. 需求分类</h1><ol><li>功能需求<ul><li>业务需求：系统建立的战略出发点，高层次目标，描述解决方案和系统特性。</li><li>用户需求：用户对系统能完成的具体任务的期望，描述系统能帮用户做什么。</li><li>系统需求：用户对系统行为的期望，一系列系统行为能帮助用户完成任务，满足业务需求。</li></ul></li><li>性能需求：速度，容量，吞吐量，负载，实时性</li><li>质量需求：功能性，可移植性，可维护性，效率，可用性，可靠性</li><li>对外接口：软硬件接口，用户界面，通信接口</li><li>约束：系统开发及运行的环境，问题域内的相关标准，商业准则，法律法规，社会性因素</li><li>其他：安装需求，培训需求，数据内容，数据信息</li></ol><h1 id="2-需求获取"><a href="#2-需求获取" class="headerlink" title="2. 需求获取"></a>2. 需求获取</h1><h2 id="2-1-上半场"><a href="#2-1-上半场" class="headerlink" title="2.1. 上半场"></a>2.1. 上半场</h2><p>确定获取的内容主题</p><h3 id="2-1-1-确定项目前景与范围-–-目标模型"><a href="#2-1-1-确定项目前景与范围-–-目标模型" class="headerlink" title="2.1.1. 确定项目前景与范围 – 目标模型"></a>2.1.1. 确定项目前景与范围 – 目标模型</h3><ul><li><p>目标模型的关系</p><ol><li><strong>精化</strong>(Refinement)关系<ul><li>AND：一系列子目标紧密结合完成大目标，关系画黑圈</li><li>OR：任一子目标都是目标的替代方案，关系画白圈</li></ul></li><li><strong>阻碍</strong>(Obstruction)关系<ul><li>可以继续and,or</li></ul></li><li><strong>支持与冲突</strong>(Support/Conflict)关系<ul><li>Support链接表示一个目标对其他目标的<strong>支持促进</strong>作用，支持关系可以被处理为<strong>OR精化关系</strong></li><li>Conflict链接表示一个目标的实现对其他目标的实现有<strong>阻碍</strong>作用。<strong>在关系上画X</strong></li></ul></li></ol></li><li><p>目标模型做法</p><ol><li>首先提出问题，对问题进行分析，然后提出业务需求，业务需求就是我们的高层目标。可以分为软目标和硬目标。软用云朵，硬用方块。</li><li>高层次目标可以分解为低层次目标。低层次目标用and或者or精化，子目标展开到单一事务时终止。<ul><li>and：用一个集中的黑圈</li><li>or：每一个目标指向父目标的白圈。表示多种可以相互替代的“候选办法”</li></ul></li><li>对每个高层次目标进行分析了以后，高层次目标也可以连接在一起。考虑已有目标之间的支持与冲突关系</li></ol></li><li><p>目标有以下几种形式</p><ul><li>avoid 避免</li><li>achieve 实现</li><li>Cease 终止</li><li>maintain 维持</li><li>optimize 优化<ul><li>min</li><li>max</li></ul></li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F31%2F21-28-16-b827409729b9137df84dba4ed9d6c55b-20231231212815-ab4885.png" alt="image.png"></p><h3 id="2-1-2-涉众分析"><a href="#2-1-2-涉众分析" class="headerlink" title="2.1.2. 涉众分析"></a>2.1.2. 涉众分析</h3><ul><li><p>涉众stakeholder：所有能够影响软件系统的实现，或者会被实现后的软件系统所影响的，<font color="#c00000">关键个人和团体</font></p></li><li><p>过程</p><ol><li>涉众识别</li><li>涉众描述</li><li>涉众评估</li><li>涉众代表选择</li></ol></li><li><p>涉众评估之Power-Interest、Power-Attitude模型</p><ul><li>风险评估</li><li>基于涉众特征与态度化解涉众风险策略</li></ul></li><li><p>基于<strong>特征</strong>化解举例：亲子兴趣班</p><ul><li>大人与小朋友一起参与：<strong>环境设定者</strong>（客户）-&gt; <strong>参与者</strong>（用户）</li><li>良好的产品体验打造亲子品牌：<strong>被影响者</strong>（潜在用户/客户） -&gt; <strong>参与者</strong></li></ul></li><li><p>基于<strong>态度</strong>化解举例：电子竞技产业</p><ul><li>与地方政府文化产业发展相结合：<strong>强反对者</strong> -&gt; <strong>强支持者</strong></li><li>成功的赛事运营与未成年人游戏时长限制：<strong>弱反对者</strong> -&gt; <strong>弱支持者</strong></li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F01%2F09-02-42-2df333875e704153d24d553d49b07d59-20240101090241-80c8fa.png" alt="image.png"></p><ul><li>Power-interest图：优先级评估<ol><li>参与者：系统的实际使用者，对系统最终成功有较大影响力，收到系统较大影响，<strong>优先级最高</strong>。</li><li>环境设定者：很少使用系统，但是由于政治、经济等因素对系统有比较大的影响，优先级次之，最常见的是政府和管理者。</li><li>被影响者：可能是系统直接使用者，也可能是因为系统出现被剥夺了部分利益的输家，受影响大，能影响少，优先级一般低于环境设定者，但是特殊情况下也可能高于环境设定者。</li><li>观众：不受影响，也不影响，优先级最低，比如环境专家和市场力量。</li></ol></li><li>Power/Attitude图：风险评估<ol><li>强反对者是需要重点分析的。</li><li>涉众的关注点和兴趣去向也是重要内容，一般环境设定者是项目高风险因素。</li><li>对于高风险的涉众类别，要尽可能澄清各个涉众类别的角色和职责，发现项目对他们的依赖和假设条件，分析实际情况与预期不一致时可能出现的风险，并提前化解。</li></ol></li><li>化解涉众风险<ol><li>一方面提高环境设定者对系统的关注，转化为参与者</li><li>一方面消除强反对者的反对原因，变为强支持者</li><li>给予被影响者一些发表和实现自身意见的权利，缓解忧虑</li></ol></li></ul><h3 id="2-1-3-涉众共赢之Stakeholder-Issue模型"><a href="#2-1-3-涉众共赢之Stakeholder-Issue模型" class="headerlink" title="2.1.3. 涉众共赢之Stakeholder-Issue模型"></a>2.1.3. 涉众共赢之Stakeholder-Issue模型</h3><p>列出系统所有的受众，明确描述他们的兴趣和对系统的期望，发现背后的共同问题<strong>Issue</strong>。如果某个涉众类别对一个Issue存在兴趣，那这个关系就是一个<strong>Stakeholder-Issue关系</strong>。</p><p>共赢分析：</p><ol><li>某个Stakeholder-Issue关系上所寄予的期望与<strong>项目的业务需求</strong>无法保持一致，那么它关联的涉众就在该Issue的问题上和<strong>项目整体目标存在冲突</strong><ul><li>涉众和项目负责人相互调整折中</li><li>重新评估项目的可行性</li></ul></li><li>Stakeholder/Issue关系图中某个Issue所关联的不同关系标识有互相冲突的期望，那么就意味着它所关联的<strong>涉众在该Issue上存在需求冲突</strong><ul><li>分析各个冲突方成为赢家的条件</li><li>适当的调整，化解冲突</li><li>分析项目在该Issue上的目标、约束和可选方案，并提供给冲突方进行权衡，促进他们之间协商解决</li></ul></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F02%2F16-03-05-059c866ff566bc5e0dba26a72f34e30b-20240102160304-fac1f8.png" alt="image.png"></p><h2 id="2-2-下半场"><a href="#2-2-下半场" class="headerlink" title="2.2. 下半场"></a>2.2. 下半场</h2><p>设计具体的应用环境和场景条件，由用户根据细节业务的执行来描述问题、表达期望</p><h3 id="2-2-1-面谈、原型、观察三大获取手段的联系与区别"><a href="#2-2-1-面谈、原型、观察三大获取手段的联系与区别" class="headerlink" title="2.2.1. 面谈、原型、观察三大获取手段的联系与区别"></a>2.2.1. 面谈、原型、观察三大获取手段的联系与区别</h3><ul><li>联系：都是需求获取的方法</li><li>区别：<ol><li>面谈可以获取用户的直接反馈和需求</li><li>原型可以让用户直观看到需求工程师的设计思路，并通过用户的反馈调整和。原型可以用来消除不确定性。</li><li>观察可以让需求工程师更深入地理解用户在实际环境中的需求。应用于用户无法完成主动的信息告知的情况下。</li></ol></li></ul><h3 id="2-2-2-面谈问题的设计"><a href="#2-2-2-面谈问题的设计" class="headerlink" title="2.2.2. 面谈问题的设计"></a>2.2.2. 面谈问题的设计</h3><ol><li>开放式问题：回答不受限制</li><li>封闭式问题：（受限制）程序性提示</li><li>探究式问题 <ul><li>为什么？</li><li>你能举个例子吗？</li><li>你能详细描述一下吗？</li></ul></li><li>诱导性问题 （不好）<ul><li>“你和其他经理一样，都同意把财产管理计算机化，是吗”</li></ul></li><li>双筒问题 （不好）<ul><li>“每天你通常会做什么决策，你是怎样做的” </li><li>过于宽泛，要回答的东西特别多</li></ul></li><li>元问题 <ul><li>我的问题看起来相关吗？</li><li>你的回答正式吗？</li><li>你是回答这些问题的最佳人选吗？</li><li>我问了太多的问题吗？</li><li>我还应该见什么人？</li></ul></li></ol><h1 id="3-需求分析"><a href="#3-需求分析" class="headerlink" title="3. 需求分析"></a>3. 需求分析</h1><h2 id="3-1-基本任务"><a href="#3-1-基本任务" class="headerlink" title="3.1. 基本任务"></a>3.1. 基本任务</h2><ol><li>建立分析模型，达成开发者和用户对需求的共同理解<ul><li>将复杂的系统分解成为简单的部分以及它们之间的联系，确定本质特征</li><li>和用户达成对信息内容的共同理解</li><li>分析的活动主要包括识别、定义和结构化，它的目的是获取某个可以转换为知识的事物的信息</li></ul></li><li>依据共同理解，发挥创造性，建立解决方案<ul><li>将一个问题分解成独立的、更简单和易于管理的子问题来帮助寻找解决方案</li><li>创建解决方案的过程是创造性的</li><li>帮助开发者建立问题的定义，并确定被定义的事物之间的逻辑关系</li><li>这些逻辑关系可以形成信息的推理，进而可以被用来验证解决方案的正确性。</li></ul></li></ol><h2 id="3-2-需求分析活动"><a href="#3-2-需求分析活动" class="headerlink" title="3.2. 需求分析活动"></a>3.2. 需求分析活动</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F01%2F10-15-15-b1ea8e4aaa788275de931e733c7ff18f-20240101101514-66f916.png" alt="image.png"></p><ul><li>需求细化：防止开发者各自假设造成的不一致</li><li>确定需求优先级：<ul><li>累积投票</li><li>区域划分：重要性，紧急性，惩罚性，成本，风险</li></ul></li><li>需求协商：开发人员内部，明确冲突的因素、解决空间和解决方案</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F01%2F10-21-07-9af6ddf87255b6d0447fdf8ca3f3ea9d-20240101102106-22ebef.png" alt="image.png"></p><h1 id="4-需求验证与管理"><a href="#4-需求验证与管理" class="headerlink" title="4. 需求验证与管理"></a>4. 需求验证与管理</h1><p>需求验证是专指在需求规格说明完成之后，对需求规格说明文档进行的验证活动</p><h2 id="4-1-需求验证基本活动"><a href="#4-1-需求验证基本活动" class="headerlink" title="4.1. 需求验证基本活动"></a>4.1. 需求验证基本活动</h2><ul><li>验证流程：</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F01%2F10-36-16-5f9bab4fd1aefa57ec716571f60edba9-20240101103615-64ac0b.png" alt="image.png"></p><ul><li>需求验证方法<ol><li><font color="#c00000">评审</font>  </li><li><font color="#c00000">原型与模拟</font>  </li><li>开发测试用例  </li><li>用户手册编制 </li><li>利用跟踪关系  </li><li><em>自动化分析</em></li></ol></li></ul><h2 id="4-2-需求管理任务与活动"><a href="#4-2-需求管理任务与活动" class="headerlink" title="4.2. 需求管理任务与活动"></a>4.2. 需求管理任务与活动</h2><ul><li>任务：<ol><li>维护需求基线</li><li>实现需求跟踪</li><li>控制变更</li></ol></li><li>活动：<ol><li>交流涉众需要什么；</li><li>驱动设计和实现工作；</li><li>测试和验证最终产品；</li><li>辅助项目管理</li><li>将需求应用、实施到解决方案；</li><li>将需求分配到子系统；</li><li>控制变更；</li><li>控制迭代式开发中的变化；</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F01%2F21-41-59-75eebd931d884713c95d54bed8236100-20240101214158-7283f2.png" alt="image.png"></p><h2 id="4-3-需求变更控制过程"><a href="#4-3-需求变更控制过程" class="headerlink" title="4.3. 需求变更控制过程"></a>4.3. 需求变更控制过程</h2><p>以可控、一致的方式进行需求基线中需求的变更处理，包括对变化的评估、协调、批准或拒绝、实现和验证。</p><ol><li>提请者：提出需求变更</li><li>接收者：接受需求变更</li><li>评估者：进行变更评估，<strong>产生需求变更表单</strong></li><li>变更控制委员会：变更决策，<strong>决定变更/拒绝变更</strong></li><li>修改者：执行变更</li><li>验证者：验证变更</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F01%2F21-46-48-01272090eaf64bdf514213ba56577415-20240101214647-f691a3.png" alt="image.png"></p><h2 id="4-4-需求变更组织"><a href="#4-4-需求变更组织" class="headerlink" title="4.4. 需求变更组织"></a>4.4. 需求变更组织</h2><p>变更控制委员会（CCB）:评价需求的变更，做出批准或者拒绝变化的决定，并确保已批准变化的实现。</p><p>人员可能来自：项目或程序管理部门； 产品管理或者需求分析部门； 开发部门； 测试或者质量保障部门；配置管理部门</p><h2 id="4-5-需求变更注意事项"><a href="#4-5-需求变更注意事项" class="headerlink" title="4.5. 需求变更注意事项"></a>4.5. 需求变更注意事项</h2><ol><li>认识到变更的必要性，并为之制定计划  </li><li>维护需求基线，审计变更记录</li><li>管理范围蔓延</li><li>灵活应对变更请求</li><li>使用辅助工具</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_需求与商业模式创新" scheme="http://example.com/categories/2023-Fall-%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_需求与商业模式创新" scheme="http://example.com/tags/2023-Fall-%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>10-人机交互基础知识</title>
    <link href="http://example.com/posts/c3e734a2/"/>
    <id>http://example.com/posts/c3e734a2/</id>
    <published>2023-12-30T03:12:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-信息处理模型"><a href="#1-信息处理模型" class="headerlink" title="1. 信息处理模型"></a>1. 信息处理模型</h1><p>研究人对外界信息的接收、存储、集成、检索和使用，可预测人执行 特定任务的效率，如可推算人需要多长时间来感知和响应某个刺激（又 称“反应时间”），信息过载会出现怎样的瓶颈现象等。</p><h2 id="1-1-人类处理机模型"><a href="#1-1-人类处理机模型" class="headerlink" title="1.1. 人类处理机模型"></a>1.1. 人类处理机模型</h2><p>最著名的<strong>信息处理模型</strong>，描述了人们从感知信息到付诸行动的认知过程</p><h3 id="1-1-1-三个交互式组件"><a href="#1-1-1-三个交互式组件" class="headerlink" title="1.1.1. 三个交互式组件"></a>1.1.1. 三个交互式组件</h3><ul><li>感知处理器<ul><li>信息将被输出到声音存储和视觉存储区域</li></ul></li><li>认知处理器<ul><li>输入将被输出到工作记忆，能够访问工作记忆和长时记忆中的信息</li></ul></li><li>动作处理器<ul><li>执行动作</li></ul></li></ul><h3 id="1-1-2-信息处理模型的用途"><a href="#1-1-2-信息处理模型的用途" class="headerlink" title="1.1.2. 信息处理模型的用途"></a>1.1.2. 信息处理模型的用途</h3><p>人机交互本质上也可以被看作是一个信息处理过程</p><ol><li>在进行界面设计时，可将与人的信息处理能力相关的知识和理论作为参考</li><li>可评估完成不同任务所需的认知要求</li><li>可预测不同界面下任务的完成效果</li></ol><h3 id="1-1-3-存在问题"><a href="#1-1-3-存在问题" class="headerlink" title="1.1.3. 存在问题"></a>1.1.3. 存在问题</h3><ol><li>把认知过程描述为一系列处理步骤</li><li>仅关注单个人和单个任务的执行过程<ul><li>忽视了复杂操作执行中人与人之间及任务与任务之间的互动</li></ul></li><li>忽视了环境和其他人可能带来的影响</li></ol><h2 id="1-2-格式塔-GESTALT-心理学"><a href="#1-2-格式塔-GESTALT-心理学" class="headerlink" title="1.2. 格式塔(GESTALT) 心理学"></a>1.2. 格式塔(GESTALT) 心理学</h2><ul><li>研究人是如何感知一个良好组织的模式的，而不是将其视为一系列相互独立的部分<ul><li>事物的整体区别于部分的组合</li><li>人倾向于有组织的信息</li></ul></li><li>“Gestalt” 德语，“完形（configuration）”或“型式（pattern）” ，格式塔心理学又称完形心理学</li></ul><h3 id="1-2-1-主要原则"><a href="#1-2-1-主要原则" class="headerlink" title="1.2.1. 主要原则"></a>1.2.1. 主要原则</h3><ol><li>相似性</li><li>相近性</li><li>连续性</li><li>对称性</li><li>完整性和闭合性</li></ol><h3 id="1-2-2-相近性原则"><a href="#1-2-2-相近性原则" class="headerlink" title="1.2.2. 相近性原则"></a>1.2.2. 相近性原则</h3><ul><li><strong>空间上比较靠近</strong>的物体容易被视为整体<ul><li>设计界面时应按照相关性对组件进行分组</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F30%2F11-23-54-40da792445f4a58ec9694c5a9d01acf4-20231230112354-00bda7.png" alt="image.png"></p><h3 id="1-2-3-相似性原则"><a href="#1-2-3-相似性原则" class="headerlink" title="1.2.3. 相似性原则"></a>1.2.3. 相似性原则</h3><ul><li>人们习惯将看上去<strong>相似的物体</strong>看成一个整体<ul><li>功能相近的组件应该使用相同或相近的表现形式</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F30%2F11-27-01-d58458abd9ced58c4b902382e73c28c8-20231230112700-d6bc09.png" alt="image.png"></p><h3 id="1-2-4-连续性原则"><a href="#1-2-4-连续性原则" class="headerlink" title="1.2.4. 连续性原则"></a>1.2.4. 连续性原则</h3><ul><li><strong>共线或具有相同方向</strong>的物体会被组合在一起<ul><li>将组件对齐，更有助于增强用户的主观感知效果</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F30%2F11-28-06-f05b36175fa2899541222d7cebe9a8a0-20231230112806-d8bbdf.png" alt="image.png"></p><h3 id="1-2-5-对称性原则"><a href="#1-2-5-对称性原则" class="headerlink" title="1.2.5. 对称性原则"></a>1.2.5. 对称性原则</h3><ul><li><strong>相互对称且能够组合为有意义单元的物体</strong>会被组合在一起</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F24%2F21-05-11-b9f5d54ed55c230a3205c9b2d962baa9-20231224210511-7e25e5.png" alt="image.png"></p><h3 id="1-2-6-完整和闭合性原则"><a href="#1-2-6-完整和闭合性原则" class="headerlink" title="1.2.6. 完整和闭合性原则"></a>1.2.6. 完整和闭合性原则</h3><ul><li>人们倾向于<strong>忽视轮廓的间隙</strong>而将其视作一个完整的整体<ul><li>页面上的空白可帮助实现分组</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F30%2F11-29-10-00b922945049becc3057c6a955595f31-20231230112909-19ad58.png" alt="image.png"></p><h3 id="1-2-7-举例"><a href="#1-2-7-举例" class="headerlink" title="1.2.7. 举例"></a>1.2.7. 举例</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F24%2F21-07-18-54a82b55441ade8883b4d55943a596d2-20231224210718-7d8da3.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F24%2F21-07-28-0df26775a8204faff615c8b82e62ffa4-20231224210728-d7053b.png" alt="image.png"></p><h1 id="2-人脑中的记忆结构"><a href="#2-人脑中的记忆结构" class="headerlink" title="2. 人脑中的记忆结构"></a>2. 人脑中的记忆结构</h1><ul><li>三个阶段，Atkinson和Shiffrin<ul><li>感觉记忆</li><li>短时记忆</li><li>长时记忆</li></ul></li><li>三个阶段之间可以进行信息交换</li></ul><h2 id="2-1-人的记忆过程"><a href="#2-1-人的记忆过程" class="headerlink" title="2.1. 人的记忆过程"></a>2.1. 人的记忆过程</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F24%2F20-54-06-878f7ac9a1caa9da72c6d208119fa4b4-20231224205406-68e247.png" alt="image.png"></p><ol><li>感觉记忆<ul><li>瞬时记忆，持续约1s</li><li>作用：视觉暂留，视频的实现</li></ul></li><li>短时记忆<ul><li>工作记忆，30s左右。储存当前正在处理的信息。</li><li>感觉记忆经编码后进入短时记忆</li><li>Short Term Memory, 简称 STM</li><li><strong>存储能力</strong>：7+2，7-2个<font color="#c00000">信息单元</font></li></ul></li><li>长时记忆<ul><li>短时记忆中的信息经进一步加工后会变为长时记忆不代表长时记忆区的信息丢失了</li><li>遗忘：可能失去了提取信息的途径，或原有联系受到了干扰。但不代表记忆丢失。</li></ul></li></ol><h2 id="2-2-7±2理论vs-交互式系统设计"><a href="#2-2-7±2理论vs-交互式系统设计" class="headerlink" title="2.2. 7±2理论vs. 交互式系统设计"></a>2.2. 7±2理论vs. 交互式系统设计</h2><ul><li>浏览菜单和工具栏基于人的识别功能<ul><li>人们识别事物的能力要远胜于回忆事物的能力</li></ul></li><li>界面设计时要尽可能减小对用户的记忆需求，同时可考虑通过将信息放置于一定的上下文中，来减少信息单元的数目</li></ul><h1 id="3-界面类型"><a href="#3-界面类型" class="headerlink" title="3. 界面类型"></a>3. 界面类型</h1><h2 id="3-1-基于命令的界面"><a href="#3-1-基于命令的界面" class="headerlink" title="3.1. 基于命令的界面"></a>3.1. 基于命令的界面</h2><ul><li>用户通过在屏幕某个位置上键入特定命令或靠组合键的方式来执行任务</li><li>优点<ul><li>专家用户能够快速而精确地完成任务；</li><li>较GUI节约系统资源；</li><li>可动态配置可操作选项；</li></ul></li><li>设计和研究问题<ul><li>命令的形式、语法和组织</li><li>选择易于标记/命名命令的方法应尽可能一致</li></ul></li></ul><h2 id="3-2-WIMP和GUI"><a href="#3-2-WIMP和GUI" class="headerlink" title="3.2. WIMP和GUI"></a>3.2. WIMP和GUI</h2><ul><li>WIMP: Window, Icon , Menu, Pointing</li><li>GUI: Graphical User Interface</li><li>设计和研究问题<ul><li>如何进行窗口管理，找到内容并在不同窗口之间流畅切换</li><li>确定菜单选项的最佳术语</li><li>消除图标的歧义</li></ul></li></ul><h2 id="3-3-多媒体界面"><a href="#3-3-多媒体界面" class="headerlink" title="3.3. 多媒体界面"></a>3.3. 多媒体界面</h2><p>在单个界面中组合不同的媒体，即图形、文本、视频、声音和动画，并将他们与各种形式的交互相连接。</p><ul><li>研究和设计问题<ul><li>多媒体内容设计<ul><li>何时使用音频与图形、声音与动画等</li></ul></li></ul></li></ul><h2 id="3-4-虚拟现实和增强现实"><a href="#3-4-虚拟现实和增强现实" class="headerlink" title="3.4. 虚拟现实和增强现实"></a>3.4. 虚拟现实和增强现实</h2><p>Virtual Reality &amp; Augmented Reality</p><ul><li>研究和设计问题<ul><li>如何防止用户体验不好的事情</li><li>确保用户使用最有效的导航方式，如第 一人称、第三人称</li><li>如何使用户与虚拟环境中的其他人协作和沟通</li></ul></li></ul><h2 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5. 其他"></a>3.5. 其他</h2><ol><li>信息可视化和仪表盘</li><li>笔式交互和触摸交互</li><li>手势界面</li><li>实物界面</li><li>可穿戴计算</li><li>脑机接口</li></ol><h2 id="3-6-GUI演化"><a href="#3-6-GUI演化" class="headerlink" title="3.6. GUI演化"></a>3.6. GUI演化</h2><p>更少的记忆<br>更多的识别<br>更少的键盘和点击<br>更不容易出错<br>更可视化的上下文</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/categories/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/tags/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>7-询问专家和用户</title>
    <link href="http://example.com/posts/a17d59f2/"/>
    <id>http://example.com/posts/a17d59f2/</id>
    <published>2023-12-29T08:08:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-查询用户-访谈"><a href="#1-查询用户-访谈" class="headerlink" title="1. 查询用户-访谈"></a>1. 查询用户-访谈</h1><p>访谈：有目的的对话过程</p><h2 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1. 分类"></a>1.1. 分类</h2><ul><li>非结构化访谈<ul><li>问题是开放式的，不限定内容和格式</li><li>受访人自行选择详细回答还是简要回答</li><li>访问人应确保能够搜集到重要问题的回答</li></ul></li><li>结构化访谈<ul><li>根据预先确定的一组问题进行访谈</li><li>问题通常是“封闭式”的，它要求准确的回答</li></ul></li><li>半结构化访谈<ul><li>开放式问题+封闭式问题</li><li>注意不要暗示答案</li></ul></li><li>集体访谈<ul><li>基本思想：个别成员的看法是在应用的上下文中通过与其他用户的交流而形成的</li><li>“焦点小组”是集体访谈的一种形式</li></ul></li></ul><h2 id="1-2-焦点小组"><a href="#1-2-焦点小组" class="headerlink" title="1.2. 焦点小组"></a>1.2. 焦点小组</h2><ul><li>非正式的评估方法<ul><li>在界面设计之前和经过一段使用之后评估用户的需要和感受</li><li>是市场、政治和社会科学研究经常使用的方法</li><li>人数限制：由大约6到9个典型用户组成</li></ul></li><li>主持人工作<ul><li>事先列出一张讨论问题和数据收集目标的清单</li><li>保持所谈论的内容不离题</li><li>保证小组的每个成员都积极参与谈论</li><li>讨论结果的分析报告</li></ul></li></ul><h1 id="2-查询专家-问卷"><a href="#2-查询专家-问卷" class="headerlink" title="2. 查询专家-问卷"></a>2. 查询专家-问卷</h1><p>本质上也是访谈的一种</p><h2 id="2-1-设计原则👍"><a href="#2-1-设计原则👍" class="headerlink" title="2.1. 设计原则👍"></a>2.1. 设计原则👍</h2><ol><li>注意提问次序，先提出一般化再提出具体问题</li><li>确保问题明确，具体</li><li>在可能时，采用封闭式问题并提供充足的答案选项</li><li>对于征求用户意见的问题时，应该提供”<strong>无看法</strong>“选项</li><li>避免使用复杂的多重问题</li><li>在使用等级标度时，应设定适当的等级范围，并确保它们不重叠<ul><li>做到直观、一致</li></ul></li><li>避免使用术语</li><li>明确说明如何完成问卷<ul><li>比如在选项前的方框内打√</li></ul></li><li>在设计问卷时，既要做到紧凑，也应适当留空</li></ol><h2 id="2-2-用户满意度调查表QUIS"><a href="#2-2-用户满意度调查表QUIS" class="headerlink" title="2.2. 用户满意度调查表QUIS"></a>2.2. 用户满意度调查表QUIS</h2><ul><li>涉及细节<ul><li>界面细节</li><li>界面对象</li><li>界面行为</li><li>任务表达</li></ul></li></ul><h2 id="2-3-问卷组织👍"><a href="#2-3-问卷组织👍" class="headerlink" title="2.3. 问卷组织👍"></a>2.3. 问卷组织👍</h2><h3 id="2-3-1-问卷调查中的两个关键问题"><a href="#2-3-1-问卷调查中的两个关键问题" class="headerlink" title="2.3.1. 问卷调查中的两个关键问题"></a>2.3.1. 问卷调查中的两个关键问题</h3><ol><li>如何寻找有代表性的用户</li><li>如何达到合理的回复率</li></ol><h3 id="2-3-2-有助于提高回复率的措施"><a href="#2-3-2-有助于提高回复率的措施" class="headerlink" title="2.3.2. 有助于提高回复率的措施"></a>2.3.2. 有助于提高回复率的措施</h3><p>精心涉及问卷，避免用户厌烦<br>不要主观引导<br>参照QUIS，提供简要描述，说明用户若没有时间完成整份问卷，可以只完成简短的部分<br>解释为什么要进行这些问卷调查，并说明将为参与者保密<br>在发出问卷之后，通过后续邮件、电话或电子邮件联系参与者<br>采取一些激励措施（如有偿调查等）<br>进行小规模测验</p><h2 id="2-4-问卷与访谈"><a href="#2-4-问卷与访谈" class="headerlink" title="2.4. 问卷与访谈"></a>2.4. 问卷与访谈</h2><ul><li>都是间接方法<ul><li>都不是对用户界面直接研究</li><li>都不能完全听信和采纳用户的说法</li></ul></li><li>访谈<ul><li>形式更自由</li><li>难以获得确切数据</li><li>需要花费更多时间</li><li>可在访谈后立即得到结果</li><li>可能回避某些“敏感问题”的真实想法</li></ul></li></ul><h1 id="3-询问专家-认知走查"><a href="#3-询问专家-认知走查" class="headerlink" title="3. 询问专家-认知走查"></a>3. 询问专家-认知走查</h1><p>专家不是以自己身份评估，而是目标<strong>扮演用户</strong>。试图想象出人们在<font color="#c00000">第一次</font>使用某个产品时的想法以及所采取的动作，它的大作流程是怎样的。<strong>主要目标是确定使一个系统如何易于学习</strong>。</p><p>实践中不太会用，因为很繁琐。</p><p>与合作评估类似，也存在合作走查。</p><ul><li>优点<ul><li>需要用户参与</li><li>不需要可运行的原型(要界面原型)</li><li>能找出非常具体的用户问题</li></ul></li><li>缺点<ul><li>工作量大，非常费时</li><li>关注面有限<ul><li>只适合于评估一个产品的易学习性</li><li>不太容易发现使用效率方面的可用性问题</li></ul></li></ul></li></ul><h1 id="4-询问专家-启发式评估-👍"><a href="#4-询问专家-启发式评估-👍" class="headerlink" title="4. 询问专家-启发式评估 👍"></a>4. 询问专家-启发式评估 👍</h1><p>Nielsen的<font color="#c00000">十条启发式原则</font>：[[2-交互设计的原则和目标#6.3. 十项启发式交互原则👍]]</p><p>经济评估，一种灵活而又相当廉价的评估方式。</p><h2 id="4-1-步骤"><a href="#4-1-步骤" class="headerlink" title="4.1. 步骤"></a>4.1. 步骤</h2><ol><li>彻底检查界面</li><li>将界面与启发式规则进行对比</li><li>列举可用性问题</li><li>应用启发式规则对每一个问题进行解释与确认</li></ol><h2 id="4-2-问题严重性分类"><a href="#4-2-问题严重性分类" class="headerlink" title="4.2. 问题严重性分类"></a>4.2. 问题严重性分类</h2><ul><li>不同作用因素<ul><li>频率：有多经常？</li><li>影响：有多难克服？</li><li>持续时间：要多长时间克服？</li></ul></li><li>严重性等级<ul><li>表面问题：不需要被修复</li><li>次要问题：需要修复，但优先级较低</li><li>主要问题：需要修复且优先级很高</li><li>灾难性问题：必须被修复</li></ul></li></ul><h2 id="4-3-如何正确评估"><a href="#4-3-如何正确评估" class="headerlink" title="4.3. 如何正确评估"></a>4.3. 如何正确评估</h2><ol><li>分析每个问题对应的启发式规则</li><li>列出所有问题</li><li>至少遍历两遍界面</li><li>不要局限于10条启发式原则</li></ol><h2 id="4-4-优缺点"><a href="#4-4-优缺点" class="headerlink" title="4.4. 优缺点"></a>4.4. 优缺点</h2><ul><li>优点<ul><li>不涉及用户，所以面临的实际限制和道德问题较少</li><li>成本相对较低，不需要特殊设备，而且较为快捷，又被称为“经济评估法”</li></ul></li><li>缺点<ul><li>评估人员需要经过长时间的训练才能成为专家<ul><li>理想的专家应同时具备交互设计和产品应用域的知识</li></ul></li><li>可能出现“虚假警报”<ul><li>“专家每找到一个真实的可用性问题，将发出约一个假警报（1.2），忽略大约半个问题（0.6）”</li></ul></li></ul></li></ul><h2 id="4-5-提醒"><a href="#4-5-提醒" class="headerlink" title="4.5. 提醒"></a>4.5. 提醒</h2><p>邀请多个专家，推荐3-5<br>使用用户测试代替启发式评估<br>观察人员可以帮助评估专家，但对用户测试不合适</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/categories/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/tags/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>6-评估之观察用户</title>
    <link href="http://example.com/posts/907ea608/"/>
    <id>http://example.com/posts/907ea608/</id>
    <published>2023-12-29T06:34:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-观察用户"><a href="#1-观察用户" class="headerlink" title="1. 观察用户"></a>1. 观察用户</h1><ul><li>观察用户怎样工作是极其重要的可用性方法<ul><li>用户并不总是客观和完整地描述产品的使用情况</li><li>用户可能忽略一些细节</li></ul></li><li>观察法是所有可用性方法中最简单的方法<br>观察高度依赖经验</li></ul><h1 id="2-不同时期观察"><a href="#2-不同时期观察" class="headerlink" title="2. 不同时期观察"></a>2. 不同时期观察</h1><p>初期：理解用户需求<br>开发期：原型<br>后期：评价</p><h1 id="3-观察方式"><a href="#3-观察方式" class="headerlink" title="3. 观察方式"></a>3. 观察方式</h1><ul><li><strong>方法</strong>：<ol><li>真实环境中的观察<ol><li>观察者既是旁观者也是参与者</li></ol></li><li>可控环境观察<ol><li>观察者不能作为参与者</li><li>重点是研究用户执行任务的细节</li></ol></li></ol></li></ul><h2 id="3-1-实验室观察"><a href="#3-1-实验室观察" class="headerlink" title="3.1. 实验室观察"></a>3.1. 实验室观察</h2><p>在专门为可用性测试而安装配置的固定设备的环境下进行的观察。</p><ul><li>优点<ol><li>提供可控且一致的评估环境，易于分析</li></ol></li><li>缺点<ol><li>可控且一致的评估环境，人为环境不自然，可能降低结论都普遍性和一致性</li><li>不利于观察多人之间的协作</li></ol></li></ul><h2 id="3-2-实地观察"><a href="#3-2-实地观察" class="headerlink" title="3.2. 实地观察"></a>3.2. 实地观察</h2><ul><li>指在用户的实际环境中观察用户在使用软件时的情况<ul><li>是发现同使用环境有关的问题的最佳手段</li></ul></li></ul><h1 id="4-观察框架"><a href="#4-观察框架" class="headerlink" title="4. 观察框架"></a>4. 观察框架</h1><p>减少干扰、完成目标。<br>观察过程发生的事件都非常复杂且变化迅速，观察框架用于组织观察活动和明确观察重点。</p><h2 id="4-1-Goetz-and-Lecomfte框架"><a href="#4-1-Goetz-and-Lecomfte框架" class="headerlink" title="4.1. Goetz and Lecomfte框架"></a>4.1. Goetz and Lecomfte框架</h2><p>关注事件的上下文、涉及的人员和技术。</p><ul><li>人员：哪些人员在场，有何特征，承担什么角色</li><li>行为：人们说了什么，做了什么，举止如何，是否存在规律性的行为，语调和肢体语言如何</li><li>时间：行为何时发生，是否与其他行为想关联</li><li>地点：行为发生于何处？是否受物理条件的影响？</li><li>原因：行为为何发生？事件或交互的促成因素是什么？不同的人是否有不同的看法？</li><li>方式：行为是如何组织的？受哪些规则或标准的影响？</li></ul><h2 id="4-2-Robson框架"><a href="#4-2-Robson框架" class="headerlink" title="4.2. Robson框架"></a>4.2. Robson框架</h2><p>有助于组织观察和数据搜集活动</p><ul><li>空间：物理空间及其布局如何？</li><li>行为者：涉及哪些人员？人员详情？</li><li>活动：行为者的活动及其原因？</li><li>物体：存在哪些实际物体？</li><li>举止：具体成员的举止如何？</li><li>事件：所观察的是不是特定事件的一部分？</li><li>目标：行为者希望达成什么目标？</li><li>感觉：用户组及个别成员的情绪如何？</li></ul><h1 id="5-难题"><a href="#5-难题" class="headerlink" title="5. 难题"></a>5. 难题</h1><p>观察多久</p><p>降低存在感</p><ul><li>在观察时不知道用户在干什么？（能看到现象，但不知道原因）<ul><li>边做边说</li><li>合作评估：两位用户共同合作，以便他们互相讨论、相互帮助</li></ul></li></ul><h1 id="6-观察和访谈相结合"><a href="#6-观察和访谈相结合" class="headerlink" title="6. 观察和访谈相结合"></a>6. 观察和访谈相结合</h1><p>观察：减少用户被监视的感觉</p><p>访谈：在做了一些任务后再问用户问题</p><p><strong>集体访谈</strong>：一次抓好几个人访谈，<strong>焦点小组</strong>（不同背景的人都有）</p><h1 id="7-数据记录"><a href="#7-数据记录" class="headerlink" title="7. 数据记录"></a>7. 数据记录</h1><p>记录行为，不要带入研究人员主观推测。<br>根据实验环境实际条件选择记录方式。</p><ul><li>类型<ul><li>纸笔</li><li>音视频</li><li>日志和交互记录</li></ul></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/categories/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/tags/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>5-评估之用户测试</title>
    <link href="http://example.com/posts/cbd5957b/"/>
    <id>http://example.com/posts/cbd5957b/</id>
    <published>2023-12-29T03:03:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-DECIDE评估框架👍"><a href="#1-DECIDE评估框架👍" class="headerlink" title="1. DECIDE评估框架👍"></a>1. DECIDE评估框架👍</h1><p><strong>步骤</strong>：</p><ol><li>决定评估需要完成的总体目标</li><li>发掘需要回答的具体问题</li><li>选择用于回答具体问题的评估泛型和技术</li><li>标识必须解决的实际问题，如测试用户的选择</li><li>决定如何处理有关道德的问题</li><li>评估解释并表示数据</li></ol><h2 id="1-1-确定目标"><a href="#1-1-确定目标" class="headerlink" title="1.1. 确定目标"></a>1.1. 确定目标</h2><p>评估目标决定了评估过程，影响评估泛型发选择。</p><h3 id="1-1-1-为什么要评估"><a href="#1-1-1-为什么要评估" class="headerlink" title="1.1.1. 为什么要评估"></a>1.1.1. 为什么要评估</h3><ol><li>产品设计是否理解了用户需要</li><li>为概念设计选择最佳隐喻</li><li>界面是否满足一致性需要</li><li>探讨新产品</li></ol><h2 id="1-2-发掘问题"><a href="#1-2-发掘问题" class="headerlink" title="1.2. 发掘问题"></a>1.2. 发掘问题</h2><ul><li>根据目标确定问题</li><li>问题可以逐层分解</li></ul><h2 id="1-3-选择评估泛型和技术"><a href="#1-3-选择评估泛型和技术" class="headerlink" title="1.3. 选择评估泛型和技术"></a>1.3. 选择评估泛型和技术</h2><ul><li>泛型决定了技术类型</li><li>必须权衡实际问题和道德问题<ul><li>最合适的技术可能成本过高</li><li>或所需时间过长</li><li>或不具备必要设备和技能</li></ul></li><li>可结合使用多种技术<ul><li>不同技术有助于了解设计的不同方面</li><li>不同类型的数据可以从不同角度看待问题</li><li>组合有助于全面了解设计的情况</li></ul></li></ul><h2 id="1-4-明确实际问题"><a href="#1-4-明确实际问题" class="headerlink" title="1.4. 明确实际问题"></a>1.4. 明确实际问题</h2><ul><li>用户<ul><li>应选择恰当的用户参与评估</li><li>能代表产品的目标用户群体<ul><li>可以先做测试，确定用户技能所属的用户群</li></ul></li><li>任务时间多长<ul><li>20分钟休息一次</li></ul></li><li>可在任务执行前，安排用户熟悉系统</li></ul></li><li>设施及设备</li><li>期限及预算是否允许</li><li>是否需要专门的技能</li></ul><h2 id="1-5-处理道德问题"><a href="#1-5-处理道德问题" class="headerlink" title="1.5. 处理道德问题"></a>1.5. 处理道德问题</h2><ul><li><p>应该保护个人隐私</p><ul><li>除非获得批准，否则书面报告不应提及个人姓名，或把姓名与搜集到的数据相联系</li><li>受保护的个人资料包括健康状况、雇佣情况、教育、居所和财务状况等</li><li>可在评估前签署一份协议书（IRB）</li></ul></li><li><p>指导原则-1</p><ul><li>说明研究的目的及要求参与者做的工作</li><li>说明保密事项，对用户&amp;对项目</li><li>测试对象是软件，而非个人</li></ul></li><li><p>指导原则-2 </p><ul><li>对测试过程的特殊要求，是否边做边说等</li><li>用户可自由表达对产品的意见</li><li>说明是否对过程进行录像</li><li>不能拍摄用户的面部</li><li>欢迎用户提问</li><li>用户有随时终止测试的权利</li><li>对用户话语的使用应征得同意，并选择匿名方式</li></ul></li></ul><h2 id="1-6-评估、解释并表示数据"><a href="#1-6-评估、解释并表示数据" class="headerlink" title="1.6. 评估、解释并表示数据"></a>1.6. 评估、解释并表示数据</h2><ul><li>搜集什么类型的数据，如何分析，如何表示</li><li>可靠性<ul><li>非正式访谈的效率低</li><li>给定相同时间，不同时间应用同一技术能否得到相同效果</li></ul></li><li>有效性<ul><li>能否得到想要的测量</li></ul></li><li>偏见<ul><li>评估人员可能有选择地搜集自己认为重要的数据</li></ul></li><li>范围<ul><li>研究发现是否具有普遍性</li></ul></li><li>环境影响<ul><li>霍桑效应</li></ul></li></ul><h1 id="2-小规模实验-Pilot-Study-👍"><a href="#2-小规模实验-Pilot-Study-👍" class="headerlink" title="2. 小规模实验 Pilot Study 👍"></a>2. 小规模实验 Pilot Study 👍</h1><p>在正式实验之前先验证设计是否严谨。</p><ul><li>对评估计划进行小范围测试<ul><li>以确保评估计划的可行性</li><li>如检查设备及使用说明</li><li>练习访谈技巧</li><li>检查问卷中问题是否明确</li></ul></li><li>小规模实验可进行多次<ul><li>类似迭代设计</li><li>测试-反馈-修改-再测</li><li>快速、成本低</li></ul></li></ul><h2 id="2-1-可用性问题分级"><a href="#2-1-可用性问题分级" class="headerlink" title="2.1. 可用性问题分级"></a>2.1. 可用性问题分级</h2><ul><li><strong>评估结果</strong>总是可用性问题清单，以及改进建议。</li><li><strong>方法</strong>：<ol><li>基于<strong>量化数据</strong>的分级<ul><li>如多少人遇到该问题，耗费多少时间等</li></ul></li><li>问题严重性的<strong>主观分级</strong>，取平均值</li><li>可用性分级的两个因素<ol><li>多少用户遇到问题</li><li>用户受该问题影响的程度</li></ol></li><li>该问题只在第一次使用时出现，还是会永远出现<ul><li>如菜单条中的下拉菜单。用户从不尝试下拉用图标表示的菜单，有人告诉他们后，可马上知道如何克服该不一致性问题，因此该问题不属于永久性的可用性问题</li></ul></li></ol></li></ul><p>``</p><h1 id="3-用户测试"><a href="#3-用户测试" class="headerlink" title="3. 用户测试"></a>3. 用户测试</h1><p><strong>隶属于可用性测试，最严格</strong></p><ol><li>在受控环境下测量典型用户执行典型任务的情况</li><li>目的是获得客观的性能数据，从而评价产品或系统的可用性，如易用性、易学性等</li><li>最适合对原型和能够运行的系统进行测试</li></ol><p>设计测试任务<br>不要把任务设计成使用手册</p><h2 id="3-1-测试设计👍"><a href="#3-1-测试设计👍" class="headerlink" title="3.1. 测试设计👍"></a>3.1. 测试设计👍</h2><ul><li>用户测试须考虑实际限制并做出适当的折衷<ul><li>应确保不同参与者的测试条件相同</li><li>应确保评估目标特征具有代表性</li><li>实验可重复，但通常不能得到完全相同的结果</li><li><strong>以DECIDE框架为基础</strong></li></ul></li></ul><ol><li>定义目标和问题<ul><li>目标描述了开展一个测试的原因，定义了测试在整个项目中的价值</li><li>目标是对关注点的说明和解答</li></ul></li><li>选择参与者<ul><li>参与者的选择对于任何实验的成功至关重要</li><li>了解用户的特性有助于选择典型用户<ul><li>要尽可能接近实际用户</li></ul></li><li>通常也需要平衡性别比例</li><li>至少4<del>5位，5</del>12位用户就足够了（视情况而言）</li></ul></li><li>设计测试任务<ul><li>测试任务与定义的目标相关</li></ul></li><li>明确测试步骤</li><li>数据搜集<ul><li>确定如何度量观测的结果</li><li>使用的度量类型（定性/定量）依赖于所选择的任务</li></ul></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F29%2F14-25-55-36c21eb9bf2124345aa76a7a14c032d1-20231229142553-e718c6.png" alt="image.png"></p><h2 id="3-2-分析方法"><a href="#3-2-分析方法" class="headerlink" title="3.2. 分析方法"></a>3.2. 分析方法</h2><ul><li>定量数据<ul><li>最常用的描述性统计方法是次数统计</li><li>次数统计、平均数统计</li></ul></li><li>定性数据<ul><li>按照主题分类</li></ul></li></ul><h2 id="3-3-总结报告"><a href="#3-3-总结报告" class="headerlink" title="3.3. 总结报告"></a>3.3. 总结报告</h2><p>将测试的结果以书面形式反馈给产品的设计人员，以便于他们对设计进一步的分析和改进。</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/categories/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/tags/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>1-概述</title>
    <link href="http://example.com/posts/f5c8b82c/"/>
    <id>http://example.com/posts/f5c8b82c/</id>
    <published>2023-12-29T01:52:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>名词：</p><ul><li>CLI：命令行界面<ul><li>Recall,基于记忆的界面</li></ul></li><li>GUI：图形用户界面<ul><li>Recognition，基于识别的界面</li></ul></li><li><strong>UCD</strong>：User-Centered Design，以用户为中心的设计方法</li><li>Man-Machine Interaction (MMI) / Human-Machine Interaction (HMI)</li><li>Man-Computer Interaction (MCI) / Human-Computer Interaction (HCI)</li><li>Computer-Human Interaction (CHI)</li><li>Human Factors (HF) / Ergonomics</li><li>Usability</li></ul><p>⽤户⼼智模型</p><h2 id="1-1-什么是人机交互"><a href="#1-1-什么是人机交互" class="headerlink" title="1.1. 什么是人机交互"></a>1.1. 什么是人机交互</h2><p><strong>⼈机交互(Human-Computer Interaction):</strong> HCI是⼀⻔与⼈类使⽤的<strong>交互式计算系统</strong>的设计，评估和实施有关的学科， 并且研究了它们周围的主要现象。</p><p>不能够设计用户体验，只能为用户体验而设计。</p><h1 id="2-HCI的重要性"><a href="#2-HCI的重要性" class="headerlink" title="2. HCI的重要性"></a>2. HCI的重要性</h1><ul><li>市场角度<ul><li>用户期望简单易用的系统</li><li>对设计低劣的系统容忍度越来越低</li></ul></li><li>企业角度<ul><li>提高员工的生产效率</li><li>降低产品的生产效率</li><li>降低产品的后续支持成本</li></ul></li><li>用户角度<ul><li>获得较高的主观满意度</li><li>减少事件、金钱、生命损失</li></ul></li></ul><h1 id="3-HCI发展历史"><a href="#3-HCI发展历史" class="headerlink" title="3. HCI发展历史"></a>3. HCI发展历史</h1><p>新的界面变革包含上一代界面 ，旧的交互方式仍然有必要（不是后⾯的阶段出现前⾯的阶段就消失了）</p><h2 id="3-1-批处理阶段"><a href="#3-1-批处理阶段" class="headerlink" title="3.1. 批处理阶段"></a>3.1. 批处理阶段</h2><ul><li>单用户</li><li>机器语言编写<ul><li>纸带</li><li>不符合人的习惯</li><li>耗费时间，又容易出错</li><li>只有少数专业人士才能够运用自如</li></ul></li></ul><h2 id="3-2-联机终端时代"><a href="#3-2-联机终端时代" class="headerlink" title="3.2. 联机终端时代"></a>3.2. 联机终端时代</h2><ul><li><strong>命令行界面</strong><ul><li>类自然语言交互</li><li>一维界面</li><li>回车后不能再对命令内容进行修改</li></ul></li><li>对用户输入要求很严格<ul><li>名称缩写减低用户负担</li></ul></li></ul><h2 id="3-3-GUI时代"><a href="#3-3-GUI时代" class="headerlink" title="3.3. GUI时代"></a>3.3. GUI时代</h2><p>1962，Ivan Sutherland创建Sketchpad</p><p>1964，Douglas Engelbart发明鼠标</p><ul><li><p>WIMP界面</p></li><li><p><strong>GUI的主要特征：直接操作</strong></p></li><li><p>图形用户界面优于字符界面？</p><ul><li>不同的交互方式本身在可用性方面并没有根本性的不同，更重要的是 认真对待界面设计的态度。 [Whiteside 1985]</li></ul></li></ul><h2 id="3-4-多通道⽤户界⾯"><a href="#3-4-多通道⽤户界⾯" class="headerlink" title="3.4. 多通道⽤户界⾯"></a>3.4. 多通道⽤户界⾯</h2><p>具有<strong>并行性</strong>，可同时接收来自多个通道的信息</p><ul><li>下一代界面的主要风格将是没有命令的用户界面<ul><li>由更多的媒体类型来构成更高的信息维度</li><li>交互也将高度便携和个性化</li></ul></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/categories/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_人机交互" scheme="http://example.com/tags/2023-Fall-%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>0-服务端开发</title>
    <link href="http://example.com/posts/19f5250f/"/>
    <id>http://example.com/posts/19f5250f/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1. Spring"></a>1. Spring</h1><ul><li><p>Spring</p><ul><li>Spring的核心是提供一个容器（container）</li><li>管理Bean的生命周期，组装Bean形成一个可用的系统</li><li>Application Context上下文运行环境</li></ul></li><li><p>Bean</p><ul><li>一个object<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F07%2F27a33f228b702e3362eab03541d8c21e_20230907191141.png" alt="image.png"></li></ul></li><li><p>核心技术</p><ul><li>依赖注入</li><li>AOP面向切面的编程</li></ul></li><li><p>持久层</p><ul><li>简化，只需要关注业务</li><li>JDBC、事务管理、ORM工具整合</li></ul></li></ul><h1 id="2-Spring衍生"><a href="#2-Spring衍生" class="headerlink" title="2. Spring衍生"></a>2. Spring衍生</h1><ul><li>Spring：基本框架</li><li>Spring Boot：自动配置，简化Spring开发<ul><li>开发单个微服务（可执行程序）</li></ul></li><li>Spring Cloud：解决分布式系统中特有的问题</li></ul><h2 id="2-1-spring-boot"><a href="#2-1-spring-boot" class="headerlink" title="2.1. spring boot"></a>2.1. spring boot</h2><ol><li>可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs</li><li>内嵌Tomcat或Jetty等<strong>Servlet容器</strong>（Web容器，有很多可运行的web组件）</li><li>提供自动配置的“<strong>starter</strong>”项目对象模型（POMS）以简化Maven配置</li><li>尽可能自动配置<strong>Spring容器</strong></li><li>提供准备好的特性，如指标、健康检查和外部化配置</li><li>绝对没有代码生成，不需要XML配置</li></ol><p>war包小，不能独立运行<br>Jar包大，内嵌tomcat容器，本身可以独立运行</p><h2 id="2-2-常用依赖"><a href="#2-2-常用依赖" class="headerlink" title="2.2. 常用依赖"></a>2.2. 常用依赖</h2><p>devtools：开发时候用于调试<br>web：MVC开发框架<br>thymeleaf：动态组装html页面</p><h1 id="3-👍Spring-Web开发框架的分层"><a href="#3-👍Spring-Web开发框架的分层" class="headerlink" title="3. 👍Spring Web开发框架的分层"></a>3. 👍Spring Web开发框架的分层</h1><ul><li>在服务端一侧的划分：</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F07%2Faa30cd55d3482bfd4228c3f361bba520_20230907204339.png" alt="image.png"></p><h1 id="4-使用JUnit写测试用例"><a href="#4-使用JUnit写测试用例" class="headerlink" title="4. 使用JUnit写测试用例"></a>4. 使用JUnit写测试用例</h1><ul><li><code>@Test</code>注解</li><li><code>void</code>返回值，<code>public</code>可选</li><li>无参数</li></ul><p>-方法命名随意</p><h2 id="4-1-断言"><a href="#4-1-断言" class="headerlink" title="4.1. 断言"></a>4.1. 断言</h2><p>测试代码中对预期结果的断定</p><h1 id="5-Spring模块组成"><a href="#5-Spring模块组成" class="headerlink" title="5. Spring模块组成"></a>5. Spring模块组成</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F14%2F4df50c54d812c48ff73dfeac3b4008cc_20230914185434.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>10-消息中间件(ActiveMQ、RabbitMQ)</title>
    <link href="http://example.com/posts/b48e71af/"/>
    <id>http://example.com/posts/b48e71af/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-消息中间件"><a href="#1-消息中间件" class="headerlink" title="1. 消息中间件"></a>1. 消息中间件</h1><ul><li>提供消息服务的应用程序</li><li>主要用于组件之间的解耦，消息的发送者服务知道消息使用者的存在，反之依然</li></ul><p>消息代理 broker：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F16%2F18-53-01-0b10509f214aed7690a292bddcc3240f-20231116185259-10be9f.png" alt="image.png"></p><h1 id="2-👍JMS"><a href="#2-👍JMS" class="headerlink" title="2. 👍JMS"></a>2. 👍JMS</h1><ul><li>Java Message Service<ul><li>Jms规定了ConnectionFactory、Connection、Session等接口/类</li></ul></li><li>JMS是一个Java标准，使用消息代理（message broker）的统一API</li><li>JmsTemplate：Spring通过基于模板的抽象为JMS功能提供了支持</li></ul><h1 id="3-ActiveMQ-Artemis"><a href="#3-ActiveMQ-Artemis" class="headerlink" title="3. ActiveMQ Artemis"></a>3. ActiveMQ Artemis</h1><ul><li>支持协议<ul><li>JMS</li><li>AMQP: Advanced Message Queueing Protocol</li><li>MQTT: Message Queuing Telemetry Transport</li></ul></li><li>支持Native内存模式和JVM内存模式<ul><li>Native可以绕过JVM，加快访问</li></ul></li><li>消息持久化</li></ul><h2 id="3-1-直接使用JMS接口发送与接受消息"><a href="#3-1-直接使用JMS接口发送与接受消息" class="headerlink" title="3.1. 直接使用JMS接口发送与接受消息"></a>3.1. 直接使用JMS接口发送与接受消息</h2><ol><li>JMS规范：jakarta.jms-api-2.0.3.jar</li><li>atemis客户端：artemis-jms-client-2.17.0.jar<ul><li>与Spring无关</li></ul></li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(BROKER_URL, USERNAME, PASSWORD);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.createConnection();</span><br><span class="line">connection.start();</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="type">Destination</span> <span class="variable">destination</span> <span class="operator">=</span> session.createQueue(<span class="string">"queue.example"</span>);</span><br></pre></td></tr></table></figure></div><h2 id="3-2-👍关键概念"><a href="#3-2-👍关键概念" class="headerlink" title="3.2. 👍关键概念"></a>3.2. 👍关键概念</h2><ul><li>Message：类似广播, 生产端</li><li>Destination：队列或主题。消费端<ul><li>三种指定方式：<ol><li>application.yml（default-destination）</li><li>@Bean（Destination对象）</li><li>直接String指定</li></ol></li></ul></li></ul><h2 id="3-3-JmsTemplate"><a href="#3-3-JmsTemplate" class="headerlink" title="3.3. JmsTemplate"></a>3.3. JmsTemplate</h2><ul><li>JmsTemplate是Spring对JMS集成支持的核心</li><li>发送的两个方法：send、convertAndSend</li></ul><h2 id="3-4-👍消息转换器-MessageConverter"><a href="#3-4-👍消息转换器-MessageConverter" class="headerlink" title="3.4. 👍消息转换器 MessageConverter"></a>3.4. 👍消息转换器 MessageConverter</h2><p>MessageConverter是一个Spring的接口，实现各种<strong>序列化</strong>机制。</p><ul><li>SimpleMessageConverter：实现String与TextMessage的相互转换、字节数组与BytesMessage的相互转换、Map与MapMessage的相互转换，以及Serializable对象与ObjectMessage的相互转换</li><li>MappingJackson2MessageConverter：使用<strong>Jackson 2 JSON</strong>库实现消息与JSON格式的相互转换</li><li>typeId：目的是告诉对方是什么类型，以便于反序列化</li><li>Message.setStringProperty，随属性集传输</li><li>消息转换器使用@Configuration定义成Bean</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F31%2F17-02-28-148a7c245eb17542de98c2c91efe9929-20231231170228-794f8b.png" alt="image.png"></p><h2 id="3-5-接收模式"><a href="#3-5-接收模式" class="headerlink" title="3.5. 接收模式"></a>3.5. 接收模式</h2><p><strong>拉取和推送都需要消息转换器做反序列化。</strong></p><h3 id="3-5-1-拉取模式-pull-model"><a href="#3-5-1-拉取模式-pull-model" class="headerlink" title="3.5.1. 拉取模式 pull model"></a>3.5.1. 拉取模式 pull model</h3><p>JmsTemplate支持<br>访问URL</p><h3 id="3-5-2-推送模式-push-model"><a href="#3-5-2-推送模式-push-model" class="headerlink" title="3.5.2. 推送模式 push model"></a>3.5.2. 推送模式 push model</h3><p>需要定义消息监听器<br>@JmsListener</p><h1 id="4-RabbitMQ"><a href="#4-RabbitMQ" class="headerlink" title="4. RabbitMQ"></a>4. RabbitMQ</h1><p><strong>实现AMQP协议</strong>。<br>RabbitMQ基础概念详细介绍：<a class="link" href="https://www.cnblogs.com/williamjie/p/9481774.html">RabbitMQ基础概念详细介绍 - 割肉机 - 博客园 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>也需要消息转换器，虽然包路径不一样，但是功能一样。</p><h2 id="4-1-👍概念"><a href="#4-1-👍概念" class="headerlink" title="4.1. 👍概念"></a>4.1. 👍概念</h2><ul><li>ConnectionFactory、Connection、Channel</li><li>Exchange：<ul><li>Default、Direct、Topic、Fanout、Headers、Dead letter</li></ul></li><li>Queue</li><li>Routing key：exchange根据routing key确定消息发往哪个队列<ul><li><strong>JMS里没有这个概念</strong></li></ul></li><li>Binding key</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F16%2F20-31-55-d57a847ec3e2d2ed48f59f6b49ec2e0c-20231116203155-0bdbb4.png" alt="image.png"></p><h2 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2. 使用"></a>4.2. 使用</h2><ol><li>添加依赖</li><li>配置文件</li><li>需要到控制台创建exchange，queue，binding</li></ol><div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">exchange:</span> <span class="string">tacocloud.order</span></span><br></pre></td></tr></table></figure></div><p>生产放指定exchange、routing key<br>消费方只需关注队列名字</p><p>也有拉取模式和推送模式，也需要消息的转换</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>11-Spring Inergration</title>
    <link href="http://example.com/posts/b564c0a/"/>
    <id>http://example.com/posts/b564c0a/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<p>做不同系统集成</p><h1 id="1-集成流-Intergration-FLow"><a href="#1-集成流-Intergration-FLow" class="headerlink" title="1. 集成流 Intergration FLow"></a>1. 集成流 Intergration FLow</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-00-32-18ab4ec2735aac2ccea5b42e91078cdf-20231123190031-d3597c.png" alt="image.png"></p><p>gateway：流的入口<br>transformer：<strong>消息</strong>处理、转换</p><p>outbound adapter：用于输出<br>inbound adapter：用于输入</p><h2 id="1-1-Gateway"><a href="#1-1-Gateway" class="headerlink" title="1.1. Gateway"></a>1.1. Gateway</h2><p>只需要定义接口，类似JPA</p><p>定义数据从哪来</p><h2 id="1-2-Transformer"><a href="#1-2-Transformer" class="headerlink" title="1.2. Transformer"></a>1.2. Transformer</h2><p><code>@Transformer</code>注解</p><h2 id="1-3-Adapter"><a href="#1-3-Adapter" class="headerlink" title="1.3. Adapter"></a>1.3. Adapter</h2><p>把message放到另外一个系统里去，如输出文件到文件系统</p><h1 id="2-集成流配置"><a href="#2-集成流配置" class="headerlink" title="2. 集成流配置"></a>2. 集成流配置</h1><ol><li>XML配置</li><li>Java配置</li><li>使用DSL的Java配置</li></ol><p>类似依赖注入</p><h2 id="2-1-XML"><a href="#2-1-XML" class="headerlink" title="2.1. XML"></a>2.1. XML</h2><ol><li>定义一个GateWay接口：获取消息数据</li><li>定义一个集成流xml：定义有哪些Channel、Transformer</li></ol><h2 id="2-2-Java"><a href="#2-2-Java" class="headerlink" title="2.2. Java"></a>2.2. Java</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-37-20-5a24358a2e8ff6ef8db47e3bc36c8989-20231123193719-f55088.png" alt="image.png"></p><h2 id="2-3-DSL"><a href="#2-3-DSL" class="headerlink" title="2.3. DSL"></a>2.3. DSL</h2><p>IntergrationFlow对象</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-40-43-b0218d8cb35748ff7d09c2f2e8d81d41-20231123194042-b1beb5.png" alt="image.png"></p><h1 id="3-👍集成流组件"><a href="#3-👍集成流组件" class="headerlink" title="3. 👍集成流组件"></a>3. 👍集成流组件</h1><ul><li>Channels：消息通道，传递消息</li><li>Filters：过滤器，基于条件判断要不要在流上继续流下去</li><li>Transformers：转换器，消息的内容/类型做转换</li><li>Routers：路由器，决定消息要放到接下来的哪个管道</li><li>Splitters：切分器，把单个消息切分成多个消息</li><li>Aggregators：聚合器，多个消息聚合成一个消息</li><li>Service activators：服务激活器，激活处理消息的方法的调用<ul><li>结束之后可能给下一个通道继续发消息</li></ul></li><li>Channel adapters：适配器，外部系统的边界</li><li>Gateways：网关，构建消息放到集成流上</li></ul><h2 id="3-1-Channels"><a href="#3-1-Channels" class="headerlink" title="3.1. Channels"></a>3.1. Channels</h2><p><strong>DirectChannel：默认</strong><br>PublishSubscribeChannel：1对多，1个发布多个订阅<br>QueueChannel：FIFO<br>PriorityChannel：优先级队列，不按照FIFO出队<br>RendezvousChannel</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-52-20-550033b89ec4a7f0e1abf90cf2d6decf-20231123195220-2e4b63.png" alt="image.png"></p><h2 id="3-2-Filters"><a href="#3-2-Filters" class="headerlink" title="3.2. Filters"></a>3.2. Filters</h2><p>在方法上加<code>@Filter</code>注解，返回<code>boolean</code>决定消息要不要往下走</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-53-49-31d3375a6337ac01c8edbbf4f9089194-20231123195348-52eb90.png" alt="image.png"></p><h2 id="3-3-Transformers"><a href="#3-3-Transformers" class="headerlink" title="3.3. Transformers"></a>3.3. Transformers</h2><p>方法加<code>@Transformer</code>注解<br>通过类型参数指定source type和to type<br>返回转换逻辑</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-55-28-8a87e0604e93c520bf876d1a6a585d58-20231123195527-beae6b.png" alt="image.png"></p><h2 id="3-4-Routers"><a href="#3-4-Routers" class="headerlink" title="3.4. Routers"></a>3.4. Routers</h2><p><code>@Router</code>注解</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-56-06-37f0c1b140d7b9dd709f1b71cc8c2a80-20231123195605-a9b7af.png" alt="image.png"></p><h2 id="3-5-Splitters"><a href="#3-5-Splitters" class="headerlink" title="3.5. Splitters"></a>3.5. Splitters</h2><p>切分消息</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F19-59-15-e9e403edfab61e437342fa71836a8113-20231123195914-c81166.png" alt="image.png"></p><h2 id="3-6-Service-activators"><a href="#3-6-Service-activators" class="headerlink" title="3.6. Service activators"></a>3.6. Service activators</h2><ul><li>MessageHandler<ul><li>处理完流就截止</li></ul></li><li>GenericHandler<ul><li>有返回值</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F20-08-05-a5083f9ec2d27fb4eca0fffa5635e15a-20231123200804-89e408.png" alt="image.png"></p><h2 id="3-7-Gateways"><a href="#3-7-Gateways" class="headerlink" title="3.7. Gateways"></a>3.7. Gateways</h2><p>只需要写一个接口。<br>Gateways 是<strong>应用程序代码和消息系统之间的桥梁</strong>。它们抽象了消息发送和接收的细节，使得应用程序代码可以通过方法调用的方式与消息系统交互，而无需直接使用消息API。这样可以使应用程序代码保持简洁，同时也便于测试。</p><ul><li>单向网关</li><li>双向网关<ul><li>requets channel 输入</li><li>repley channel 获得返回值（Spring会在这个管道上一直等，同步）</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F20-12-01-e1f7a60e7156af19a94a54aaa98aec8c-20231123201200-615caa.png" alt="image.png"></p><h2 id="3-8-Channel-adapters"><a href="#3-8-Channel-adapters" class="headerlink" title="3.8. Channel adapters"></a>3.8. Channel adapters</h2><p>Adapters 则是用于将<strong>消息从一种格式转换为另一种格式</strong>，或者从一种传输协议转换为另一种传输协议。Inbound把外部系统的消息格式转为spring integration消息，outbound把spring integration消息转为外部系统消息。<br>例如，JMS适配器可以将JMS消息转换为Spring Integration通用消息，HTTP适配器可以将HTTP请求和响应转换为Spring Integration消息。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F20-14-53-3423606ae480b57609abc38987c77384-20231123201453-e17b91.png" alt="image.png"></p><h2 id="3-9-Endpoint-modules"><a href="#3-9-Endpoint-modules" class="headerlink" title="3.9. Endpoint modules"></a>3.9. Endpoint modules</h2><p>Spring已经提供了很多中Endpoint<br>AMQP、Filesystems、FTP、Email…</p><h1 id="4-电子邮件集成流"><a href="#4-电子邮件集成流" class="headerlink" title="4. 电子邮件集成流"></a>4. 电子邮件集成流</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F23%2F21-08-14-37a3cf11926c438aa0ff8c40edb1591f-20231123210813-33a283.png" alt="image.png"></p><p>IMAP协议需要授权码</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>12-反应式编程</title>
    <link href="http://example.com/posts/d938b74e/"/>
    <id>http://example.com/posts/d938b74e/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h1><ul><li>IO密集型场景</li><li>同步阻塞模型，阻塞线程多，CPU利用率不高，性能下降</li><li>管理多线程，意味着更高的复杂性</li></ul><h1 id="2-👍Reactor"><a href="#2-👍Reactor" class="headerlink" title="2. 👍Reactor"></a>2. 👍Reactor</h1><ul><li><strong>Reactive Streams</strong>：Netflix、Lightbend和Pirotal于2013年开始制定的<strong>一种规范</strong>，旨在提供无阻塞回压的异步流处理标准<ul><li>和JDK里的Stream不是同一个东西</li></ul></li><li><strong>Reactor</strong>：Spring Pivotal团队提供的响应式编程的Java实现，其它类似实现：RxJava<ul><li>函数式、声明式，描述数据会流经的管道或流</li></ul></li><li><strong>Spring WebFlux</strong>：启用基于响应式编程的Web应用程序的开发。提供类似于Spring MVC的编程模型</li></ul><h1 id="3-👍Java的stream与反应式的流区别"><a href="#3-👍Java的stream与反应式的流区别" class="headerlink" title="3. 👍Java的stream与反应式的流区别"></a>3. 👍Java的stream与反应式的流区别</h1><ol><li><strong>Java的stream通常都是同步的</strong>，并且只能处理有限的数据集，本质上来说，它们只是使用函数来对集合进行迭代的一种方式</li><li>JDK9中的 <strong>Flow API对应反应式流</strong></li></ol><h1 id="4-👍反应式流规范定义的4个接口"><a href="#4-👍反应式流规范定义的4个接口" class="headerlink" title="4. 👍反应式流规范定义的4个接口"></a>4. 👍反应式流规范定义的4个接口</h1><ul><li>org.reactivestreams.*</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F19-07-41-798ed044f2aa4ce418bbeb6519cfa668-20231130190741-06575a.png" alt="image.png"></p><ul><li>Publisher：数据发布者</li><li>Subscriber：数据订阅者</li><li>Processor：处理器</li><li>Subscription：协调</li></ul><p>处理过程是异步的  </p><p><font color="#c00000">消费者驱动，消费者去请求发布者才会发布数据</font></p><h1 id="5-基本概念"><a href="#5-基本概念" class="headerlink" title="5. 基本概念"></a>5. 基本概念</h1><ol><li>Flux：包含 0 到 N 个元素的异步序列</li><li>Mono：包含 0 或者 1 个元素的异步序列</li><li>消息：正常的包含元素的消息、序列结束的消息和序列出错的消息</li><li>操作符（Operator）：对流上元素的操作</li></ol><h1 id="6-反应式流图"><a href="#6-反应式流图" class="headerlink" title="6. 反应式流图"></a>6. 反应式流图</h1><h2 id="6-1-Flux"><a href="#6-1-Flux" class="headerlink" title="6.1. Flux"></a>6.1. Flux</h2><p>Flux：发送0-n个元素的异步序列</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F19-50-28-2478db88115146681d4269a2e67204e8-20231130195028-f96d09.png" alt="image.png"></p><h2 id="6-2-Mono"><a href="#6-2-Mono" class="headerlink" title="6.2. Mono"></a>6.2. Mono</h2><p>Mono：0-1个数据</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F19-50-35-43b84d1bac8df3886bab7388fbc8422d-20231130195034-f55784.png" alt="image.png"></p><h1 id="7-流的操作"><a href="#7-流的操作" class="headerlink" title="7. 流的操作"></a>7. 流的操作</h1><ul><li>类型<ul><li>创建操作</li><li>组合操作</li><li>转换操作 </li><li>逻辑操作</li></ul></li></ul><h2 id="7-1-创建Flux"><a href="#7-1-创建Flux" class="headerlink" title="7.1. 创建Flux"></a>7.1. 创建Flux</h2><ul><li>Flux的静态方法<ul><li><code>just</code>：根据对象创建</li><li><code>fromArray</code>：根据集成创建，数组、Iterable、Java Stream</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-19-30-099704152461e9b25bdbbf87419d26a9-20231130201930-4b546d.png" alt="image.png"></p><h2 id="7-2-组合Flux流"><a href="#7-2-组合Flux流" class="headerlink" title="7.2. 组合Flux流"></a>7.2. 组合Flux流</h2><ul><li>mergeWith</li><li>zip：自己决定如何合并</li><li>first：取两个流里面最先有的数据</li></ul><h2 id="7-3-过滤Flux流"><a href="#7-3-过滤Flux流" class="headerlink" title="7.3. 过滤Flux流"></a>7.3. 过滤Flux流</h2><ul><li>skip：指定个数/时间</li><li>take：指定个数/时间</li><li>filter：需要提供Predicate</li><li>distinct：只发布源Flux中尚未发布过的数据项</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-50-27-9624d81ea1b9b815676419eb53eb71a3-20231130205026-100752.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-50-36-9648126cc6e148b104e4369205f43c63-20231130205035-0bc08f.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-50-08-1dc3601d6deecab36c6e8e25231983b3-20231130205008-b20327.png" alt="image.png"></p><h2 id="7-4-转换Flux流"><a href="#7-4-转换Flux流" class="headerlink" title="7.4. 转换Flux流"></a>7.4. 转换Flux流</h2><h3 id="7-4-1-👍map-flatMap"><a href="#7-4-1-👍map-flatMap" class="headerlink" title="7.4.1. 👍map/flatMap"></a>7.4.1. 👍map/flatMap</h3><ul><li><p>map：</p><ul><li>同步</li><li>返回具体值</li></ul></li><li><p><strong>flatMap</strong>：</p><ul><li>异步</li><li>转换出来的<strong>返回结果还是一个流（Mono/Flux）</strong></li><li>可以并发处理，指定用哪个并发模型处理<ul><li>多个流并发处理结果合并成一个流，但结果顺序不可控</li></ul></li><li>扁平化</li></ul></li><li><p><strong>并发模型（Schedulers方法）</strong></p><ul><li>.immediate()</li><li>.single()</li><li>.newSingle()</li><li>.elastic()</li><li>.parallel()</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F20-49-26-5285b7a6ede0772dea032de105737181-20231130204925-7ab7ac.png" alt="image.png"></p><p><strong>如果map返回流会怎么样</strong>？没有下游订阅者驱动，流是死的(流不被订阅就不会发送任何事情)。</p><h3 id="7-4-2-缓冲"><a href="#7-4-2-缓冲" class="headerlink" title="7.4.2. 缓冲"></a>7.4.2. 缓冲</h3><ul><li>buffer，缓冲数据，bufferAndFlatMap</li><li>collectList，同：buffer不带参数则缓冲所有数据到列表</li><li>collectMap，需要提供生成key的函数</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F21-01-17-a2c87fea5eefda93fbc122c479c890d2-20231130210117-9de6d6.png" alt="image.png"></p><h2 id="7-5-逻辑操作"><a href="#7-5-逻辑操作" class="headerlink" title="7.5. 逻辑操作"></a>7.5. 逻辑操作</h2><ul><li>all<ul><li>要提供Predicate函数</li><li>所有元素满足条件True</li><li><strong>返回</strong><code>Mono&lt;Boolean&gt;</code></li></ul></li><li>any<ul><li>要提供Predicate函数</li><li>有元素满足条件返回True</li><li><strong>返回</strong><code>Mono&lt;Boolean&gt;</code></li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F21-19-03-bb543500e23441c4ac493e1c1cb9e6f4-20231130211902-2aeca5.png" alt="image.png"></p><h1 id="8-不同的消息"><a href="#8-不同的消息" class="headerlink" title="8. 不同的消息"></a>8. 不同的消息</h1><ul><li>反应式编程<ul><li>Java中的一个普通对象，没有消息头和消息体</li><li>只在JVM中流动</li></ul></li><li>spring intergrestion<ul><li>header：消息头</li><li>payload：消息体</li><li>只在JVM中流动</li></ul></li><li>消息队列<ul><li>也有header和payload</li><li>要远程传输，在网络中流动，所以需要消息转换器（序列化/反序列化）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>13-WebFlux</title>
    <link href="http://example.com/posts/bfe92605/"/>
    <id>http://example.com/posts/bfe92605/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-异步Web框架的事件轮询机制"><a href="#1-异步Web框架的事件轮询机制" class="headerlink" title="1. 异步Web框架的事件轮询机制"></a>1. 异步Web框架的事件轮询机制</h1><ul><li>用较少的线程处理更多请求，减少线程管理的开销<ul><li>很多请求的线程并不是在运行，而是在等待</li><li>事件驱动</li></ul></li></ul><p>反应式编程适合<strong>请求多</strong>且<strong>大部分在等待</strong>的情况</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F07%2F18-52-05-3d823dafa4673e8da18904eae9cbd7f0-20231207185204-00c0c0.png" alt="image.png"></p><h1 id="2-Spring-MVC与Spring-WebFlux"><a href="#2-Spring-MVC与Spring-WebFlux" class="headerlink" title="2. Spring MVC与Spring WebFlux"></a>2. Spring MVC与Spring WebFlux</h1><ul><li>不同<ul><li>MVC：依赖多线程处理</li><li>WebFlux：在事件轮询中处理请求<ul><li>可以使用纯粹的函数式编程实现Controller</li></ul></li></ul></li><li>共性<ul><li>WebFlux也可以使用Controller、RequestMapping等注解<ul><li>WebFlux的参数和返回值可能是流</li></ul></li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F07%2F19-00-35-8e48541635a29f83c6e89b87c0f1ee0d-20231207190034-169096.png" alt="image.png"></p><p>依赖：spring-boot-starter-webflux</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><h2 id="3-1-repository"><a href="#3-1-repository" class="headerlink" title="3.1. repository"></a>3.1. repository</h2><ul><li>继承<code>ReactiveCRUDrepository</code>接口</li><li>成员方法返回流</li></ul><h1 id="4-controller"><a href="#4-controller" class="headerlink" title="4. controller"></a>4. controller</h1><ul><li>返回流</li><li>如果方法<strong>没有返回值</strong>，需要在方法内<strong>订阅</strong><ul><li>否则不会执行，不订阅就不会驱动</li><li>多层嵌套流，对外围订阅不会触发内层的流</li></ul></li></ul><p>例子：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value="/mono")</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">stringMono</span><span class="params">()</span> {</span><br><span class="line">    Mono&lt;String&gt; from = Mono.fromSupplier(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">" in Supplier thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, Spring Reactive data time:"</span> + LocalDateTime.now();</span><br><span class="line">    });</span><br><span class="line">    System.out.println(<span class="string">"thread: "</span> + Thread.currentThread().getName() + <span class="string">", time:"</span> + LocalDateTime.now());</span><br><span class="line">    <span class="keyword">return</span> from;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Spring Reactive data time:2024-01-02T20:40:46.651302900</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value="/flux", produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">produceFlux</span><span class="params">()</span>{</span><br><span class="line">    Flux&lt;String&gt; stringFlux = Flux.fromStream(IntStream.range(<span class="number">1</span>,<span class="number">6</span>).mapToObj(i-&gt;{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">" in Supplier thread: "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"java north flux："</span>+i+<span class="string">", date time: "</span>+LocalDateTime.now();</span><br><span class="line">    }));</span><br><span class="line">    System.out.println(<span class="string">"thread: "</span> + Thread.currentThread().getName() + <span class="string">", time:"</span> + LocalDateTime.now());</span><br><span class="line">    <span class="keyword">return</span> stringFlux;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F02%2F20-47-01-c9692a4a5af3f51e8de2b1c113c85c6c-20240102204701-f3eb3e.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F01%2F02%2F20-47-19-a2f875c2613b77f4a8fe127cfb4a0331-20240102204719-e660d9.png" alt="image.png"></p><h2 id="4-1-使用函数式范式定义控制器"><a href="#4-1-使用函数式范式定义控制器" class="headerlink" title="4.1. 使用函数式范式定义控制器"></a>4.1. 使用函数式范式定义控制器</h2><ul><li>基本组件<ul><li>HandlerFunction：</li><li>RouterFunction：路由和处理关系</li></ul></li></ul><p>WebClient：相当于RestTemplate</p><h1 id="5-R2DBC"><a href="#5-R2DBC" class="headerlink" title="5. R2DBC"></a>5. R2DBC</h1><p>反应式关系型数据库链接<br>JDBC的替代方案</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>15-容器镜像构建和编排</title>
    <link href="http://example.com/posts/70e6ad8c/"/>
    <id>http://example.com/posts/70e6ad8c/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-由Dockerfile构建镜像"><a href="#1-由Dockerfile构建镜像" class="headerlink" title="1. 由Dockerfile构建镜像"></a>1. 由Dockerfile构建镜像</h1><h2 id="1-1-过程"><a href="#1-1-过程" class="headerlink" title="1.1. 过程"></a>1.1. 过程</h2><p>Image：静态的压缩包<br>Container：运行的容器，轻量级的虚拟机</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F21%2F18-48-00-e370271f15d63a6c253c9948ac97824b-20231221184759-c0bcd1.png" alt="image.png"></p><h2 id="1-2-👍文件指令"><a href="#1-2-👍文件指令" class="headerlink" title="1.2. 👍文件指令"></a>1.2. 👍文件指令</h2><ul><li>FROM：<strong>指定基础镜像，必须为第一个命令</strong></li><li>RUN：构建镜像时执行的命令</li><li><font color="#c00000">ADD</font>：将本地文件添加到容器中，<strong>tar类型文件会自动解压</strong></li><li><font color="#c00000">COPY</font>：功能类似ADD，但是<strong>不会自动解压文件</strong></li><li><strong>CMD</strong>：<strong>构建容器后调用，也就是在容器启动时才进行调用</strong><ul><li>可以被docker run参数覆盖</li></ul></li><li>ENTRYPOINT：配置容器，使其可执行化<ul><li>配合CMD可省去“application”，只使用参数，用于docker run时根据不同参数执行不同功能</li><li>很可能是shell脚本</li></ul></li><li>LABEL：用于为镜像添加元数据<ul><li>key-value</li></ul></li><li>ENV：设置环境变量</li><li>EXPOSE：指定与外界交互的端口，容器内的端口号，docker run时加-P则会映射一个随机号（宿主机）</li><li>VOLUME：用于指定持久化目录，docker run时如果没有指定挂载目录，会创建一个volume</li><li>WORKDIR：工作目录，类似于cd命令</li><li>USER：指定运行容器时的用户名或 UID<ul><li>默认root</li></ul></li><li>ARG：用于指定传递给构建运行时的变量</li><li>ONBUILD：用于设置镜像触发器<ul><li>可以被其他人进一步构建，会触发一些行为</li></ul></li></ul><h1 id="2-Docker-build"><a href="#2-Docker-build" class="headerlink" title="2. Docker build"></a>2. Docker build</h1><h2 id="2-1-构建命令"><a href="#2-1-构建命令" class="headerlink" title="2.1. 构建命令"></a>2.1. 构建命令</h2><ul><li><p>docker build [OPTIONS] PATH | URL | -</p></li><li><p>生成镜像：<code>docker build -t  &lt;image&gt;:&lt;tag&gt; .</code></p><ul><li>最后一个参数context: .</li></ul></li></ul><h2 id="2-2-👍最佳实践"><a href="#2-2-👍最佳实践" class="headerlink" title="2.2. 👍最佳实践"></a>2.2. 👍最佳实践</h2><ul><li><p>如何编写dockerfile: <a class="link" href="https://zhuanlan.zhihu.com/p/26904830">如何编写最佳的Dockerfile - 知乎 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ol><li><code>.dockerignore</code>文件</li><li>容器只运行<strong>单个应用</strong><ul><li>解耦，未来可以单独对一个应用进行升级/重启/…</li></ul></li><li>将多个RUN指令合并为一个<ul><li>原因：减少镜像分层</li></ul></li><li>基础镜像的标签不要用latest<ul><li>建议使用固定的版本，使得镜像可预知</li></ul></li><li>每个RUN指令的最后删除多余文件<ul><li>原因：否则，虽然在下一个RUN删掉，上一层的文件还在（写时复制，上一层不可修改）</li></ul></li><li>选择合适的基础镜像(alpine版本最好)<ul><li>轻量级</li></ul></li><li>设置WORKDIR和 CMD</li><li>合理安排COPY和RUN的顺序<ul><li>把不容易改变的放在前面，充分利用缓存</li></ul></li></ol></li><li><p>Docker健康检查HEALTHCHECK的使用方法：<a class="link" href="https://zhuanlan.zhihu.com/p/386986915">Docker健康检查HEALTHCHECK的使用方法 - 知乎 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ul><h2 id="2-3-镜像分层"><a href="#2-3-镜像分层" class="headerlink" title="2.3. 镜像分层"></a>2.3. 镜像分层</h2><p>Dockerfile里每一条命令都会生成一个新的层，重复构建时有cache, 只从修改的层开始重新构建.</p><ul><li><p>写时复制 COW</p></li><li><p>docker history 查看镜像的层</p></li><li><p>将所有的RUN指令合并为一个</p><ul><li>Dockerfile中的每个指令都会创建一个新的镜像层</li><li>镜像层将被缓存和复用</li><li>当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效</li><li>某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效</li><li>镜像层是不可变的，如果我们在某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在Docker容器中不可见了)</li></ul></li></ul><h2 id="2-4-YAML文件语法"><a href="#2-4-YAML文件语法" class="headerlink" title="2.4. YAML文件语法"></a>2.4. YAML文件语法</h2><h1 id="3-Docker-compose"><a href="#3-Docker-compose" class="headerlink" title="3. Docker compose"></a>3. Docker compose</h1><p>服务编排工具</p><ul><li>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排<br> 一个单独的 docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</li><li>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理</li><li>Compose 中有两个重要的概念<ul><li>服务 (service)：一个应用的容器（可能会有多个容器），实际上可以包括若干运行相同镜像的容器实例</li><li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml文件中定义</li></ul></li><li>使用微服务架构的系统一般包含若干个微服务，每个微服务一般部署多个实例。如果每个服务都要手动启停，那么效率低，维护量大</li></ul><h2 id="3-1-docker-compose-yml格式"><a href="#3-1-docker-compose-yml格式" class="headerlink" title="3.1. docker-compose.yml格式"></a>3.1. docker-compose.yml格式</h2><p><a class="link" href="https://blog.csdn.net/weixin_46545831/article/details/112995427">Docker-compose指令详解_docker-compose指定container名字-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" href="https://zhuanlan.zhihu.com/p/93459395">Docker三剑客之docker-compose - 知乎 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="3-2-YAML文件"><a href="#3-2-YAML文件" class="headerlink" title="3.2. YAML文件"></a>3.2. YAML文件</h2><p>指定容器名之后只能部署一个，默认情况下为服务名+编号</p><h2 id="3-3-ports、expose、links、depends-on"><a href="#3-3-ports、expose、links、depends-on" class="headerlink" title="3.3. ports、expose、links、depends_on"></a>3.3. ports、expose、links、depends_on</h2><p><a class="link" href="https://zhuanlan.zhihu.com/p/382779508">docker-compose的ports、expose、links、depends_on的使用技巧 - 知乎 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>ports<ul><li>用来把服务端口映射给宿主机</li></ul></li><li>expose<ul><li>用来把服务端口开放给其他服务，客户端服务可以通过links功能访问服务端服务的端口</li></ul></li><li>links<ul><li>links的目的是把一个服务的名称在当前服务里面创建一个别名</li></ul></li><li><strong>depends_on</strong><ul><li>当前服务启动之前先要把depends_on指定的服务启动起来才行</li></ul></li></ul><h2 id="3-4-👍docker-compose常用命令"><a href="#3-4-👍docker-compose常用命令" class="headerlink" title="3.4. 👍docker-compose常用命令"></a>3.4. 👍docker-compose常用命令</h2><ul><li>docker-compose ps<ul><li>和当前compose的yaml文件相关的正在运行的容器</li></ul></li><li>docker-compose images</li><li><strong>docker-compose up</strong><ul><li>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作</li></ul></li><li><strong>docker-compose stop</strong> <ul><li>终止整个服务集合</li></ul></li><li>docker-compose stop [service]<ul><li>终止指定的服务 （这有个点就是启动的时候会先启动 depond_on中的容器，关闭 的时候不会影响到 depond_on中的）</li></ul></li><li><strong>docker-compose logs</strong> -f [services…] <ul><li>查看容器的输出日志</li></ul></li><li>docker-compose build [SERVICE…] </li><li>docker-compose rm nginx <ul><li>移除指定的容器</li></ul></li><li>docker-compose up -d –scale flask=3 organizationservice=2 <ul><li>设置指定服务运行的容器个数</li><li>scale：横向伸缩</li></ul></li></ul><h2 id="3-5-为什么要docker-compose"><a href="#3-5-为什么要docker-compose" class="headerlink" title="3.5. 为什么要docker-compose"></a>3.5. 为什么要docker-compose</h2><p>可以方便地在本地调试微服务</p><h2 id="3-6-如何配置日志驱动Docker-Logging"><a href="#3-6-如何配置日志驱动Docker-Logging" class="headerlink" title="3.6. 如何配置日志驱动Docker Logging"></a>3.6. 如何配置日志驱动Docker Logging</h2><ul><li>Logging 驱动是可以插拔的框架</li><li>Logging 驱动是 Container 用来使用服务来访问 log data 的工具</li><li>Docker 支持很多种类的 Logging Driver</li><li>默认驱动（log-driver）: “json-file”，存放到主机目录：/var/lib/docker/containers/[容器ID]-json.log</li><li>单个容器的日志配置<ul><li>docker run –log-driver syslog nginx</li><li>docker run –log-driver json-file –log-opt max-size=50m nginx</li></ul></li><li>更多驱动：fluentd、splunk、awslogs</li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>16-k8s使用</title>
    <link href="http://example.com/posts/9aa54120/"/>
    <id>http://example.com/posts/9aa54120/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-k8s环境"><a href="#1-k8s环境" class="headerlink" title="1. k8s环境"></a>1. k8s环境</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1. 安装"></a>1.1. 安装</h2><p><a class="link" href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">GitHub - AliyunContainerService/k8s-for-docker-desktop: 为Docker Desktop for Mac/Windows开启Kubernetes和Istio。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>根据说明安装</p><h2 id="1-2-部署dashboard"><a href="#1-2-部署dashboard" class="headerlink" title="1.2. 部署dashboard"></a>1.2. 部署dashboard</h2><p><code>kubectl apply -f kubernetes-dashboard.yaml</code></p><p>kubectl： 客户端程序与远程k8s server交互<br>kubectl proxy： 把远程k8s server端口代理到本地端口</p><h2 id="1-3-部署ingress-controller"><a href="#1-3-部署ingress-controller" class="headerlink" title="1.3. 部署ingress controller"></a>1.3. 部署ingress controller</h2><p><code>kubectl apply -f ingress-nginx-controller.yaml</code></p><h2 id="1-4-验证-Kubernetes-集群状态"><a href="#1-4-验证-Kubernetes-集群状态" class="headerlink" title="1.4. 验证 Kubernetes 集群状态"></a>1.4. 验证 Kubernetes 集群状态</h2><ul><li>kubectl cluster-info</li><li>kubectl get nodes</li><li>kubectl get nodes –show-labels</li><li>给节点打标签：kubectl label node docker-desktop disktype=ssd<ul><li>查询满足标签的节点：kubectl get nodes -l disktype=ssd</li><li>删除标签：kubectl label node docker-desktop disktype</li></ul></li></ul><h1 id="2-k8s基本架构"><a href="#2-k8s基本架构" class="headerlink" title="2. k8s基本架构"></a>2. k8s基本架构</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F28%2F18-55-11-2838e48395432e6ee0c51d6f1cbf08d5-20231228185510-36573e.png" alt="image.png"></p><p>Node: 安装docker的宿主机，提供容器。<br>Master：管理集群的机器，安装k8s的核心模块。也可以与Node部署在同一台宿主机上。</p><p>kubelet：和Master、本地docker交互。<br>flannel：容器网络的第三方实现，给容器提供虚拟网络。<br>etcd：类似reddis的缓存系统。</p><p>k8s目的：通过多个Node节点，获得更多容器。</p><h1 id="3-👍k8s资源"><a href="#3-👍k8s资源" class="headerlink" title="3. 👍k8s资源"></a>3. 👍k8s资源</h1><h2 id="3-1-类型"><a href="#3-1-类型" class="headerlink" title="3.1. 类型"></a>3.1. 类型</h2><ul><li>namespaces<ul><li>类似java中的package</li><li>可以把不同资源放在不同namespace里，不同namespace里面可以有同名资源</li></ul></li><li>ReplicaSet<ul><li>维持Pod实例数</li></ul></li><li>Pods<ul><li>以包含一个或多个容器，内部容器的逻辑宿主机</li><li><font color="#c00000">k8s里管理的最小资源</font></li></ul></li><li>Deployment<ul><li>负责Pod的自动创建</li></ul></li><li>Service<ul><li>类似微服务的“服务”概念，为外界提供一定的业务能力</li><li>部署在Pod中，一个服务可以有多个Pod</li></ul></li><li>Ingress<ul><li>网关，把不同域名/url路由到对应的服务</li><li>k8s对外统一提供Ingress的入口</li></ul></li><li>configmap<ul><li>集群中提供配置信息的地方</li><li>key-value结构</li></ul></li><li>secrets<ul><li>涉及安全的隐私数据，有不同类别</li></ul></li><li>serviceaccounts<ul><li>给容器里的软件用的账户，容器和k8s server交互时用到</li></ul></li><li>DaemonSet<ul><li>常驻在Node上</li><li>例：fluentd，常驻的Node上收集日志</li></ul></li></ul><h2 id="3-2-Pod"><a href="#3-2-Pod" class="headerlink" title="3.2. Pod"></a>3.2. Pod</h2><ul><li><p><font color="#c00000">Pod是Kubernetes调度的最小单元</font> 👍</p></li><li><p>多个容器在一个Pod中共享网络和文件系统</p><ul><li>PID命名空间：Pod中不同的应用程序可以看到其他应用程序的进程ID</li><li>network命名空间：Pod中多个容器处于<strong>同一个网络命名空间</strong>，因此能够访问的IP和端口范围都是相同的。也可以通过localhost相互访问</li><li>IPC命名空间：Pod中的<strong>多个容器</strong>共享Inner-process Communication命名空间，因此可以通过SystemVIPC或POSIX进行<strong>进程间通信</strong></li><li>UTS命名空间：Pod中的多个容器共享同一个主机名</li><li>Volumes：Pod中各个容器可以共享在Pod中定义分存储卷（Volume）</li></ul></li><li><p>restartPolicy字段</p><ul><li>Always：只要退出就重启</li><li>OnFailure：失败退出时（exit code不为0）才重启<ul><li>也可能是正常的退出</li></ul></li><li>Never：永远不重启</li></ul></li></ul><h3 id="3-2-1-pod管理命令"><a href="#3-2-1-pod管理命令" class="headerlink" title="3.2.1. pod管理命令"></a>3.2.1. pod管理命令</h3><ul><li><strong>创建pod</strong><ul><li><code>kubectl run</code></li><li><code>kubectl run myspittr --image spittr:1.0-SNAPSHOT</code></li><li>类似docker run</li></ul></li><li><strong>查看pod</strong><ul><li><code>kubectl get pods</code></li><li><code>kubectl logs -f myspittr</code></li></ul></li><li>在pod中<strong>执行命令</strong><ul><li><code>kubectl exec</code></li><li><code>kubectl exec myspittr -- ls /run/secrets/kubernetes.io/serviceaccount</code>，在myspittr中执行<code>--</code>后的命令</li></ul></li><li><strong>删除pod</strong><ul><li><code>kubectl delete pod &lt;pod name&gt;</code></li></ul></li></ul><h3 id="3-2-2-如何将pod或service的端口快速映射到本机端口（调试用）"><a href="#3-2-2-如何将pod或service的端口快速映射到本机端口（调试用）" class="headerlink" title="3.2.2. 如何将pod或service的端口快速映射到本机端口（调试用）"></a>3.2.2. 如何将pod或service的端口快速映射到本机端口（调试用）</h3><ul><li><p><strong>port-forward</strong>: ``kubectl port-forward <name> host_ip:container_ip`</name></p><ul><li>和<code>docker -p</code>一样，左边宿主机右边容器端口</li><li>可以直接映射pod，但更<strong>推荐映射service</strong></li></ul></li><li><p>映射pod：<code>kubectl port-forward pod/myspittr 8081:8080</code></p><ul><li>访问：<a class="link" href="http://localhost:8081/spittr/">http://localhost:8081/spittr/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul></li><li><p>映射service：<code>kubectl port-forward service/demo 8081:80</code></p></li></ul><h3 id="3-2-3-Pod、Container与Node之间的关系"><a href="#3-2-3-Pod、Container与Node之间的关系" class="headerlink" title="3.2.3. Pod、Container与Node之间的关系"></a>3.2.3. Pod、Container与Node之间的关系</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F28%2F19-32-11-f9c84bf9f2d585a4e92d0a7a6a7fe85d-20231228193210-1d543b.png" alt="image.png"></p><h2 id="3-3-👍-Service"><a href="#3-3-👍-Service" class="headerlink" title="3.3.👍 Service"></a>3.3.👍 Service</h2><p>不希望让别人直接访问pod，k8s可能会对pod做更改，ip会改变。但<strong>cluster-ip或服务名不会改变</strong>。</p><h3 id="3-3-1-命令"><a href="#3-3-1-命令" class="headerlink" title="3.3.1. 命令"></a>3.3.1. 命令</h3><ul><li><p>创建：kubectl expose</p><ul><li><code>kubectl expose pod &lt;serveice name&gt; --port &lt;port&gt;</code></li></ul></li><li><p>查看</p><ul><li>kubectl svc</li></ul></li></ul><h3 id="3-3-2-如何访问Service"><a href="#3-3-2-如何访问Service" class="headerlink" title="3.3.2. 如何访问Service"></a>3.3.2. 如何访问Service</h3><ol><li>expose</li><li>port-forward</li><li>curl容器</li></ol><h2 id="3-4-👍Ingress"><a href="#3-4-👍Ingress" class="headerlink" title="3.4. 👍Ingress"></a>3.4. 👍Ingress</h2><ul><li><font color="#c00000">只能路由到service，不能路由到pod</font><ul><li>service有cluseter-ip，不会改变，而pod的ip可能会改变</li></ul></li></ul><h3 id="3-4-1-命令"><a href="#3-4-1-命令" class="headerlink" title="3.4.1. 命令"></a>3.4.1. 命令</h3><ul><li>创建：kubectl create ingress myspittr –class=nginx –rule=<a class="link" href="http://www.license.com/*=myspittr:8080">www.license.com/*=myspittr:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><ul><li>访问：<a class="link" href="http://www.license.com/spittr/">http://www.license.com/spittr/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul></li><li>删除：kubectl delete ingress myspittr</li></ul><p>ingress网关默认端口80</p><h2 id="3-5-命令行快捷创建deployment、service、ingress"><a href="#3-5-命令行快捷创建deployment、service、ingress" class="headerlink" title="3.5. 命令行快捷创建deployment、service、ingress"></a>3.5. 命令行快捷创建deployment、service、ingress</h2><ul><li><p>kubectl create deployment myspittr–image=spittr:1.0-SNAPSHOT –port=8080</p></li><li><p>kubectl expose deployment myspittr 把上面的这个pod的8080端口暴露为myspittr服务</p></li><li><p>kubectl create ingress myspittr–class=nginx–rule=<a class="link" href="http://www.license.com/*=myspittr:8080">www.license.com/*=myspittr:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>访问：<a class="link" href="http://www.license.com/spittr/">http://www.license.com/spittr/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>删除：</p><ul><li>kubectl delete ingress myspittr</li><li>kubectl delete service myspittr</li><li>kubectl delete deployment myspittr</li></ul></li></ul><h2 id="3-6-Deployment"><a href="#3-6-Deployment" class="headerlink" title="3.6. Deployment"></a>3.6. Deployment</h2><p><a class="link" href="https://www.jianshu.com/p/029661f38674">Kubernetes对象之Deployment - 简书 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>重启：kubectl rollout restart deployment/spittr<ul><li>kubectl rollout restart deployment –selector=app=spittr</li></ul></li><li><strong>更新镜像重部署</strong>：kubectl set image deployment/spittr spittr=spittr:1.0</li><li>扩容：kubectl scale deployment spittr –replicas 2</li><li><strong>自动伸缩</strong>：kubectl autoscale deployment spittr –min=10 –max=15 –cpu-percent=80 👍<ul><li>k8s可以依据CPU使用率动态决定实例数量的选择</li><li><font color="#c00000">记得删除</font>： kubectl delete horizontalpodautoscalers.autoscaling spittr</li></ul></li><li>查看历史版本：kubectl rollout history deployment/spittr</li><li>回滚到前一个版本：kubectl rollout undo deployment/spittr</li></ul><h1 id="4-k8s常用命令"><a href="#4-k8s常用命令" class="headerlink" title="4. k8s常用命令"></a>4. k8s常用命令</h1><ul><li>kubectl get secrets/pods/all [ -n namespace]</li><li>kubectl get secret mysecret-o yaml</li><li>kubectl delete pod pod_name [ -n namespace]</li><li>kubectl apply -f [json文件或yaml文件-路径]</li><li>kubectl delete -f [json文件或yaml文件-路径]</li><li>kubectl describe secret mysecret</li><li>kubectl logs secret1-pod</li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2-面向切面编程</title>
    <link href="http://example.com/posts/e2853af6/"/>
    <id>http://example.com/posts/e2853af6/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-软件编程方法"><a href="#1-软件编程方法" class="headerlink" title="1. 软件编程方法"></a>1. 软件编程方法</h1><ul><li>面向过程编程 POP</li><li>面向对象编程 OOP</li><li>面向切面编程 AOP</li><li>函数式编程 FP</li><li>反应式编程 RP</li></ul><h1 id="2-AOP-Aspect-Oriented-Programming"><a href="#2-AOP-Aspect-Oriented-Programming" class="headerlink" title="2. AOP: Aspect Oriented Programming"></a>2. AOP: Aspect Oriented Programming</h1><h2 id="2-1-👍横切关注点"><a href="#2-1-👍横切关注点" class="headerlink" title="2.1. 👍横切关注点"></a>2.1. 👍横切关注点</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F21%2F593c95764eb4ced35052b11e904cb58c_20230921200636.png" alt="image.png"></p><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1. 定义"></a>2.1.1. 定义</h3><ul><li>横切关注点：公共性的功能，但需要嵌入到业务代码的许多地方<ul><li>Cross-cutting concern</li><li>例：来了一个请求，需要权限认证。权限认证与业务逻辑无关，且许多地方要用到。</li></ul></li></ul><p>Spring会帮开发者嵌入横切关注点</p><h3 id="2-1-2-类型"><a href="#2-1-2-类型" class="headerlink" title="2.1.2. 类型"></a>2.1.2. 类型</h3><ol><li>日志</li><li>安全</li><li>事务</li><li>缓存</li></ol><h2 id="2-2-AOP的可选方案"><a href="#2-2-AOP的可选方案" class="headerlink" title="2.2. AOP的可选方案"></a>2.2. AOP的可选方案</h2><p>以日志为例</p><ul><li>继承<ul><li>让业务类继承日志类</li><li>缺点：感知到日志代码存在，强耦合，对业务代码造成了侵入</li></ul></li><li>委托<ul><li>委托日志对象的引用来调用日志方法</li><li>缺点：需要知道日志模块的存在，侵入业务代码</li></ul></li></ul><h1 id="3-👍AOP术语"><a href="#3-👍AOP术语" class="headerlink" title="3. 👍AOP术语"></a>3. 👍AOP术语</h1><ol><li><strong>通知 Advice</strong>：切面要做什么以及何时做<ul><li>时间：方法前/后…</li></ul></li><li><strong>切点 Pointcut</strong>：指定在何处切<ul><li>Spring只支持在<font color="#ff0000">方法</font>的前后切</li><li>写<strong>切点表达式</strong>指定逻辑</li></ul></li><li><strong>切面 Aspect</strong>：Advice和Pointcut的结合<ul><li>包含切的所有逻辑</li></ul></li><li><strong>连接点 Join point</strong>：方法、字段修改、构造方法</li><li><strong>引入 introduction</strong>：引入新的行为和状态<ul><li>给对象加入新的方法/状态，但不需要实现新的子类。在原来的对象上动态加入新的方法/状态。</li></ul></li><li><strong>织入 Weaving</strong>：切面应用到目标对象的过程</li></ol><h2 id="3-1-通知-Advice"><a href="#3-1-通知-Advice" class="headerlink" title="3.1. 通知 Advice"></a>3.1. 通知 Advice</h2><p><strong>在aspect类的方法上注解</strong></p><ul><li>@Before</li><li>@After：不区分是否正常结束</li><li>@AfterReturning</li><li>@AfterThrowing</li><li>@Around：结合前面所有类型</li></ul><p>被切方法成功运行之后会执行：After、AfterReturning、Around</p><h2 id="3-2-切点-Pointcut"><a href="#3-2-切点-Pointcut" class="headerlink" title="3.2. 切点 Pointcut"></a>3.2. 切点 Pointcut</h2><ul><li><code>@Pointcut</code>，空方法</li><li>可以在不同的Advice的切点表达式中直接重用<ul><li>消除重复</li><li><strong>不是方法调用</strong></li></ul></li><li>相当于<strong>对比较复杂的切点表达式进行封装</strong>，简单的就可以直接写在Advice里<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F21%2Fe5eb3eb6b02f362f0bdf531c29a71c55_20230921201543.png" alt="image.png"></li></ul><h2 id="3-3-👍切面-Aspect"><a href="#3-3-👍切面-Aspect" class="headerlink" title="3.3. 👍切面 Aspect"></a>3.3. 👍切面 Aspect</h2><ul><li>java类上加<code>@Aspect</code>注解，是一个单独的类<ul><li>@Aspect // 并不具有 @Component 的效果，不能在扫描时实例化，因此需要添加 @Component 注解或在 JavaConfig 类中主动实例化</li></ul></li><li>包含切的时间、切点和逻辑</li><li>定义可重用的切点</li></ul><p>==不需要修改业务代码==</p><h3 id="3-3-1-创建步骤"><a href="#3-3-1-创建步骤" class="headerlink" title="3.3.1. 创建步骤"></a>3.3.1. 创建步骤</h3><ol><li>实现一个java类，在类上加<code>@Aspect</code>注解，定义逻辑和行为。用<code>@Before</code>等注解定义Advice和<strong>切点表达式</strong>。</li><li>在配置类增加注解<code>@EnableAspectJProxy</code><ul><li>启用AspectJ代理</li></ul></li><li>实例化：在配置类中实例化切面类对应的Bean，或者使用<code>@Component</code></li></ol><h3 id="3-3-2-👍切点表达式-切点指示器"><a href="#3-3-2-👍切点表达式-切点指示器" class="headerlink" title="3.3.2. 👍切点表达式/切点指示器"></a>3.3.2. 👍切点表达式/切点指示器</h3><ol><li>借助<code>AspectJ</code>切点指示器的语法</li><li>在方法上加<code>@Before(&lt;expression&gt;)</code>、<code>@Pointercut(&lt;expression)</code></li></ol><ul><li>可以实现👍<ol><li>指定在哪些方法上切入</li><li>获取参数</li><li>限定包路径</li><li>限定bean名称，白名单或黑名单</li><li>限定在特定注解上切入</li></ol></li></ul><h4 id="3-3-2-1-Pointcut"><a href="#3-3-2-1-Pointcut" class="headerlink" title="3.3.2.1. `Pointcut"></a>3.3.2.1. `Pointcut</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(</span></span><br><span class="line"><span class="meta">"execution(* soundsystem.CompactDisc.playTrack( int )) " + </span></span><br><span class="line"><span class="meta">"&amp;&amp; args(trackNumber)")</span> <span class="comment">//获取参数</span></span><br><span class="line">&amp;&amp; within(soundsystem.*)<span class="comment">//限定包路径</span></span><br><span class="line">&amp;&amp; bean(sgtPeppers)<span class="comment">//限定bean名称，或者： &amp;&amp; !bean(sgtPeppers)</span></span><br></pre></td></tr></table></figure></div><ol><li>指定方法<code>execution</code></li><li>可以指定包/路径<code>within</code></li><li>可以带参数<code>args</code></li><li>限定在哪些Bean上植入（可以取反）<code>bean</code></li></ol><h4 id="3-3-2-2-Around"><a href="#3-3-2-2-Around" class="headerlink" title="3.3.2.2. Around"></a>3.3.2.2. <code>Around</code></h4><ol><li><code>@annotation</code>关键字指定<strong>在特定注解上植入</strong><ul><li>注解可以自己定义，和Spring无关</li></ul></li></ol><ul><li><code>Around</code><ul><li>需要一个<strong>ProceedingJoinPoint方法参数</strong></li><li>对ProceedingJoinPoint方法的调用实际上就是对切点的调用</li></ul></li></ul><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around("@annotation(innerAuth)")</span> <span class="comment">//</span></span><br><span class="line">限定注解</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">innerAround</span><span class="params">(ProceedingJoinPoint point, InnerAuth innerAuth)</span> { ... }</span><br><span class="line"></span><br><span class="line"><span class="meta">@InnerAuth</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Boolean&gt; <span class="title function_">register</span><span class="params">(<span class="meta">@RequestBody</span> SysUser sysUser)</span>{...}</span><br></pre></td></tr></table></figure></div><ul><li>Around优势<ul><li>可以自由控制是否调用/调用次数</li><li>可以有返回值，灵活性更高</li></ul></li></ul><h3 id="3-3-3-实现原理"><a href="#3-3-3-实现原理" class="headerlink" title="3.3.3. 实现原理"></a>3.3.3. 实现原理</h3><ul><li>切与不切通过<code>getBean</code>获得的对象类型并不一样。</li><li>通过创建<strong>代理</strong>实现<ul><li>JDK本身就具备代理能力</li><li>针对该对象的调用都会转到代理对象</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F21%2F0e23d5f342f4383c7a76122ca75ea479_20230921200101.png" alt="image.png"></p><h2 id="3-4-织入-Weaving"><a href="#3-4-织入-Weaving" class="headerlink" title="3.4. 织入 Weaving"></a>3.4. 织入 Weaving</h2><p>切面应用到目标对象的过程。</p><h3 id="3-4-1-织入时机"><a href="#3-4-1-织入时机" class="headerlink" title="3.4.1. 织入时机"></a>3.4.1. 织入时机</h3><ol><li>编译期： 需要特殊的编译器</li><li>类加载期: 需要类加载器的处理</li><li><strong>运行期</strong>: Spring所采纳的方式，使用代理对象，只支持方法级别的<font color="#c00000">连接点</font></li></ol><h3 id="3-4-2-织入方式"><a href="#3-4-2-织入方式" class="headerlink" title="3.4.2. 织入方式"></a>3.4.2. 织入方式</h3><p>使用代理机制。  </p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F31%2F10-35-22-e9d137daf3c4b7f22dc84e135ebdf72f-20231231103521-3027ed.png" alt="image.png"></p><h2 id="3-5-引入-👍introduction"><a href="#3-5-引入-👍introduction" class="headerlink" title="3.5. 引入 👍introduction"></a>3.5. 引入 👍introduction</h2><p>引入新的行为和状态。</p><h3 id="3-5-1-引入方式"><a href="#3-5-1-引入方式" class="headerlink" title="3.5.1. 引入方式"></a>3.5.1. 引入方式</h3><ol><li>创建需要增加的接口和实现类</li><li>新建一个切面类，加<code>@Aspect</code></li><li>在里面定义一个新增实现类的<code>static</code>接口，加上<code>@DeclareParents</code>注解</li><li>实例化切面类Bean</li></ol><h3 id="3-5-2-例子"><a href="#3-5-2-例子" class="headerlink" title="3.5.2. 例子"></a>3.5.2. 例子</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F21%2Ff76b26d26ccfff3dcc22e9fd080b07ea_20230921211603.png" alt="image.png"></p><p>定义切面，<strong>为对象增加新的行为</strong>。Encoreable接口里包含要引入的新的行为的定义。新的行为引入到原有类中的时候，每个类都会实例化一个新的DefaultEncoreable类，一对一。</p><p>切面本身是<strong>单实例</strong>的，但是实现新行为的类对应的实例和被切入类是<strong>一对一</strong>的。</p><ul><li><code>@DeclareParents</code>：<ul><li><code>value</code>：给实现了这个接口的对象，引入新的行为</li><li><code>defaultImpl</code>：实现了需要引入的新行为。在该例子中实现了<code>Encoreable</code>。</li></ul></li><li><code>main</code>和测试</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F09%2F28%2F786a0319e1f1f5d0d8e5422f97265926_20230928185355.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>9-OAuth2</title>
    <link href="http://example.com/posts/a0bd262e/"/>
    <id>http://example.com/posts/a0bd262e/</id>
    <published>2023-12-28T13:18:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-创建授权服务器"><a href="#1-创建授权服务器" class="headerlink" title="1. 创建授权服务器"></a>1. 创建授权服务器</h1><h2 id="1-1-增加权限控制"><a href="#1-1-增加权限控制" class="headerlink" title="1.1. 增加权限控制"></a>1.1. 增加权限控制</h2><p>POST：<a class="link" href="http://tacocloud:8080/api/ingredients">http://tacocloud:8080/api/ingredients <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>DELETE ：<a class="link" href="http://tacocloud:8080/">http://tacocloud:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> /api/ingredients/*</p><ul><li>两种方式<ul><li>.antMatchers(HttpMethod.POST, “/api/ingredients”).hasAuthority(“ROLE_USER”)</li><li>@PreAuthorize(“hasAuthority(‘ROLE_USER’)”)</li></ul></li></ul><h2 id="1-2-👍OAth2"><a href="#1-2-👍OAth2" class="headerlink" title="1.2. 👍OAth2"></a>1.2. 👍OAth2</h2><p>之前讲了Spring Security的单体应用权限控制</p><ul><li>OAth2：<strong>分布式环境</strong>中微服务权限控制，需要把认证和授权集中在一个地方，不需要每个微服务单独做认证授权。<ul><li>是一个与变成语言无关的规范</li><li>restful api权限控制</li></ul></li></ul><h2 id="1-3-👍授仅码授权（authorization-code-grant）模式"><a href="#1-3-👍授仅码授权（authorization-code-grant）模式" class="headerlink" title="1.3. 👍授仅码授权（authorization code grant）模式"></a>1.3. 👍授仅码授权（authorization code grant）模式</h2><h3 id="1-3-1-👍流程图"><a href="#1-3-1-👍流程图" class="headerlink" title="1.3.1. 👍流程图"></a>1.3.1. 👍流程图</h3><ul><li>Client application：客户端（第三方应用程序），消费API提供的资源</li><li>Authorization server：授权服务器</li><li>Resource server：提供API资源</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F13%2F19-20-30-a83b91bcb885875b08c329f60f5ac115-msedge_CL3vHC98yN-06bb6b.png" alt="msedge_CL3vHC98yN.png"></p><ul><li>授权服务器会用<strong>私钥</strong>给token签名，资源服务器用<strong>公钥</strong>验证token是否合法</li><li>token不变时公钥也不变，只有第一次才需要向授权服务器索取公钥</li></ul><h3 id="1-3-2-👍过程"><a href="#1-3-2-👍过程" class="headerlink" title="1.3.2. 👍过程"></a>1.3.2. 👍过程</h3><p>其中使用<strong>授权码授权模式</strong></p><ol><li>用户使用第三方的应用程序，也就是客户端应用程序</li><li>客户端发现用户未登录，将用户<strong>重定向</strong>到授权服务器<ul><li>授权服务器会维护合法的重定向地址，用于校验</li></ul></li><li>授权服务器向用户索取用户名密码</li><li>用户名密码匹配，则授权服务器请求用户授权</li><li><strong>授权服务器给客户端程序返回code</strong>，重定向回到应用程序<ul><li><strong>这里的code是和重定向URI一起返回给浏览器的，所以不安全</strong></li><li>授权服务器返回的是重定向url+code</li></ul></li><li><strong>客户端应用程序用code向授权服务器索取token</strong><ul><li>用code交换token，可能包含访问令牌（access token）和更新令牌（refresh token）</li><li><strong>token不过浏览器</strong>，在应用程序服务端和授权服务器之间处理</li></ul></li><li>客户端在请求头带上token调用资源服务器的API</li><li>资源服务器验证token，返回结果<ul><li>第一次，资源服务器向授权服务器索取公钥，验证Token合法性</li><li>Token过期时才会重新索取公钥</li></ul></li><li>客户端程序把结果返回给用户</li></ol><p>密码没有在浏览器来回传送，但是如果没有密码即使拿到code也没用<br>用code向授权服务器换取token才需要密码</p><p><a class="link" href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0 - 阮一峰的网络日志 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="1-4-其他授权模式"><a href="#1-4-其他授权模式" class="headerlink" title="1.4. 其他授权模式"></a>1.4. 其他授权模式</h2><ol><li>隐式授权（implicit grant）：直接返回访问令牌Token，而不是授仅码</li><li>用户凭证（或密码）授权（user credentials (password) grant）：用户凭证直接换取访问令牌，不经过浏览器登录</li><li>客户端凭证授权（client credentials grant）：客户端交换自己的凭证以获取访问令牌</li></ol><h2 id="1-5-开发授权服务器"><a href="#1-5-开发授权服务器" class="headerlink" title="1.5. 开发授权服务器"></a>1.5. 开发授权服务器</h2><h3 id="1-5-1-授权服务器config"><a href="#1-5-1-授权服务器config" class="headerlink" title="1.5.1. 授权服务器config"></a>1.5.1. 授权服务器config</h3><ol><li>注册第三方应用程序（客户端）</li><li>指定资源服务器地址</li><li>jwkSource</li></ol><h3 id="1-5-2-JWK"><a href="#1-5-2-JWK" class="headerlink" title="1.5.2. JWK"></a>1.5.2. JWK</h3><p>JSON web key，RSA密钥对（公䄴、私䄴），用于对令牌签名，令牌会用私钥签名，资源服务器会通过从授权 服务器获取到的公钥验证请求中收到的令牌是否有效</p><p>运行授权服务器</p><h3 id="1-5-3-运行授权服务器"><a href="#1-5-3-运行授权服务器" class="headerlink" title="1.5.3. 运行授权服务器"></a>1.5.3. 运行授权服务器</h3><ol><li>获得授权码（浏览器访问）:<a class="link" href="http://authserver:9000/oauth2/authorize?response_type=code&client_id=taco-admin-client&scope=writeIngredients+deleteIngredients&redirect_uri=http://clientadmin:9090/login/oauth2">http://authserver:9000/oauth2/authorize?response_type=code&amp;client_id=taco-admin-client&amp;scope=writeIngredients+deleteIngredients&amp;redirect_uri=http://clientadmin:9090/login/oauth2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>获得token（postman访问） POST ： <a class="link" href="http://authserver:9000/oauth2/token">http://authserver:9000/oauth2/token <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>刷新token（postman访问）： <a class="link" href="http://authserver:9000/oauth2/token">http://authserver:9000/oauth2/token <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ol><h1 id="2-创建资源服务器"><a href="#2-创建资源服务器" class="headerlink" title="2. 创建资源服务器"></a>2. 创建资源服务器</h1><h2 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1. 步骤"></a>2.1. 步骤</h2><ol><li><p>添加依赖</p></li><li><p>在过滤器中针对被保护的API添加权限控制</p><ul><li>使用<code>SCOPE_</code>前缀</li><li>开启API调用前的过滤器</li></ul></li><li><p>指定授权服务器的地址</p><ul><li>为了获取公钥</li></ul></li></ol><p><font color="#ff0000">使用<code>SCOPE_</code>前缀</font>:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(HttpMethod.POST, "/api/ingredients").hasAuthority("SCOPE_writeIngredients")</span><br><span class="line">.antMatchers(HttpMethod.DELETE, "/api/ingredients/*").hasAuthority("SCOPE_deleteIngredients")</span><br></pre></td></tr></table></figure></div><p>开启API调用前的过滤器:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and()</span><br><span class="line">.oauth2ResourceServer(oauth2 -&gt; oauth2.jwt())</span><br></pre></td></tr></table></figure></div><h2 id="2-2-配置资源服务器从何处获取公钥"><a href="#2-2-配置资源服务器从何处获取公钥" class="headerlink" title="2.2. 配置资源服务器从何处获取公钥"></a>2.2. 配置资源服务器从何处获取公钥</h2><p>jwt属性配置：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    oauth2:</span><br><span class="line">      resourceserver:</span><br><span class="line">        jwt:</span><br><span class="line">          jwk-set-uri: http://tacocloud:9000/oauth2/jwks</span><br></pre></td></tr></table></figure></div><h2 id="2-3-从POSTMAN访问被保护资源"><a href="#2-3-从POSTMAN访问被保护资源" class="headerlink" title="2.3. 从POSTMAN访问被保护资源"></a>2.3. 从POSTMAN访问被保护资源</h2><ul><li>带着token（Authorization属性）访问POST：<a class="link" href="http://tacocloud:8080/api/ingredients">http://tacocloud:8080/api/ingredients <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>带着token（Authorization属性）访问DELETE：<a class="link" href="http://tacocloud:8080/api/ingredients/">http://tacocloud:8080/api/ingredients/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>*</li></ul><h1 id="3-开发客户端"><a href="#3-开发客户端" class="headerlink" title="3. 开发客户端"></a>3. 开发客户端</h1>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>服务端考试复习（例题）</title>
    <link href="http://example.com/posts/ff3b226a/"/>
    <id>http://example.com/posts/ff3b226a/</id>
    <published>2023-12-28T13:12:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-题型"><a href="#1-题型" class="headerlink" title="1. 题型"></a>1. 题型</h1><p>多选题<br>问答题：5道题</p><h1 id="2-问答题例题"><a href="#2-问答题例题" class="headerlink" title="2. 问答题例题"></a>2. 问答题例题</h1><p>前7个是老师最后一节课讲到，但没给答案。</p><h2 id="2-1-web开发框架分层，请求处理过程"><a href="#2-1-web开发框架分层，请求处理过程" class="headerlink" title="2.1. web开发框架分层，请求处理过程"></a>2.1. web开发框架分层，请求处理过程</h2><ul><li><p>分层</p><ol><li>控制器层</li><li>业务逻辑层</li><li>数据访问层</li></ol></li><li><p>处理过程：</p><ol><li>Web容器开发的基本单元是Servlet，请求先到servlet。</li><li>mapping根据url把请求转到controller，其中spring框架会做参数解析。</li><li>controller拿到请求和请求参数，把请求和请求参数传给业务层</li><li>业务层处理业务逻辑，可能会做数据持久化访问DAO层</li><li>业务层把处理结构返回控制器</li><li>控制器把结果放回给servlet</li><li>servlet拿到了数据和逻辑视图名，找到视图解析器的第三方库</li><li>视图解析器渲染视图</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F12%2F18%2F10-13-42-ca4167c94583a1706c06fdd1405e61c3-Screenshotundefinedfromundefined2023-10-07undefined18-38-55-eb0c99.png" alt="Screenshot from 2023-10-07 18-38-55"></p><h2 id="2-2-AOP编程解决什么问题，开发要点"><a href="#2-2-AOP编程解决什么问题，开发要点" class="headerlink" title="2.2. AOP编程解决什么问题，开发要点"></a>2.2. AOP编程解决什么问题，开发要点</h2><ul><li>解决问题<ol><li>分离横切关注点，把非业务逻辑分离出来，减少对业务代码的侵入</li><li>降低耦合</li></ol></li><li>开发要点<ol><li><strong>通知 Advice</strong>：切面要做什么以及何时做<ul><li>时间：方法前/后…</li></ul></li><li><strong>切点 Pointcut</strong>：指定在何处切<ul><li>Spring只支持在<font color="#ff0000">方法</font>的前后切</li><li>写<strong>切点表达式</strong>指定逻辑</li></ul></li><li><strong>切面 Aspect</strong>：Advice和Pointcut的结合<ul><li>包含切的所有逻辑</li></ul></li><li><strong>连接点 Join point</strong>：方法、字段修改、构造方法</li><li><strong>引入 introduction</strong>：引入新的行为和状态<ul><li>给对象加入新的方法/状态，但不需要实现新的子类。在原来的对象上动态加入新的方法/状态。</li></ul></li><li><strong>织入 Weaving</strong>：切面应用到目标对象的过程</li></ol></li></ul><p>[[2-面向切面编程#3. 👍AOP术语]]</p><h2 id="2-3-spring-security-web请求保护"><a href="#2-3-spring-security-web请求保护" class="headerlink" title="2.3. spring security web请求保护"></a>2.3. spring security web请求保护</h2><p>使用servlet容器的filter机制拦截web请求，对请求进行权限控制。</p><h2 id="2-4-web请求开发有哪些步骤"><a href="#2-4-web请求开发有哪些步骤" class="headerlink" title="2.4. web请求开发有哪些步骤"></a>2.4. web请求开发有哪些步骤</h2><ol><li>设计REST API<ol><li><ol><li>使用<strong>标准HTTP动词</strong>：GET、PUT、POST、DELETE，映射到CRUD</li></ol></li><li>使用URL来传达意图<ul><li>例：请求一批资源复数，单个资源单数</li><li>推荐用名词</li></ul></li><li>请求和响应使用JSON</li><li>使用HTTP状态码来传达效果<ul><li><code>Create</code>: 201</li><li><code>No content</code>: 204</li></ul></li></ol></li><li>创建controller，定义请求映射</li><li>在业务逻辑层处理请求，返回响应</li></ol><p>[[8-REST API#2.12. Rest API接口设计👍]]</p><h2 id="2-5-OAuth2基于授权码的授权，系统组成，处理流程"><a href="#2-5-OAuth2基于授权码的授权，系统组成，处理流程" class="headerlink" title="2.5. OAuth2基于授权码的授权，系统组成，处理流程"></a>2.5. OAuth2基于授权码的授权，系统组成，处理流程</h2><ul><li>系统组成<ol><li>客户端，第三方应用程序，API所提供的资源的消费者<ul><li>后端</li></ul></li><li>授权服务器，在分布式系统中进行统一权限控制</li><li>资源服务器，提供API资源</li></ol></li><li>处理流程（这里的User应该是指浏览器）<ol><li>用户使用第三方应用</li><li>第三方应用发现用户未登录，将用户重定向到授权服务器</li><li>授权服务器向用户索取用户名密码</li><li>用户名密码匹配，则授权服务器请求用户授权</li><li>如果用户授权，授权服务器向客户端返回客户端预设的重定向URI和授权码（code）<ul><li>这里的code是和重定向URI一起返回给浏览器的，所以不安全</li></ul></li><li>客户端用授权码向授权服务器申请令牌（token），授权服务器确认令牌（token），给客户端返回令牌（token）<ul><li><strong>token不过浏览器</strong>，在应用程序服务端和授权服务器之间处理</li></ul></li><li>客户端调用资源服务器的api，带上令牌（token）</li><li>资源服务器验证令牌（token），返回结果</li><li>客户端把请求结果返回</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F13%2F19-20-30-a83b91bcb885875b08c329f60f5ac115-msedge_CL3vHC98yN-06bb6b.png"></p><h2 id="2-6-Spring集成流解决了什么问题"><a href="#2-6-Spring集成流解决了什么问题" class="headerlink" title="2.6. Spring集成流解决了什么问题"></a>2.6. Spring集成流解决了什么问题</h2><p>企业级应用程序必须要与其他的系统协作才能完成其目标。Spring集成流可以使应用程序跨越本身的边界，与其他的应用程序和企业级服务实现集成。</p><h2 id="2-7-反应式编程的4个接口"><a href="#2-7-反应式编程的4个接口" class="headerlink" title="2.7. 反应式编程的4个接口"></a>2.7. 反应式编程的4个接口</h2><ol><li>Publisher：数据发布者</li><li>Subscriber：数据订阅者</li><li>Peocessor：处理器</li><li>Subscription：协调</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2023%2F11%2F30%2F19-07-41-798ed044f2aa4ce418bbeb6519cfa668-20231130190741-06575a.png"></p><h2 id="2-8-不同消息的区别"><a href="#2-8-不同消息的区别" class="headerlink" title="2.8. 不同消息的区别"></a>2.8. 不同消息的区别</h2><ol><li>反应式编程<ul><li>一种面向数据流和变化传播的声明式编程范式</li><li>只在JVM中流动</li></ul></li><li>spring集成流<ul><li>header：消息头</li><li>payload：消息体</li><li>只在JVM中流动</li></ul></li><li>消息队列<ul><li>也有header和payload</li><li>要在网络中流动，所以需要消息转换器（序列化/反序列化）</li></ul></li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/categories/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_服务端开发" scheme="http://example.com/tags/2023-Fall-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>考试</title>
    <link href="http://example.com/posts/bd4d7fe/"/>
    <id>http://example.com/posts/bd4d7fe/</id>
    <published>2023-12-28T13:12:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><p>多选题<br>问答题：5道题</p><h1 id="问答题例题"><a href="#问答题例题" class="headerlink" title="问答题例题"></a>问答题例题</h1><h2 id="web开发框架分层，请求处理过程"><a href="#web开发框架分层，请求处理过程" class="headerlink" title="web开发框架分层，请求处理过程"></a>web开发框架分层，请求处理过程</h2><ul><li><p>分层</p><ol><li>控制器层</li><li>业务逻辑层</li><li>数据访问层</li></ol></li><li><p>处理过程：[[3-Spring MVC#3.1. 处理过程👍]]</p><ol><li>Web容器开发的基本单元是Servlet，请求先到servlet。</li><li>mapping根据url把请求转到controller，其中spring框架会做参数解析。</li><li>controller拿到请求和请求参数，把请求和请求参数传给业务层</li><li>业务层处理业务逻辑，可能会做数据持久化访问DAO层</li><li>业务层把处理结构返回控制器</li><li>控制器把结果放回给servlet</li><li>servlet拿到了数据和逻辑视图名，找到视图解析器的第三方库</li><li>视图解析器渲染视图</li></ol></li></ul><h2 id="AOP编程解决什么问题，开发要点"><a href="#AOP编程解决什么问题，开发要点" class="headerlink" title="AOP编程解决什么问题，开发要点"></a>AOP编程解决什么问题，开发要点</h2><ul><li>解决问题<ol><li>分离横切关注点，把非业务逻辑分离出来，减少对业务代码的侵入</li><li>降低耦合</li></ol></li><li>开发要点<ol><li>[[2-面向切面编程#3. AOP术语👍]]</li></ol></li></ul><h2 id="spring-security-web请求保护"><a href="#spring-security-web请求保护" class="headerlink" title="spring security web请求保护"></a>spring security web请求保护</h2><p>使用servlet容器的filter机制拦截web请求，对请求进行权限控制。</p><h2 id="web请求开发有哪些步骤"><a href="#web请求开发有哪些步骤" class="headerlink" title="web请求开发有哪些步骤"></a>web请求开发有哪些步骤</h2><ol><li>设计REST API [[8-REST API#2.12. Rest API接口设计👍]]</li><li>创建controller，定义请求映射</li><li>在业务逻辑层处理请求，返回响应</li></ol><h2 id="OAuth2基于授权码的授权，系统组成，处理流程"><a href="#OAuth2基于授权码的授权，系统组成，处理流程" class="headerlink" title="OAuth2基于授权码的授权，系统组成，处理流程"></a>OAuth2基于授权码的授权，系统组成，处理流程</h2><h2 id="Spring集成流解决了什么问题"><a href="#Spring集成流解决了什么问题" class="headerlink" title="Spring集成流解决了什么问题"></a>Spring集成流解决了什么问题</h2><h2 id="反应式编程的4个接口"><a href="#反应式编程的4个接口" class="headerlink" title="反应式编程的4个接口"></a>反应式编程的4个接口</h2>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>13-期末复习</title>
    <link href="http://example.com/posts/20e7e86a/"/>
    <id>http://example.com/posts/20e7e86a/</id>
    <published>2023-12-26T16:12:00.000Z</published>
    <updated>2024-01-05T13:41:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-内容组织"><a href="#1-内容组织" class="headerlink" title="1. 内容组织"></a>1. 内容组织</h1><p>软件主导硬件<br>以应用为中心</p><ul><li><strong>重要</strong> ，+</li><li><em>不重要</em>，-</li></ul><h1 id="2-嵌入式系统概述"><a href="#2-嵌入式系统概述" class="headerlink" title="2. 嵌入式系统概述"></a>2. 嵌入式系统概述</h1><ol><li>定义、术语</li><li>组成</li><li>特点</li><li>分类</li><li>典型应用</li></ol><h1 id="3-设计方法"><a href="#3-设计方法" class="headerlink" title="3. 设计方法"></a>3. 设计方法</h1><ol><li>嵌入式系统设计的挑战</li><li>设计目标</li><li>传统的设计过程</li><li><em>软硬件协同设计</em></li><li><em>原型</em></li></ol><h1 id="4-嵌入式微处理器"><a href="#4-嵌入式微处理器" class="headerlink" title="4. 嵌入式微处理器"></a>4. 嵌入式微处理器</h1><ol><li>分类</li><li>特点</li><li>流水线清空，分支预测技术</li><li>选择微处理器的准则、步骤</li></ol><p>更关注那些可能会影响上层软件开发的部分<br>偏向集成/板级开发</p><p><strong>考试一定会涉及，但是量不大</strong></p><h1 id="5-存储器架构"><a href="#5-存储器架构" class="headerlink" title="5. 存储器架构"></a>5. 存储器架构</h1><ol><li>复杂</li><li><em>易失性存储器</em></li><li><em>非易失性存储器</em></li><li>固件、可固化（ROMable）</li><li>存储器系统的层次架构</li><li><em>flash</em></li></ol><h1 id="6-总线"><a href="#6-总线" class="headerlink" title="6. 总线"></a>6. 总线</h1><ol><li>可重入</li><li>竞态条件</li><li>总线，常用</li></ol><h1 id="7-硬件部分总结与实例"><a href="#7-硬件部分总结与实例" class="headerlink" title="7. 硬件部分总结与实例+"></a>7. 硬件部分总结与实例+</h1><ol><li>感知决策控制</li><li>根据能力和性能，设备分类</li><li>车载为例，计算平台</li><li>环境感知，常用传感器</li></ol><h1 id="8-嵌入式软件概述"><a href="#8-嵌入式软件概述" class="headerlink" title="8. 嵌入式软件概述"></a>8. 嵌入式软件概述</h1><p>嵌入式软件和桌面软件对比<br>有关硬件的决策会对软件产生持久的影响，软件主导硬件<br>嵌入式软件系统层次架构<br><strong>为什么要对实时系统建模</strong><br><strong>实时系统</strong></p><h1 id="9-嵌入式软件架构综述"><a href="#9-嵌入式软件架构综述" class="headerlink" title="9. 嵌入式软件架构综述+"></a>9. 嵌入式软件架构综述+</h1><ol><li>嵌入式软件架构</li><li>实时嵌入式软件常用的设计模式</li><li>获取数据的设计模式</li><li>RTOS应用程序中的同步（资源，活动），不同方式/设计模式</li></ol><h1 id="10-建模"><a href="#10-建模" class="headerlink" title="10. 建模+"></a>10. 建模+</h1><ol><li>建模，设计，分析</li><li>模型，特征</li><li>常见的建模技术，建模语言</li><li>嵌入式系统模型的用途</li><li>何时对嵌入式系统建模</li><li><strong>反应式系统</strong>，模型，特征<ul><li>对机器人很重要</li></ul></li><li><strong>FSM</strong>有限状态机<ul><li>所有的示例都要看一下</li></ul></li><li>层次FSM<ul><li>补充常规有限状态机的局限</li></ul></li></ol><p>CPS</p><h1 id="11-嵌入式操作系统概述"><a href="#11-嵌入式操作系统概述" class="headerlink" title="11. 嵌入式操作系统概述+"></a>11. 嵌入式操作系统概述+</h1><ol><li>实时系统，术语，分类</li><li>RTOS &amp; GPOS</li><li>RTOS关键要求</li><li>为何使用RTOS</li><li>RTOS类别</li><li><strong>物联网操作系统</strong>，要求，通用架构<ul><li>与以往的嵌入式系统有一些差异</li></ul></li></ol><h1 id="12-实时调度"><a href="#12-实时调度" class="headerlink" title="12. 实时调度+"></a>12. 实时调度+</h1><ol><li>实时系统所需的调度策略</li><li>调度决策</li><li>任务模型</li><li>时限约束</li><li>调度程序的度量</li><li><strong>RMS、EDF及其改进</strong></li><li><em>实时调度异常</em></li><li><em>优先级反转，优先级继承，优先级天花板</em></li></ol><h1 id="13-嵌入式实时内核（结合ucOS-II和freertos）"><a href="#13-嵌入式实时内核（结合ucOS-II和freertos）" class="headerlink" title="13. 嵌入式实时内核（结合ucOS-II和freertos）-"></a>13. 嵌入式实时内核（结合ucOS-II和freertos）-</h1><ol><li>实时任务调度</li><li>中断时钟</li><li>同步与通信</li><li>存储管理（静态、动态</li></ol><h1 id="14-bsp-bootloader"><a href="#14-bsp-bootloader" class="headerlink" title="14. bsp,bootloader -"></a>14. bsp,bootloader -</h1><ol><li>嵌入式系统启动过程</li><li>bsp,特点，与bios区别</li><li>引导模式</li><li>bootloader及其启动过程</li></ol><h1 id="15-物联网概述"><a href="#15-物联网概述" class="headerlink" title="15. 物联网概述 +"></a>15. 物联网概述 +</h1><ol><li>定义，术语</li><li>IOT特征</li><li>IOT的优势和不足</li><li>应用</li></ol><h1 id="16-IoT技术"><a href="#16-IoT技术" class="headerlink" title="16. IoT技术 +"></a>16. IoT技术 +</h1><ol><li>IoT的多样化技术环境</li><li>物联网软件、硬件、连接<ul><li>介绍了一些比较成熟的技术</li></ul></li><li>进步最快的技术</li><li>IoT面临的挑战</li></ol><h1 id="17-IoT平台"><a href="#17-IoT平台" class="headerlink" title="17. IoT平台"></a>17. IoT平台</h1><ol><li>概念</li><li>功能领域</li></ol><p>管理平台，中间件<br>纯后端系统</p><h1 id="18-IoT平台关键技术"><a href="#18-IoT平台关键技术" class="headerlink" title="18. IoT平台关键技术+"></a>18. IoT平台关键技术+</h1><p>设备影子，物模型<br>边缘计算</p><ol><li>设备管理：主要功能，<strong>物模型</strong>、<strong>设备影子</strong>、数字孪生（概念，价值）</li><li>边缘计算：基于云的IoT解决方案不足，边缘/边缘计算计算概念，优势，用途<ul><li>CDN是边缘计算的落地</li></ul></li><li>通信协议：主流技术，多协议接入方案</li></ol><h1 id="19-ROS"><a href="#19-ROS" class="headerlink" title="19. ROS"></a>19. ROS</h1><ol><li>相关概念</li><li>为何使用</li></ol><p>作业用到的</p><h1 id="20-自动紧急制动-AEB"><a href="#20-自动紧急制动-AEB" class="headerlink" title="20. 自动紧急制动 AEB"></a>20. 自动紧急制动 AEB</h1><ol><li>意义</li><li>难点</li><li>功能</li><li>流程</li><li>策略</li></ol><h1 id="21-PID算法及其应用"><a href="#21-PID算法及其应用" class="headerlink" title="21. PID算法及其应用"></a>21. PID算法及其应用</h1><ol><li>反馈控制</li><li><strong>开环控制</strong></li><li><strong>闭环控制</strong></li><li>PID算法</li></ol><h1 id="22-关键词提示"><a href="#22-关键词提示" class="headerlink" title="22. 关键词提示 +"></a>22. 关键词提示 +</h1><ol><li>嵌入式：受限（资源，成本），专用，实时，可靠</li><li>物联：网络连接，节能，多样/异构，安全<ul><li>通信的能耗不弱于计算</li></ul></li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2023_Fall_嵌入式系统概论" scheme="http://example.com/categories/2023-Fall-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2023_Fall_嵌入式系统概论" scheme="http://example.com/tags/2023-Fall-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
  </entry>
  
</feed>
