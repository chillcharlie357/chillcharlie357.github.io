<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Charlie</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-19T06:56:34.272Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Charlie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件系统设计-pmx期末</title>
    <link href="http://example.com/posts/e8fd03f1/"/>
    <id>http://example.com/posts/e8fd03f1/</id>
    <published>2024-06-11T07:06:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><ul><li>简答题<ol><li>设计原则之间的关系</li><li>设计模式之间的关系</li><li>设计原则和设计模式之间的关系</li><li>架构分析方法和概念</li></ol></li><li>设计题：<ul><li>给出一个设计问题，回答设计方案</li><li>设计两三个设计模式联合设计</li></ul></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><ol><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果：可以作为约束条件的一部分</li></ol><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>目的</p><ol><li>创建型：创建对象</li><li>结构型：处理类和对象的组合</li><li>行为型：描述对类或对象怎样交互和怎样分配职责</li></ol></li><li><p>范围</p><ol><li>类模式：式处理类和子类之间的关系，这些关系通过继承建立， 在编译时刻就被确定下来，是属于<strong>静态</strong>的。</li><li>对象模式：处理对象间的关系，这些关系在运行时刻变化，更具<strong>动态</strong>性</li></ol></li><li><p>模式和模式的变体，不同</p></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F19%2F14-03-56-f7eba1b50144117a2d8052de51950d35-20240619140355-d9b953.png" alt="image.png"></p><h2 id="设计模式与类库框架"><a href="#设计模式与类库框架" class="headerlink" title="设计模式与类库框架"></a>设计模式与类库框架</h2><ul><li>为什么不设计一个设计模式的库？<ul><li>设计模式比库更高层。设计模式告诉我们怎么构建类和对象来解决特定问题，我们需要做的是使用这些原则来适应具体的应用。</li></ul></li><li>库和框架是不是设计模式？<ul><li>框架和类不是设计模式。它们提供了可以连接到代码中的具体实现。但是优势库和框架会在它们的实现中应用设计模式。如果你理解了设计模式，你可以更快理解框架和库的API。</li></ul></li></ul><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计原则之间的关系</p><ul><li>目标：<ol><li>可复用</li><li>可维护</li></ol></li><li>设计原则<ol><li><strong>单一职责原则</strong>要求在软件系统中，一个类只负责一个功能领域中的相应职责。</li><li><strong>开闭原则</strong>要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</li><li><strong>里氏代换原则</strong>可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</li><li><strong>依赖倒转原则</strong>要求抽象不应该依赖于细节，细节应该依赖于抽象；要针对接口编程，不要针对实现编程。</li><li><strong>接口隔离原则</strong>要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</li><li><strong>合成复用原则</strong>要求复用时尽量使用对象组合，而不使用继承。</li><li><strong>迪米特法则</strong>要求一个软件实体应当尽可能少的与其他实体发生相互作用。</li></ol></li><li>目标：开闭原则</li><li>指导：最小知识原则/迪米特</li><li>基础：单一职责原则、封装可变性原则</li><li>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</li></ul><h1 id="表驱动法"><a href="#表驱动法" class="headerlink" title="表驱动法"></a>表驱动法</h1><ul><li>目标</li><li>原理</li><li>如何快速从表中查询条目？<ol><li>直接访问</li><li>索引访问</li><li>阶梯访问</li></ol></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>软件系统设计-架构期末</title>
    <link href="http://example.com/posts/3ff9b627/"/>
    <id>http://example.com/posts/3ff9b627/</id>
    <published>2024-06-06T02:06:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-架构概念"><a href="#1-架构概念" class="headerlink" title="1. 架构概念"></a>1. 架构概念</h1><ol><li>架构定义<ul><li>架构定义：软件系统的系统，系统包含元素，元素之间的关系，软件的属性和动态行为</li><li>工业界定义：设计阶段最重要设计决定的集合</li></ul></li><li>软件架构师做什么</li><li>架构来源<ol><li>主要：NFR非功能需求</li><li>ASR</li><li>质量需求</li><li>利益相关者</li><li>技术环境</li></ol></li><li>视图 4+1<ol><li>逻辑视图：架构的静态关系</li><li>过程视图：运行过程种的变化行为</li><li>物理视图：和物理世界元素的对应关系</li><li>开发视图：开发活动</li><li>用例场景user case scenairos</li></ol></li><li>架构活动和演化</li><li>软件架构知识域</li></ol><h1 id="2-架构过程"><a href="#2-架构过程" class="headerlink" title="2. 架构过程"></a>2. 架构过程</h1><p>四个阶段，图<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-08-47-0067f3b14e1c3d3853948c36015a7a1d-20240616170846-967e93.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-08-57-d8d00bc5524d00997b981af5fd1fa8c0-20240616170856-10f18d.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-09-06-dce21ed5882ec762dc38214bf132fe92-20240616170906-6800ff.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F17-09-13-5a8ff42941d1d7d1f678df31e4fa0d02-20240616170913-841a77.png" alt="image.png"></p><h1 id="3-质量属性"><a href="#3-质量属性" class="headerlink" title="3. 质量属性"></a>3. 质量属性</h1><ol><li>软件需求<ol><li>功能需求：系统行为</li><li>质量需求:系统完成工作好坏程度</li><li>约束：需求阶段预设的设计决定，不能妥协</li></ol></li><li>质量属性<ol><li>外部：用户把系统作为黑盒，可以从外部感受的</li><li>内部：可以知道系统内部怎么实现，开发人员，系统是否容易实现和维护</li><li>用刺激相应情景描述</li><li>tatics树和设计决定</li><li>checklist在七个方面评估质量属性</li></ol></li><li>ASR：<ol><li>如何从用户获取ASR？从需求文档（不能提供足够信息，尤其是质量需求），座谈会，商业目标，项目树（Utililty Tree）</li></ol></li></ol><h1 id="4-架构模式"><a href="#4-架构模式" class="headerlink" title="4. 架构模式"></a>4. 架构模式</h1><p>可以被复用的解决方案</p><p>涉及的架构元素<br>相互之间的关系<br>需要施加的设计决定</p><ul><li>分类<ol><li>Module 描述静态关系</li><li>CNC 组件连接器</li><li>系统动态关系</li><li>系统和外部（物理世界，人，组织….）</li></ol></li></ul><p>Tactic是最小粒度的基本设计决定<br>Pattern包含需要解决的问题，问题发生的场景，一系列设计决定</p><h1 id="5-设计架构"><a href="#5-设计架构" class="headerlink" title="5. 设计架构"></a>5. 设计架构</h1><ul><li><p>通用设计策略</p><ol><li>抽象</li><li>分解</li><li>分治</li><li>生成和测试：先根据ASR、质量属性选择一个初始的设计决定组合，然后看是不是能满足ASR要求</li><li>迭代</li><li>重用</li></ol></li><li><p>7个方面</p><ol><li>Responsibilities职责：如何分配，不等于功能<ul><li>还有质量要求，如Monitor是为了可用性而不是实现功能</li></ul></li><li>Coordition</li><li>Data：数据存储，协议，分配</li><li>Resource：计算资源，网络，缓存，时间</li><li>Elements mapping</li><li>Binding time：元素之间的关系什么时候被确定下来<ol><li>绑定事件越往后，越灵活，但是系统的不确定性增加，测试负担增加</li></ol></li></ol></li><li><p>ADD</p><ol><li>输入：ASR</li><li>输出：在step 4生成的视图</li></ol></li></ul><h1 id="6-文档架构"><a href="#6-文档架构" class="headerlink" title="6. 文档架构"></a>6. 文档架构</h1><ul><li>Views视图<ol><li>style(viewpoints), pattern and views</li><li>Structural views: module views, component and connector views, allocation views</li><li>Quality views</li></ol></li><li>文档化视图：<ol><li>确定stakeholder，保留提供了大部分stakehodler都关心的信息的视图</li><li>合并视图</li><li>排序，把不重要的视图筛选掉</li></ol></li><li>视图补充信息</li></ul><h1 id="7-评估架构"><a href="#7-评估架构" class="headerlink" title="7. 评估架构"></a>7. 评估架构</h1><ul><li>ATAM方法<ol><li>不同阶段参加的stackholder不同<ol><li>phase1 项目评估小组，决策者</li><li>phase2 其他stackholder</li></ol></li><li>输入：架构文档</li><li>输出：设计决定，ASR，效用树，风险</li></ol></li></ul><p>phase1<br>phase2 不能向stackholder透露效用树</p><h1 id="8-微服务架构"><a href="#8-微服务架构" class="headerlink" title="8. 微服务架构"></a>8. 微服务架构</h1><p>更多考虑他们之间的关系</p><p>这里有张图，注意图例</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SQL-期末</title>
    <link href="http://example.com/posts/48f5fee/"/>
    <id>http://example.com/posts/48f5fee/</id>
    <published>2024-06-03T06:06:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>SQL 3选2，标注使用哪个数据库</p><ul><li>常见函数：<ol><li>字符串replace</li><li>数值计算，考虑空值，平均值空值</li><li>日期，使用索引的三种写法</li></ol></li><li>递归查询，withas<ul><li>起始体，union all,递归体，视图</li></ul></li><li>外连接+数值计算</li></ul><p>结构合理、关键字、函数都有分</p><h1 id="论述"><a href="#论述" class="headerlink" title="论述"></a>论述</h1><ol><li>索引的叶节点<ul><li>结构：N个节点，N+1个link<ul><li>考试一般3扇出</li></ul></li><li>节点分裂/合并<ul><li>叶节点和内部节点</li><li>向上传递</li></ul></li></ul></li><li>日志<ul><li>Redo</li><li>Undo</li><li>区别，实现，问题</li></ul></li><li>分区，分表，分库<ul><li>原因</li><li>解决的问题</li><li>带来新的问题</li></ul></li><li>SQL解释器：<strong>可能会考一个基于成本优化器的成本计算方式</strong><ol><li>优化的基本逻辑</li><li>基于成本的优化器</li><li>基于规则的优化器</li></ol></li><li>建议和想法</li></ol><hr><p>B+Tree索引是大多DBMS缺省的索引类型，请详细描述以下几个问题：<br>1）B树索引的结构和使用方式  </p><p>有K个子树的中间结点包含K个元素，每个节点不保存数据只保存索引，所有的数据都存储在叶节点；<br>所有叶节点中包含了元素的信息，还有指向元素记录的指针，并且叶节点本身按照关键字大小从小到大的顺序连接；<br>使用方式是根据目标元素在B树中二分查找。</p><p>2）何时该使用B树索引，并分别说明原因；并详细说明为什么系统的为外键构建索引是普遍的要求？</p><p>何时使用：<br>仅需要通过索引访问基本表的一部分（检索的结果集与集体的百分比低于10%）<br>如果处理表的多列，可以使用索引而不使用表；<br>为什么系统的为外键构建索引是普遍的要求：<br>建立外键索引可以更快速地保证数据的一致性：比如A持有B的外键，B删除记录时需要检查A中相应的行；否则，需要对A全表遍历；<br>建立外键索引可以避免死锁：如上所述，对A全表遍历时间很长，导致其他进程与之死锁，导致双双失败；</p><p>3）针对2）有没有例外情况？如果有请简要说明情况  </p><p>如果表很小或者很少被修改，则不必建立；因为使用索引非常占用磁盘空间；</p><p>4）请描述Oracle中一种类似于B树索引结构的物理组织形式索引组织表（IOT）的基本结构和应用范围  </p><p>其中的记录是排序，按主键有序的。IOT中每个叶节点既有每行的主键值，又有非主键值。<br>数据的存放是严格规定的， 记录的存放是排序的，查询效率非常高。数据插入以前其实就已经确定了其位置，所以不管插入的先后顺序，它在那个物理上的哪个位置与插入的先后顺序无关。这样在进行查询的时候就可以少访问很多 blocks，但是插入的时候，速度就比普通的表要慢一些。<br>应用范围：经常查找的表；经常通过主键访问的表；按顺序进行物理存贮；构建自己的索引结构；对主键或者唯一键区间查询、分类查询；<br>不适用：经常更新的表；不经常使用主键访问的表；</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>07-Linux期末总结</title>
    <link href="http://example.com/posts/60504a0c/"/>
    <id>http://example.com/posts/60504a0c/</id>
    <published>2024-05-30T02:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ol><li>什么是Linux？<ul><li>类Unix，开源，免费，GNU协议，支持多平台</li></ul></li><li>常见Linux发行版有哪些？</li><li>GPL版权的特点<ol><li>开放源代码</li><li>自由使用</li><li>有传染性</li></ol></li><li>文件系统和后面的文件一起考</li><li>GRUB知道就行，细节不考</li><li>配置文件能读懂就行<ul><li>grun.conf</li><li>title, root, kernel, initrd</li></ul></li><li>安装软件步骤<ol><li>cmake： 用于生成makefile</li><li>make：编译</li><li>make install：从Makefile中读取指令，将编译好的文件复制到指定的安装目录中</li></ol></li><li>虚拟终端切换<ul><li>Alt-Fn (or Ctrl-Alt-Fn if in X)</li></ul></li><li>命令行提示符<ol><li>$：普通用户</li><li><h1 id="：root用户"><a href="#：root用户" class="headerlink" title="：root用户"></a>：root用户</h1></li><li>和环境变量<code>PS1</code>有关</li></ol></li><li><strong>命令都要</strong>，除了课上讲的不要求的命令</li><li>文件基本概念<ol><li>数据集合，可以读写的对象，有属性、类型、权限</li><li>字节流</li></ol></li><li><strong>7种文件类型</strong><ol><li>普通文件</li><li>文件夹</li><li>字符设备文件</li><li>块设备文件</li><li>网络接口文件</li><li>符号链接</li><li>管道文件</li></ol></li><li>知道统一目录结构</li><li><strong>文件权限</strong></li><li>进程</li></ol><p>MBR、GPT不考<br>常见目录一般不考<br>开机启动部分不考<br>命令行好处不靠<br>多任务多用户，不考<br>层次结构图，不作为重点</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><ol><li><strong>命令</strong>，除了上课讲不考的都要考<ul><li>不考：vdir，locate</li></ul></li><li><strong>重定向</strong></li><li>管道：会用就行</li><li>环节变量，和SHELL编程一起考</li><li>高级命令和正则表达式，会有一些比较简单的表达式，不是重点<ol><li>find</li><li>sed</li><li>grep</li></ol></li></ol><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>考试最多出现两题概念题</p><ol><li>Shell概念<ul><li>用户与操作系统之间的接口，是核外程序。</li><li>既是命令的解释程序，也是独立的程序设计语言解释器。</li></ul></li><li>Shell类型，除了bash再列出一两个名字<ul><li>zsh, ash, csh</li></ul></li><li>Shell机制<ol><li>哪些功能归shell管：重定向、管道</li></ol></li><li><strong>执行Shell三种方式的区别</strong></li><li>环境变量<ol><li>基本命令：export, env,</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="8.471ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 3744 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(888,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mi" transform="translate(1651,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(2702,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(3466,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>PS1, $PS2</li></ol></li><li>read</li><li>引号用法</li><li>参数变量</li><li>条件测试<ol><li>[]形式</li></ol></li><li>Shell算数比较，直接给脚本理解</li><li>Shell脚本会写</li><li>命令表<ol><li>分号串联</li><li>条件组合<ol><li>AND</li><li>OR</li></ol></li></ol></li><li>函数，只要求会读</li><li>杂项命令</li><li>参数扩展</li><li>即时文档</li></ol><p>语句块不要求</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><ol><li>编译器原理，连接，动态库静态库。考试和Makefile一起考，一般给一个实际程序<ol><li>调试原理：要加调试信息，关掉调试优化</li></ol></li><li><strong>gcc参数</strong></li><li>makefile读得懂，写考试比较简单<ol><li>预定义变量，多目标扩展，使用函数，不要求写</li></ol></li></ol><p>gdb不考</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><ol><li>文件和文件系统的概念</li><li><strong>7种文件类型</strong></li><li><strong>VFS的四个对象</strong><ol><li>super block</li><li>i-node object</li><li>file object</li><li>dentry object</li></ol></li><li><strong>硬链接，软连接</strong><ol><li>区别：一定要答全</li><li>常见命令</li><li>对应系统调用</li><li>ls -l的时候会影响哪些地方</li></ol></li><li>系统调用和库函数<ol><li>区别：缓存分配，</li><li>编程题会要求用系统调用写，或用库函数写</li></ol></li><li>各种系统调用<ol><li>fcntl参数和意思，意思对就行</li><li>ioctl在驱动考，和字符型驱动的关系</li><li>umask，权限</li></ol></li><li>C库<ol><li>缓存</li></ol></li><li>文件锁<ol><li>系统调用：fcntl</li><li>类型</li></ol></li></ol><p>编程题：尽可能高效-&gt;用系统调用</p><p>文件系统在磁盘分布不考</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>进程线程</p><ol><li>系统调用<ol><li>exec系列</li><li>fork</li><li>wait,waitpid</li><li><strong>kill,raise</strong></li><li>alarm, pause</li><li>mmap/munmap</li></ol></li><li>进程信息</li><li>信号，不会要求写，会问在代码里的效果</li><li>可靠信号和不可靠信号</li><li>可重入函数<ol><li>列表不需要背下来</li></ol></li><li>地址映射：文件映射到一段内存地址<ol><li>mmap/munmap描述参数</li></ol></li><li><strong>pthread</strong><ol><li>编程可能会考</li><li>信号量、互斥量、条件变量</li><li>cancel</li><li>多线程程序出现错误</li><li>TLS</li></ol></li></ol><p>编程题：文件、线程、进程</p><p>main函数入口出口，不考<br>可靠信号的设置细节不要求掌握<br>共享内存不考<br>设置线程属性不考</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>块设备不考，只考到字符设备之前</p><ol><li>Linux内核介绍</li><li>内核编译步骤，知道make menuconfig是可选的</li><li>grub引导菜单能读</li><li>驱动：工作在内核态<ol><li>加载模块命令</li><li>模块依赖命令</li></ol></li><li>用户态程序和内核态程序区别</li><li>内核代码，读</li><li>内核代码/Shell脚本没有类型浮点支持</li><li>模块间通信</li><li>驱动类型：只要求字符型设备<ol><li><strong>字符型设备驱动的步骤</strong></li><li><strong>应用程序怎么用驱动</strong></li><li>主设备号和次设备号</li></ol></li></ol><p>init不要求<br>make-kpkg不要求<br>内核代码，不要求写<br>内核编译模式，makefile，不用写<br>/proc文件系统不要求</p><h1 id="试卷结构"><a href="#试卷结构" class="headerlink" title="试卷结构"></a>试卷结构</h1><p>选择<br>填空<br>判断<br>随机</p><p>简答题：<br>0~2概念题，送分<br>描述题，尽可能写满<br>读程序题</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>08-SQL常识</title>
    <link href="http://example.com/posts/2243eb0e/"/>
    <id>http://example.com/posts/2243eb0e/</id>
    <published>2024-05-28T06:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Group-by"><a href="#1-Group-by" class="headerlink" title="1. Group by"></a>1. Group by</h1><p>group by是一个过程化操作</p><ol><li>筛选分组用having，</li><li>count(*)只要rowid存在都会算，count(name)会忽略NULL</li></ol><h1 id="2-字符串处理"><a href="#2-字符串处理" class="headerlink" title="2. 字符串处理"></a>2. 字符串处理</h1><p>清洗数据在数据库里处理的代价比在应用程序里处理的代价低</p><h2 id="2-1-遍历字符串"><a href="#2-1-遍历字符串" class="headerlink" title="2.1. 遍历字符串"></a>2.1. 遍历字符串</h2><p>数据透视表(T1,T10,T100,…)</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(e.ename,iter.pos, <span class="number">1</span>) <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> ename)</span><br></pre></td></tr></table></figure></div><h2 id="2-2-内嵌引号"><a href="#2-2-内嵌引号" class="headerlink" title="2.2. 内嵌引号"></a>2.2. 内嵌引号</h2><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">' " '</span></span><br></pre></td></tr></table></figure></div><h2 id="2-3-统计字符出现的个数"><a href="#2-3-统计字符出现的个数" class="headerlink" title="2.3. 统计字符出现的个数"></a>2.3. 统计字符出现的个数</h2><p>问题：出现多少个逗号</p><p><strong>repalce</strong>+<strong>length</strong></p><p>len(replace) / len(‘,’)</p><h2 id="2-4-删除不想要的字符"><a href="#2-4-删除不想要的字符" class="headerlink" title="2.4. 删除不想要的字符"></a>2.4. 删除不想要的字符</h2><p>oracle：<code>translate</code><br>mysql：嵌套<code>replace</code></p><h2 id="2-5-分离数字和字符"><a href="#2-5-分离数字和字符" class="headerlink" title="2.5. 分离数字和字符"></a>2.5. 分离数字和字符</h2><p>oracle: translate对原来的字段处理两次<br>mysql：正则表达式<code>REGEXP_REPLACE</code></p><h2 id="2-6-判断含有数字和字母的数值"><a href="#2-6-判断含有数字和字母的数值" class="headerlink" title="2.6. 判断含有数字和字母的数值"></a>2.6. 判断含有数字和字母的数值</h2><p>mysql: 正则表达式，regexp</p><h2 id="2-7-提取姓名首字母"><a href="#2-7-提取姓名首字母" class="headerlink" title="2.7. 提取姓名首字母"></a>2.7. 提取姓名首字母</h2><p>需要找到空格的位置或大写的位置，然后把那个位置的字母提出来</p><h1 id="3-数值操作"><a href="#3-数值操作" class="headerlink" title="3. 数值操作"></a>3. 数值操作</h1><h2 id="3-1-计算平均值"><a href="#3-1-计算平均值" class="headerlink" title="3.1. 计算平均值"></a>3.1. 计算平均值</h2><p>难点在于空值</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span><span class="operator">%</span> 统计空值 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="built_in">coalesce</span>(sal,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">from</span> t2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> 不统计空值 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal)</span><br><span class="line"><span class="keyword">from</span> t2</span><br></pre></td></tr></table></figure></div><h2 id="3-2-累计求和"><a href="#3-2-累计求和" class="headerlink" title="3.2. 累计求和"></a>3.2. 累计求和</h2><p>sum over</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, sal</span><br><span class="line"><span class="built_in">sum</span>(sal) <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> sal,empno)</span><br><span class="line"><span class="keyword">as</span> running_total</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span>中的第二个字段</span><br></pre></td></tr></table></figure></div><h2 id="3-3-计算众数"><a href="#3-3-计算众数" class="headerlink" title="3.3. 计算众数"></a>3.3. 计算众数</h2><p>group by<br>count</p><h2 id="3-4-计算中位数"><a href="#3-4-计算中位数" class="headerlink" title="3.4. 计算中位数"></a>3.4. 计算中位数</h2><p>oracle: median()<br>mysql：分组，记录个数，找到中间位置的值</p><h2 id="3-5-去掉最大值最小值，然后计算平均值"><a href="#3-5-去掉最大值最小值，然后计算平均值" class="headerlink" title="3.5. 去掉最大值最小值，然后计算平均值"></a>3.5. 去掉最大值最小值，然后计算平均值</h2><p>where sal not in (min_sal, max_sal)</p><h1 id="4-日期处理"><a href="#4-日期处理" class="headerlink" title="4. 日期处理"></a>4. 日期处理</h1><h2 id="4-1-年月日加减法"><a href="#4-1-年月日加减法" class="headerlink" title="4.1. 年月日加减法"></a>4.1. 年月日加减法</h2><p>oracle: add_mounths()<br>mysql: date_add()</p><h2 id="4-2-两个日期之间的天数"><a href="#4-2-两个日期之间的天数" class="headerlink" title="4.2. 两个日期之间的天数"></a>4.2. 两个日期之间的天数</h2><p>mysql: datediff<br>oracle：两个日期直接相减</p><h2 id="4-3-两个日期之间的工作日天数"><a href="#4-3-两个日期之间的工作日天数" class="headerlink" title="4.3. 两个日期之间的工作日天数"></a>4.3. 两个日期之间的工作日天数</h2><p>需要获取日期是星期几，然后把星期六星期天去掉<br>date_format,date_add</p><h2 id="4-4-判断闰年"><a href="#4-4-判断闰年" class="headerlink" title="4.4. 判断闰年"></a>4.4. 判断闰年</h2><p>加一年，然后判断时间差是多少天；<br>判断二月份第一天到最后一天是几天</p><h1 id="5-常见SQL连接模式"><a href="#5-常见SQL连接模式" class="headerlink" title="5. 常见SQL连接模式"></a>5. 常见SQL连接模式</h1><h2 id="5-1-叠加行集（Union-Union-all）"><a href="#5-1-叠加行集（Union-Union-all）" class="headerlink" title="5.1. 叠加行集（Union & Union all）"></a>5.1. 叠加行集（Union &amp; Union all）</h2><p>不是关系代数</p><ul><li>约束：上下的select字段要一样，字段数量要一样</li><li>区别：<ul><li>Union：等同于针对Union all的输出再进行一次distinct操作</li><li>Union all：不去重</li></ul></li></ul><h2 id="5-2-查找只存在于一张表的数据（差）"><a href="#5-2-查找只存在于一张表的数据（差）" class="headerlink" title="5.2. 查找只存在于一张表的数据（差）"></a>5.2. 查找只存在于一张表的数据（差）</h2><p>MySQL: not in<br>Oracle: minus</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select deptno</span><br><span class="line">from dept</span><br><span class="line">where deptno not in (</span><br><span class="line">select deptno in emp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如果<code>deptno</code>不是主键：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select distinct deptno</span><br><span class="line">from dept</span><br><span class="line">where deptno not in (</span><br><span class="line">select deptno in emp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如果<code>not in</code>嵌套查询里有空值:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select deptno</span><br><span class="line">from dept</span><br><span class="line">where deptno not in (10, 50, null)</span><br></pre></td></tr></table></figure></div><p>no=20 not in (10, 50, null)-&gt;(F or F or null)=null，查询结果为空</p><h2 id="5-3-从一个表检索另一个不相关的行（外连接）"><a href="#5-3-从一个表检索另一个不相关的行（外连接）" class="headerlink" title="5.3. 从一个表检索另一个不相关的行（外连接）"></a>5.3. 从一个表检索另一个不相关的行（外连接）</h2><p>左外连接<br>右外连接</p><h2 id="5-4-确定两个表是否有相同的数据"><a href="#5-4-确定两个表是否有相同的数据" class="headerlink" title="5.4. 确定两个表是否有相同的数据"></a>5.4. 确定两个表是否有相同的数据</h2><p>很复杂</p><h2 id="5-5-从多个表种返回缺失的值"><a href="#5-5-从多个表种返回缺失的值" class="headerlink" title="5.5. 从多个表种返回缺失的值"></a>5.5. 从多个表种返回缺失的值</h2><p>全外连接</p><h2 id="5-6-连接和聚合函数的使用"><a href="#5-6-连接和聚合函数的使用" class="headerlink" title="5.6. 连接和聚合函数的使用"></a>5.6. 连接和聚合函数的使用</h2>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>06-微服务架构</title>
    <link href="http://example.com/posts/ab2d67c8/"/>
    <id>http://example.com/posts/ab2d67c8/</id>
    <published>2024-05-21T06:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<p>微服务架构：小，自治</p><h1 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h1><ol><li><p>分析用户故事中和场景中的名词</p></li><li><p>分析用户故事中和场景中的动词，确定系统操作</p><ol><li><font color="#c00000">命令型或查询型</font></li><li>前端给后端发出请求</li><li>后端进行业务逻辑的数据获取和处理</li><li>系统操作规范<ol><li>命令对应的参数、返回值</li><li>领域模型类的行为：<font color="#c00000">前置和后置条件</font></li></ol></li></ol></li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>07-SQL优化的基础</title>
    <link href="http://example.com/posts/b68ed7c/"/>
    <id>http://example.com/posts/b68ed7c/</id>
    <published>2024-05-13T06:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关系代数核心</strong>：等价变换-&gt;可以自动对表达式做等价变换，做查询路径优化</p><h1 id="1-SQL与查询优化器"><a href="#1-SQL与查询优化器" class="headerlink" title="1. SQL与查询优化器"></a>1. SQL与查询优化器</h1><p>group by, order by不属于关系代数，无法被查询优化器优化</p><ul><li><p>过程</p><ol><li>优化器借助关系理论提供的语义无误的原始查询进行<strong>有效的等价变换</strong></li><li>优化器根据数据库的实际情况对理论上等价的不同优化方案<strong>做出权衡</strong></li><li>产生可能的<strong>最优查询执行方案</strong></li><li>实际将一个SQL查询优化成更高效的方案</li></ol></li><li><p>类型</p><ol><li>RBO基于规则的优化器：给每个算子赋值一个权重，计算整个查询的总权重</li><li>CBO基于成本的优化器：还要考虑结果集大小<ul><li>优化目标：中间结果集的数量最少</li></ul></li></ol></li></ul><h1 id="2-基于规则的优化"><a href="#2-基于规则的优化" class="headerlink" title="2. 基于规则的优化"></a>2. 基于规则的优化</h1><ul><li><span style="background:rgba(3, 135, 102, 0.2)">要点：结构匹配和替换</span><ol><li>应用规则算法一般需要现在关系代数结构上匹配一部分局部结构</li><li>在根据结构的特点进行变换，替换</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F16-58-48-a760838c6f3725342a3536e93a7390d3-20240613165848-32932d.png" alt="image.png"></p><h1 id="3-基于成本的优化"><a href="#3-基于成本的优化" class="headerlink" title="3. 基于成本的优化"></a>3. 基于成本的优化</h1><p><span style="background:rgba(3, 135, 102, 0.2)">要点：执行计划的成本估算</span></p><p>遍历不同关系代数表示，枚举功能，得到最优方案。</p><h2 id="3-1-优化主要方向-连接"><a href="#3-1-优化主要方向-连接" class="headerlink" title="3.1. 优化主要方向-连接"></a>3.1. 优化主要方向-连接</h2><h3 id="3-1-1-嵌套循环连接（Nested-Loop-Join）"><a href="#3-1-1-嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="3.1.1. 嵌套循环连接（Nested-Loop Join）"></a>3.1.1. 嵌套循环连接（Nested-Loop Join）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-02-10-f24ab1df8bea51f8d89dcba316bcde3e-20240613170210-aeeba2.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-02-35-70192c6a4827b7a0f9f1af66c3e09f5f-20240613170235-750631.png" alt="image.png"></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1.m1 &gt; 1</span><br><span class="line">t1.m1 = t2.m2</span><br><span class="line">t2.n2 &lt; 'd'</span><br></pre></td></tr></table></figure></div><ul><li><p>左外连接</p><ul><li>T1 T2左外连接，T1记录都保留，T2如果没有相等的，结果集中是空值</li></ul></li><li><p><span style="background:rgba(3, 135, 102, 0.2)">驱动表只访问一次，但被驱动表却可能被多次访问</span>，访问次数取决于 对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为<span style="background:rgba(3, 135, 102, 0.2)">嵌套循环连接 ( Nested-Loop Join )</span></p></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-05-02-ce6ea7a731c15bd09390b2072d306728-20240613170502-db3580.png" alt="image.png"></p><h3 id="3-1-2-基于索引的连接优化"><a href="#3-1-2-基于索引的连接优化" class="headerlink" title="3.1.2. 基于索引的连接优化"></a>3.1.2. 基于索引的连接优化</h3><p>基于索引的连接优化：通过索引读取有限条的T2数据与T1连接</p><ol><li>被驱动表有索引的情况下，被驱动表被驱动表筛选的数据<strong>进行多次基于索引的查询</strong></li><li>如果有<strong>多个条件</strong>，需要多个索引，优化器选择某个索引进行执行</li><li>连接查询和过滤条件一般只涉及<strong>被驱动表的部分列</strong>，所以真实工作环境不要使用<code>*</code>作为查询列表<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-08-56-24a145188978dbfdd9725c4f22b6183a-20240613170856-d6e2ef.png" alt="image.png"></li></ol><h3 id="3-1-3-基于块的连接优化（Block-Nested-Loop-Join）"><a href="#3-1-3-基于块的连接优化（Block-Nested-Loop-Join）" class="headerlink" title="3.1.3. 基于块的连接优化（Block Nested-Loop Join）"></a>3.1.3. 基于块的连接优化（Block Nested-Loop Join）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F17-11-46-3ebf049bd6a19b2d509f9c8abba07ef4-20240613171146-3c374e.png" alt="image.png"></p><ol><li><strong>尽量减少访问被驱动表的次数</strong>（驱动表的记录不会都放入 join buffer，只会将部分列放入）</li><li>join buffer 足够大，就可以一次访问被驱动表完成连接</li><li>join buffer 一般 256KB（相比来看，索引仍然是最好的选择）</li></ol><h2 id="3-2-连接小结"><a href="#3-2-连接小结" class="headerlink" title="3.2. 连接小结"></a>3.2. 连接小结</h2><ol><li>本质上，连接就是把各个表中的路径都取出来依次进行匹配，并把匹配的组合返回 </li><li>外连接和内连接的本质都是确定驱动表  </li><li><strong>嵌套循环连接算法</strong>：驱动表连接一次，但被驱动表可能会访问多次，访问次数取决于被驱动表执行单表查询后结果集中有多少记录  </li><li>被驱动表会被连接多次，可以用索引加速</li><li>被驱动表很大，多次访问会导致更多的磁盘 I/O，基于块的嵌套循环算法来缓解</li></ol><h2 id="3-3-成本计算"><a href="#3-3-成本计算" class="headerlink" title="3.3. 成本计算"></a>3.3. 成本计算</h2><p>I/O成本：物理读写<br>CPU成本：比较，逻辑读写<br>…</p><h2 id="3-4-基于成本的优化步骤"><a href="#3-4-基于成本的优化步骤" class="headerlink" title="3.4. 基于成本的优化步骤"></a>3.4. 基于成本的优化步骤</h2><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算<strong>全表扫描的代价</strong>(row, data_length)</li><li>计算使用<strong>不同索引的代价</strong></li><li>对比各个查询优化方案的代价，找到成本最低的访问方式</li></ol><p><strong>好条件先做</strong></p><p>SQL-&gt;表达式-&gt;树-&gt;不断调整树的节点，找到最优执行路径-&gt;得到执行计划：可执行的代码</p><p><a class="link" href="https://juejin.cn/post/6990669704457093134">MySQL 是怎样运行的 - 基于成本的优化 - 掘金 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="3-4-1-全表扫描成本"><a href="#3-4-1-全表扫描成本" class="headerlink" title="3.4.1. 全表扫描成本"></a>3.4.1. 全表扫描成本</h3><ul><li>查询成本=<code>I/O</code>成本+<code>CPU</code>成本<ol><li><span style="background:rgba(3, 135, 102, 0.2)"> I/O成本</span>：聚簇索引占用的<strong>页面数</strong>，记录从磁盘到内存</li><li><span style="background:rgba(3, 135, 102, 0.2)">CPU成本</span>：该表中的<strong>记录行数</strong>，检测记录是否满足条件，对结果集排序</li></ol></li></ul><p>row：记录行数<br>data_length：占用字节数 = 页面数量 X 页面大小</p><p>物理读取一个页面默认成本是 1.0<br>逻辑读取和检测条件默认为 0.2</p><h3 id="3-4-2-使用不同索引执行查询的代价"><a href="#3-4-2-使用不同索引执行查询的代价" class="headerlink" title="3.4.2. 使用不同索引执行查询的代价"></a>3.4.2. 使用不同索引执行查询的代价</h3><ul><li>二级索引 + 回表<ol><li>估算范围区间数量：查询优化器认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的</li><li>需要回表的数量：优化器需要计算二级索引的某个范围区间到底包含多少条记录，可能是估算出来的</li></ol></li><li>I/O成本：范围区间的数量 （读取一个页的成本）+ 回表操作（二级索引记录条数）</li><li>CPU成本：计算二级索引记录条数的成本（二级索引记录条数，微调） + 读取并检测回表后聚簇索引记录的成本（二级索引记录条数）</li></ul><h3 id="3-4-3-两表连接的成本分析"><a href="#3-4-3-两表连接的成本分析" class="headerlink" title="3.4.3. 两表连接的成本分析"></a>3.4.3. 两表连接的成本分析</h3><ul><li><span style="background:rgba(3, 135, 102, 0.2)">连接查询的总成本</span> = 单次访问驱动表的成本 + 驱动表扇出 * 单次被驱动表的成本</li><li>不同驱动表的成本不一样，寻找成本最低的那个</li><li><span style="background:rgba(3, 135, 102, 0.2)">扇出值：根据条件占比计算</span></li><li>多表连接类似,，只是可选路径是 N 的阶乘</li></ul><h1 id="4-SQL的执行顺序"><a href="#4-SQL的执行顺序" class="headerlink" title="4. SQL的执行顺序"></a>4. SQL的执行顺序</h1><ol><li>SQL</li><li>语法语义检查</li><li><strong>解析</strong>：最消耗资源的步骤，选择最优执行路径，</li><li>执行计划</li><li>执行引擎</li><li>存储引擎</li><li>数据库</li></ol><h1 id="5-软解析：绑定变量"><a href="#5-软解析：绑定变量" class="headerlink" title="5. 软解析：绑定变量"></a>5. 软解析：绑定变量</h1><ul><li><strong>绑定变量</strong>：把所有常量变成变量<ul><li>数据库一般不默认启用</li><li>但ORM框架一般默认绑定变量，处于安全性考虑</li></ul></li><li>好处：<ol><li>相似查询使用变量，当成一个查询。实现软解析。</li><li>避免sql串的拼接，防止注入</li></ol></li><li>缺点：<ol><li>绑定变量之后，无法通过范围查询的范围估计扇出数量，进而估计最优查询路径。只能使用平均值估算。</li></ol></li></ul><h2 id="5-1-防止SQL注入攻击"><a href="#5-1-防止SQL注入攻击" class="headerlink" title="5.1. 防止SQL注入攻击"></a>5.1. 防止SQL注入攻击</h2><p>不把SQL串组合起来之后直接放到查询优化器里，而是先保留变量生成执行计划后再代入变量</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span> A<span class="operator">=</span>a</span><br></pre></td></tr></table></figure></div><p>变量a作为<strong>执行计划的参数</strong>传入，而不是直接拼到SQL串里</p><h2 id="5-2-把相似查询当成同一个查询，只是参数不同"><a href="#5-2-把相似查询当成同一个查询，只是参数不同" class="headerlink" title="5.2. 把相似查询当成同一个查询，只是参数不同"></a>5.2. 把相似查询当成同一个查询，只是参数不同</h2><ul><li>如果查询与数据值有关，<strong>绑定变量</strong>导致无法优化，如<code>WHERE 3 &lt; x &lt; 5</code></li></ul><p>硬解析：相似查询当成多条查询，单独执行，数据值固定。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> x <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> x <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>把所有常量编程变量</span><br><span class="line"><span class="keyword">WHERE</span> x <span class="operator">=</span> A<span class="operator">/</span><span class="operator">/</span>绑定变量</span><br></pre></td></tr></table></figure></div><h1 id="6-优化器只能对关系领域进行优化"><a href="#6-优化器只能对关系领域进行优化" class="headerlink" title="6. 优化器只能对关系领域进行优化"></a>6. 优化器只能对关系领域进行优化</h1><p>order by，group by等不属于关系代数的操作无法优化，是脱离关系代数独立执行的</p><p>例子：查询不适经理的员工中，工资最高的五个人？</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">%</span><span class="operator">%</span> rownum是ORACLE方言 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> wrong <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> <span class="keyword">order</span> <span class="keyword">by</span>在前面的查询全部完成后再排序，就是只查询前<span class="number">5</span>条 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> empname, salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> status <span class="operator">!=</span> <span class="string">'EXEC'</span></span><br><span class="line"><span class="keyword">and</span> rownum <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> <span class="keyword">right</span> <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="operator">%</span><span class="operator">%</span> 选择出符合条件并排序后，再选择前<span class="number">5</span>条 <span class="operator">%</span><span class="operator">%</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> empname, salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> status <span class="operator">!=</span> <span class="string">'EXEC'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> rownum <span class="operator">&lt;=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>有效范围</strong><ol><li>优化器需要借助数据库中找到的信息</li><li>能够数据意义上等价变化</li><li>优化器考虑整体响应时间</li><li>优化器改善的是独立的查询</li></ol></li></ul><h1 id="7-优化器自动条件化解"><a href="#7-优化器自动条件化解" class="headerlink" title="7. 优化器自动条件化解"></a>7. 优化器自动条件化解</h1><ol><li>移除不必要的括号<ol><li>select from (t1, (t2, t3))</li><li>select from t1, t2, t3</li></ol></li><li>常量传递</li><li>移除没用的条件</li><li>表达式计算：<strong>只会对右侧修改，不会修改左侧</strong><ol><li>a=5+1</li><li>a=6</li><li>注意：-a&lt;8, a-1=6优化器不会优化<ul><li>语法语义检查的时候，无法预测左侧是不是函数索引f(x)</li></ul></li></ol></li><li>having子句和where子句合并<ol><li>没有聚合函数，group by子句时</li></ol></li><li>常量表检查，当成常量使用<ol><li>查询表中，只有一条或者没有记录</li><li>使用主键或唯一的二级索引键的等值查询</li></ol></li></ol><h1 id="8-使用SQL需要考虑的因素"><a href="#8-使用SQL需要考虑的因素" class="headerlink" title="8. 使用SQL需要考虑的因素"></a>8. 使用SQL需要考虑的因素</h1><ol><li>获得结果集所需访问的数据量（表大小）</li><li>定义结果集所需的查询条件<ul><li>过滤条件：where子句</li></ul></li><li>结果集的大小</li><li>获得结果集所涉及表的数量<ul><li>表的数量，from子句，不要超过5-8张表</li></ul></li><li>同时修改这些数据用户的多少</li></ol><h1 id="9-子查询"><a href="#9-子查询" class="headerlink" title="9. 子查询"></a>9. 子查询</h1><p>出现在某个查询语句的某个位置中的查询称为子查询</p><h2 id="9-1-嵌套子查询"><a href="#9-1-嵌套子查询" class="headerlink" title="9.1. 嵌套子查询"></a>9.1. 嵌套子查询</h2><ul><li>exist：<ol><li>关联嵌套子查询</li><li>内层查询绑定变量依赖外层查询，外层每有一个符合条件内查询都执行一次</li><li>外部条件好时，可以做到整个查询都在索引上完成，exist查询效率更高</li></ol></li><li>in：<ol><li>非关联嵌套子查询</li><li>内层查询不再依赖外层查询，只执行一次</li><li>内部结果集和外部结果集<strong>最差情况下要笛卡尔积</strong>。优化器要对内连接做优化。</li></ol></li></ul><h2 id="9-2-按返回结果区分子查询"><a href="#9-2-按返回结果区分子查询" class="headerlink" title="9.2. 按返回结果区分子查询"></a>9.2. 按返回结果区分子查询</h2><ol><li>标量子查询</li></ol><h2 id="9-3-优化"><a href="#9-3-优化" class="headerlink" title="9.3. 优化"></a>9.3. 优化</h2><ul><li>选择分辨率最大的条件</li><li>关键时In子查询的优化<ol><li>不相关子查询</li><li>如果子查询结果集记录少，内外层分别优化</li><li>子查询结果记录多，内存放不下。临时表，去重，构架哈希表。</li><li>大到内存放不下了临时表，磁盘物化表，构建B+树索引</li></ol></li></ul><h1 id="10-SQL优化的其他问题"><a href="#10-SQL优化的其他问题" class="headerlink" title="10. SQL优化的其他问题"></a>10. SQL优化的其他问题</h1>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>06-Linux内核</title>
    <link href="http://example.com/posts/612388c4/"/>
    <id>http://example.com/posts/612388c4/</id>
    <published>2024-05-13T03:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-编译内核"><a href="#1-编译内核" class="headerlink" title="1. 编译内核"></a>1. 编译内核</h1><p>有很多复杂的configure</p><ol><li>配置</li><li>make</li><li>启用内核</li></ol><h2 id="1-1-编译选项"><a href="#1-1-编译选项" class="headerlink" title="1.1. 编译选项"></a>1.1. 编译选项</h2><ul><li>config模式<ol><li>Y：加入内核</li><li>N：不加入内核</li><li>M：模块形式，先留一个地址，<code>.ko</code>文件。需要功能的时候可以去加载。</li></ol></li></ul><h2 id="1-2-启用新内核"><a href="#1-2-启用新内核" class="headerlink" title="1.2. 启用新内核"></a>1.2. 启用新内核</h2><ul><li>make install：把内核复制到\boot目录下<ul><li><font color="#c00000">慎用</font>，一般手动做这个操作</li></ul></li></ul><p>grub的引导菜单会多一个刚编译的内核</p><h2 id="1-3-初始化程序的建立"><a href="#1-3-初始化程序的建立" class="headerlink" title="1.3. 初始化程序的建立"></a>1.3. 初始化程序的建立</h2><ul><li>initrd<ul><li>系统启动时的第一个用户态程序，没有父进程的进程</li></ul></li></ul><h1 id="2-驱动"><a href="#2-驱动" class="headerlink" title="2. 驱动"></a>2. 驱动</h1><p>常见驱动的源代码集成在内核源码中</p><p>也有第三方驱动的开发，可以单独编译成模块<code>.ko</code></p><p>编译需要内核头文件的支持</p><h2 id="2-1-加载模块"><a href="#2-1-加载模块" class="headerlink" title="2.1. 加载模块"></a>2.1. 加载模块</h2><p>系统开机时没有加载，但可以在运行的时候加载模块</p><p>e.g. U盘驱动</p><ul><li>底层命令<ol><li><font color="#c00000">insmod</font>：<strong>把模块装载到内核里</strong></li><li>rmmod：从内核里释放模块</li></ol></li><li>高层命令<ol><li>modprobe：装载</li><li>modprobe -r：释放</li></ol></li></ul><h2 id="2-2-模块依赖"><a href="#2-2-模块依赖" class="headerlink" title="2.2. 模块依赖"></a>2.2. 模块依赖</h2><ul><li>lsmod：看当前已经装载到内核的模块<ul><li>和<code>cat /proc/modules</code>等价</li></ul></li><li>modinfo</li><li>moddep</li></ul><p>模块依赖：模块A引用模块B导出的符号，即模块B被模块A引用。如果要装载模块A，就要先装载模块B。</p><p>高层命令会解决依赖关系，而底层命令不会。</p><h2 id="2-3-模块通信"><a href="#2-3-模块通信" class="headerlink" title="2.3. 模块通信"></a>2.3. 模块通信</h2><ol><li>共享变量</li><li>调用函数</li></ol><h2 id="2-4-👍Linux内核模块与应用程序模块的区别"><a href="#2-4-👍Linux内核模块与应用程序模块的区别" class="headerlink" title="2.4. 👍Linux内核模块与应用程序模块的区别"></a>2.4. 👍Linux内核模块与应用程序模块的区别</h2><table><thead><tr><th></th><th>C</th><th>Linux内核模块</th></tr></thead><tbody><tr><td>运行</td><td>用户空间</td><td>内核空间</td></tr><tr><td>入口</td><td>main()</td><td>module_init()指定</td></tr><tr><td>出口</td><td>无</td><td>module_exit()指定</td></tr><tr><td>运行</td><td>直接指定</td><td>insmod</td></tr><tr><td>调试</td><td>gdb</td><td>kdbug,kdb,kgdb等</td></tr></tbody></table><ol><li>内核模块其实并不存在入口出口，init做初始化，exit做释放，加载后一直在内存里待命</li><li>内核模块真正执行的时候是用户态程序调用相关功能<ul><li>e.g. 内核加载了一段打印机的驱动，一直在内存里待命，在用户态程序（如Word）里点了打印，这段驱动才会被调用（通过系统调用）</li><li>要考虑并行会出现的问题，可能有多个用户同时打印</li></ul></li></ol><h2 id="2-5-内核程序注意事项"><a href="#2-5-内核程序注意事项" class="headerlink" title="2.5. 内核程序注意事项"></a>2.5. 内核程序注意事项</h2><ol><li>不能调用C库来开发驱动程序</li><li>没有内存保护机制</li><li>小内核栈<ul><li>内核一般不用递归否则会占用大量内存空间</li></ul></li><li>并发考虑</li><li>内核代码/Shell脚本没有类型浮点支持</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO <span class="string">"Hello world\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO <span class="string">"Goodbye world\n"</span>);</span><br><span class="line">}</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure></div><h2 id="2-6-编译"><a href="#2-6-编译" class="headerlink" title="2.6. 编译"></a>2.6. 编译</h2><p>内核Makefile和一般的不一样，而且经常更新</p><h2 id="2-7-模块参数传递"><a href="#2-7-模块参数传递" class="headerlink" title="2.7. 模块参数传递"></a>2.7. 模块参数传递</h2><ul><li>传递方式<ol><li>参数在模块加载时传递<ul><li>shell: <code>insmod hello.ko test=2</code></li></ul></li><li>参数需要使用module_param宏来声明<ul><li><code>module_param(变量名称，类型, 访问许可掩码)</code></li></ul></li></ol></li><li>支持参数类型<ul><li>Byte, short, ushort, int, uint, long, ulong, bool, charp</li><li>Array (module_param_array(name, type, nump, perm))</li></ul></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> test;</span><br><span class="line">module_param(test, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO “Hello world test=%d \n” , test);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">printk(KERN_INFO <span class="string">"Goodbye world\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Test"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"xxx"</span>);</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure></div><h1 id="3-字符型设备"><a href="#3-字符型设备" class="headerlink" title="3. 字符型设备"></a>3. 字符型设备</h1><h2 id="3-1-驱动程序的初始化加载过程"><a href="#3-1-驱动程序的初始化加载过程" class="headerlink" title="3.1. 驱动程序的初始化加载过程"></a>3.1. 驱动程序的初始化加载过程</h2><ol><li><strong>申请设备号</strong></li><li>定义<strong>文件操作结构体</strong> file_operations</li><li>创建并初始化定义<strong>结构体 cdev</strong><ol><li><code>struct cdev *my_cdev = cdev_alloc();</code></li><li><code>my_cdev-&gt;ops = &amp;my_fops;</code></li><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops);</code>和2功能差不多。</li></ol></li><li>将<strong>cdev注册到系统</strong>，并和对应的<strong>设备号绑定</strong><ul><li><code>int cdev_add(struct cdev *dev, dev_t num, unsigned int count);</code></li></ul></li><li>在/dev文件系统中用<strong>mknod创建设备文件</strong>，并将该文件<strong>绑定到设备号上</strong><ul><li><code>mknod {{path/to/device_file}} c {{major_device_number}} {{minor_device_number}}</code></li></ul></li></ol><h2 id="3-2-主设备号和次设备号"><a href="#3-2-主设备号和次设备号" class="headerlink" title="3.2. 主设备号和次设备号"></a>3.2. 主设备号和次设备号</h2><ul><li>一个字符设备或者块设备都有一个主设备号和次设备号。</li><li>主设备号和次设备号统称为设备号。</li><li>主设备号用来表示<strong>一个特定的驱动程序</strong>。</li><li>次设备号用来表示<strong>使用该驱动程序的各设备</strong>。</li></ul><h2 id="3-3-应用程序调用驱动"><a href="#3-3-应用程序调用驱动" class="headerlink" title="3.3. 应用程序调用驱动"></a>3.3. 应用程序调用驱动</h2><ol><li><strong>加载设备驱动</strong>：应用程序需要加载一个驱动模块（.ko文件），这个过程会生成一个设备文件，该文件代表了驱动程序控制的硬件设备或本地设备</li><li><strong>打开设备文件</strong>：应用程序使用系统提供的函数（如<code>open()</code>）来打开设备文件。这些函数最终会通过内核转发到相应的驱动函数。每个设备文件都有一个对应的inode结构体，包含了设备的主次设备号，是设备的唯一标识</li><li><strong>执行系统调用</strong>：应用程序通过执行系统调用（如<code>read()</code>, <code>write()</code>, <code>ioctl()</code>等）与设备驱动进行交互。这些调用最终会通过内核转发到相应的驱动函数</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>05-架构设计</title>
    <link href="http://example.com/posts/9e04b6b3/"/>
    <id>http://example.com/posts/9e04b6b3/</id>
    <published>2024-05-09T02:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ASR"><a href="#1-ASR" class="headerlink" title="1. ASR"></a>1. ASR</h1><p>Architecturally SIgnificant Requirement(ASR)：对架构有重要影响的需求</p><h2 id="1-1-获取"><a href="#1-1-获取" class="headerlink" title="1.1. 获取"></a>1.1. 获取</h2><h3 id="1-1-1-从需求文档"><a href="#1-1-1-从需求文档" class="headerlink" title="1.1.1. 从需求文档"></a>1.1.1. 从需求文档</h3><ul><li>MoSCoW：需求的四个级别，判断优先级和重要性<ol><li>Master</li><li>Should</li><li>Could</li><li>Won’t</li></ol></li></ul><p>仅仅从需求文档无法获得完整、充分、详细的信息</p><h3 id="1-1-2-座谈会-研讨会"><a href="#1-1-2-座谈会-研讨会" class="headerlink" title="1.1.2. 座谈会/研讨会"></a>1.1.2. 座谈会/研讨会</h3><p>Quality Attribute Workshop(QAW)</p><h1 id="2-设计决策👍"><a href="#2-设计决策👍" class="headerlink" title="2. 设计决策👍"></a>2. 设计决策👍</h1><p>七要素：</p><h2 id="2-1-分解"><a href="#2-1-分解" class="headerlink" title="2.1. 分解"></a>2.1. 分解</h2><p>把系统为了实现功能需求和非功能需求的责任进行分解，分配给被分解的元素</p><h2 id="2-2-设计ASR"><a href="#2-2-设计ASR" class="headerlink" title="2.2. 设计ASR"></a>2.2. 设计ASR</h2><ul><li>适用非ASR需求<ol><li>架构设计不影响非ASR的需求</li><li>需要对架构设计做调整，小范围调整</li><li>非ASR需求无法满足，要做一些妥协<ol><li>接近满足需求</li><li>调整需求</li><li>无法满足这些需求</li></ol></li></ol></li><li>是否要一次性设计所有的ASR？<ol><li>从经验判断</li><li>是完全从零开发，还是已经完成一部分，或是有框架</li></ol></li></ul><h2 id="2-3-生成和测试"><a href="#2-3-生成和测试" class="headerlink" title="2.3. 生成和测试"></a>2.3. 生成和测试</h2><p>验证和评估</p><ul><li><p>如何测试</p><ol><li>分析技术：静态建模，动态仿真技术</li><li>设计checklist</li></ol></li><li><p>什么时候完成验证</p><ol><li>设计满足ASR</li><li>预算不够，实现目前为止最佳的设计</li></ol></li></ul><h1 id="3-Attribute-Driven-Design-ADD"><a href="#3-Attribute-Driven-Design-ADD" class="headerlink" title="3. Attribute-Driven Design(ADD)"></a>3. Attribute-Driven Design(ADD)</h1><p>通用场景下的软件系统设计</p><h2 id="3-1-ADD的输入"><a href="#3-1-ADD的输入" class="headerlink" title="3.1. ADD的输入"></a>3.1. ADD的输入</h2><ol><li>是否有足够的需求？</li><li>是否已经筛选出ASR？</li><li>是否已经排序？</li><li>使用基于场景（刺激响应）的描述方式精确描述？</li></ol><h2 id="3-2-选择一个系统元素进行分解"><a href="#3-2-选择一个系统元素进行分解" class="headerlink" title="3.2. 选择一个系统元素进行分解"></a>3.2. 选择一个系统元素进行分解</h2><ul><li>分类<ol><li>greenfield开发：所有需求，整个系统作为设计焦点</li><li>partially designed system：在当前已经设计过的系统里选择一些元素作为设计焦点</li></ol></li></ul><h2 id="3-3-选择和当前迭代相关的ASR"><a href="#3-3-选择和当前迭代相关的ASR" class="headerlink" title="3.3. 选择和当前迭代相关的ASR"></a>3.3. 选择和当前迭代相关的ASR</h2><p>说明对用户的重要程度<br>说明对开发者的难易程度</p><p>排序：<br>(H,H)(H,M)(H,L)(M,H)…</p><h2 id="3-4-生成局部设计"><a href="#3-4-生成局部设计" class="headerlink" title="3.4. 生成局部设计"></a>3.4. 生成局部设计</h2><ol><li><strong>设计焦点</strong>承载的ASR怎么解决</li><li>列出所有patterns和tactics<ol><li>定义可配置的参数。e.g.ping/echo的timeout时间</li><li>估计参数值</li></ol></li><li>选择pattern和tactic<ol><li>对整体（当前设计焦点的各个ASR）的影响</li><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F09%2F11-08-06-b5b07ddb02853be9baf16f2cac386b1a-20240509110805-cc752b.png" alt="image.png"></li></ol></li><li>决定pattern/tactic和ASR的关系<ol><li>哪些要做调整，结合</li></ol></li><li>设计决定可视化成一个或一组视图</li><li>评估<ol><li>哪些ASR没有被考虑到</li><li>是否需要做额外修正</li><li>所有设计决定会不会不一致</li></ol></li></ol><h2 id="3-5-实例化架构元素，分配职责"><a href="#3-5-实例化架构元素，分配职责" class="headerlink" title="3.5. 实例化架构元素，分配职责"></a>3.5. 实例化架构元素，分配职责</h2><ol><li>实例化每一个架构元素</li><li>把设计焦点承担的责任分配到架构元素</li><li>把实例化和责任记录下来</li></ol><h2 id="3-6-为实例化元素定义接口"><a href="#3-6-为实例化元素定义接口" class="headerlink" title="3.6. 为实例化元素定义接口"></a>3.6. 为实例化元素定义接口</h2><p>交互哪些数据<br>元素之间的交互关系</p><h2 id="3-7-验证和完善需求，并使其成为实例化元素的约束"><a href="#3-7-验证和完善需求，并使其成为实例化元素的约束" class="headerlink" title="3.7. 验证和完善需求，并使其成为实例化元素的约束"></a>3.7. 验证和完善需求，并使其成为实例化元素的约束</h2><ol><li>验证设计需求是不是都分配到元素上</li><li>把每个元素的职责翻译成功能需求</li></ol><h2 id="3-8-重复直到所有ASR都满足"><a href="#3-8-重复直到所有ASR都满足" class="headerlink" title="3.8. 重复直到所有ASR都满足"></a>3.8. 重复直到所有ASR都满足</h2><p>每一次迭代都满足一些ASR，如果还有ASR没有完成回到第二步，选择系统中一个元素作为设计新的焦点</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F09%2F11-18-13-9377fac25e8135c67c87d8dcc3b099a3-20240509111812-df4de9.png" alt="image.png"></p><h2 id="3-9-ADD的输出"><a href="#3-9-ADD的输出" class="headerlink" title="3.9. ADD的输出"></a>3.9. ADD的输出</h2><ol><li>软件元素：履行各种角色和<strong>职责</strong>，具有预定<strong>属性</strong>并与其他软件元素相关以组成系统架构的计算或开发工件</li><li>角色</li><li>职责</li><li>性质</li><li>关系：使用视图表示元素之间的关联</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F09%2F11-22-20-c0b9137fbe7364b63e9e02a1583542ab-20240509112220-2a2a8b.png" alt="image.png"></p><h1 id="ADD例子"><a href="#ADD例子" class="headerlink" title="ADD例子"></a>ADD例子</h1><p><a class="link" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Lec15-Design/#3-%E5%9F%BA%E4%BA%8Eadd%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%9E%E4%BE%8B">2021-软件系统设计-Lec15-Design - SpriCoder的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>04-架构模式</title>
    <link href="http://example.com/posts/12c16a93/"/>
    <id>http://example.com/posts/12c16a93/</id>
    <published>2024-05-07T06:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<p>解决特定问题的设计决定的集合，但是可以参数化配置。</p><ul><li><p>DSSA 领域特定软件架构</p><ol><li>面向特定任务(task/domain)</li><li>在这个领域里是通用的</li><li>标准结构</li></ol></li><li><p>架构模式</p><ol><li>把设计决定打包在一起</li></ol></li><li><p>设计模式<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-09-51-8b4e00572f757ad428e4008f69aa83da-20240507140950-fa7584.png" alt="image.png"></p></li><li><p>架构模式分类</p><ol><li>Module</li><li>Component-Connector<ol><li>在Runtime动态建立联系</li></ol></li><li>Allocation</li></ol></li></ul><h1 id="Layered-Pattern"><a href="#Layered-Pattern" class="headerlink" title="Layered Pattern"></a>Layered Pattern</h1><ul><li>Module类架构</li></ul><ol><li>一个Layer里包含多个Module，不存在跨层的Module</li><li>限制层与层之间的依赖关系，质量属性的可修改性策略就使用了分层</li><li>各层之间不能跨层调用，只能上面调下面</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-16-47-b199ddcbdff99b04e268ba2e7d332b4c-20240507141646-1ef7b2.png" alt="image.png"></p><ul><li>限制<ol><li>每个模块只能被分配到一层</li><li>至少有两层</li><li>allowed-to-use关系不能是环，低层不能调用高层</li></ol></li><li>弱点<ol><li>增加层很复杂</li><li>性能</li></ol></li></ul><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-18-30-444d6cbeb1cdbf4fa785de6b61092876-20240507141829-67d177.png" alt="image.png"></p><hr><p>如果D是sidecar，那么也是分层；但如果D也有一定业务，则不是分层<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-25-46-741bf1a29993aa374ab8a6754a9fb3bd-20240507142545-72c020.png" alt="image.png"></p><h1 id="Broker-Pattern"><a href="#Broker-Pattern" class="headerlink" title="Broker Pattern"></a>Broker Pattern</h1><ul><li>Component-Connector类模式</li></ul><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-34-43-2c21c09e9de3e3b8c04404d72a18db01-20240507143442-cee395.png" alt="image.png"></p><ul><li>元素<ol><li>Client</li><li>Server</li><li>Broker：中介，帮助client找到server，传递请求</li></ol></li><li>分析<ol><li>提升了互操作性、可修改性</li><li>现代场景下如果有多个broker实例，可以提高扩展性、安全性、可用性（补充设计）</li><li>可能<strong>单点失效，减低性能、安全性、可用性</strong></li><li>减低可测试性，无法预先确定client和server的状态</li></ol></li></ul><h2 id="Pattern-1"><a href="#Pattern-1" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-36-41-5112182333c844cc84ff216ca67d7c03-20240507143641-9c99b5.png" alt="image.png"></p><h1 id="Model-View-Controller-Pattern"><a href="#Model-View-Controller-Pattern" class="headerlink" title="Model-View-Controller Pattern"></a>Model-View-Controller Pattern</h1><p>从动态看属于Component-Connector<br>从开发态看属于Module</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-54-35-cc6e1787efc5b7097c73cbb1ae914782-20240507145434-fb3e5b.png" alt="image.png"></p><h2 id="Pattern-2"><a href="#Pattern-2" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-54-49-7e40f48489e84a51c5331bf99eb8f877-20240507145448-7baa06.png" alt="image.png"></p><h1 id="Pipe-and-Filter-Pattern"><a href="#Pipe-and-Filter-Pattern" class="headerlink" title="Pipe-and-Filter Pattern"></a>Pipe-and-Filter Pattern</h1><p>Component-Connector</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-56-07-9ecaef916b1c000ee9724bf806272c79-20240507145607-deab29.png" alt="image.png"></p><ul><li><p>元素</p><ol><li>pipe<ul><li>必须有数据的输入和输出</li><li>连接一系列的数据处理/计算</li></ul></li><li>filter<ul><li>通过pipe连起来</li></ul></li></ol></li><li><p>限制</p><ol><li>系统里不可能只有孤立的pipe</li></ol></li></ul><h2 id="Pattern-3"><a href="#Pattern-3" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-57-55-2764955e71cac24cc8a6b8df474c15a6-20240507145754-7b1c94.png" alt="image.png"></p><h1 id="Client-Server-Pattern"><a href="#Client-Server-Pattern" class="headerlink" title="Client-Server Pattern"></a>Client-Server Pattern</h1><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F14-59-19-36800fe2562f1df5520f11d28f81167d-20240507145918-c888d4.png" alt="image.png"></p><ul><li><p>元素</p><ol><li>Client</li><li>Server</li></ol></li><li><p>不需要broker：在有限的网络中，有哪些服务是预先知道的</p></li></ul><h2 id="Pattern-4"><a href="#Pattern-4" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-03-13-fe3a35814348e258c7bcbf1c77e4d792-20240507150312-39032f.png" alt="image.png"></p><h1 id="Peer-to-Peer-Pattern"><a href="#Peer-to-Peer-Pattern" class="headerlink" title="Peer-to-Peer Pattern"></a>Peer-to-Peer Pattern</h1><p>CC<br>没有明确的地位差距</p><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-04-53-895cb73111b3ab647bb300595b8a7a2a-20240507150452-821875.png" alt="image.png"></p><p>peer即可以发送也可以接受数据</p><p>hops：限制可感知的范围<br>节点可以自由加入退出</p><ul><li>分析<ol><li>提高了系统的可伸缩性</li><li>牺牲移动安全性</li></ol></li></ul><h2 id="Pattern-5"><a href="#Pattern-5" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-07-03-98cf5b4315536a76cde2239249b648c1-20240507150702-8ce395.png" alt="image.png"></p><h1 id="Service-Oriented-SOA-Pattern"><a href="#Service-Oriented-SOA-Pattern" class="headerlink" title="Service-Oriented/SOA Pattern"></a>Service-Oriented/SOA Pattern</h1><p>cc</p><h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-15-38-887fee6231c05c8479e0b486f04e1aaf-20240507151537-92c286.png" alt="image.png"></p><ul><li>Component<ol><li>Service Provider</li><li>Service Consumer</li><li>Registry：注册服务</li><li>ESB：client到server的通信路由，类似broker</li><li>Orchestration server：编排组织业务</li></ol></li><li>Connector:<ol><li>SOAP</li><li>REST</li><li>Asynchronous</li></ol></li></ul><p>可以访问到其他组织，不同技术实现的服务</p><p>质量属性：提高互操作性</p><h2 id="Pattern-6"><a href="#Pattern-6" class="headerlink" title="Pattern"></a>Pattern</h2><p>虚线：组织边界，内部可以完全由组织控制</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-20-03-4ccbe77739cadb305da03a2116dd50eb-20240507152003-12bdce.png" alt="image.png"></p><h1 id="Publish-Subscribe-Pattern"><a href="#Publish-Subscribe-Pattern" class="headerlink" title="Publish-Subscribe Pattern"></a>Publish-Subscribe Pattern</h1><h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-25-01-b1aa62975ac9705c2737a903557f5e59-20240507152501-de822f.png" alt="image.png"></p><p>存在多对多的关系<br>不能保证一定会接收到，或即时接收到</p><h2 id="Pattern-7"><a href="#Pattern-7" class="headerlink" title="Pattern"></a>Pattern</h2><p>在OS中事件处理普遍使用</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-25-11-dda2131381aa560a984e411503e4faf0-20240507152510-7f26d2.png" alt="image.png"></p><h1 id="Shared-Data-Pattern"><a href="#Shared-Data-Pattern" class="headerlink" title="Shared-Data Pattern"></a>Shared-Data Pattern</h1><p>CC</p><h2 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h2><p>存在中心的被共享的数据</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-27-04-13c8a8d1b5b7924a527dee2dca6ab41c-20240507152703-ca7333.png" alt="image.png"></p><ul><li>分析<ol><li>星型结构，可能单点失效</li><li>想要获取数据高一致性、实时性时的妥协</li></ol></li></ul><h2 id="Pattern-8"><a href="#Pattern-8" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-28-17-8bc18054676d4840b527b2b0f755f94d-20240507152816-a848b3.png" alt="image.png"></p><h1 id="Map-Reduce-Pattern"><a href="#Map-Reduce-Pattern" class="headerlink" title="Map-Reduce Pattern"></a>Map-Reduce Pattern</h1><p>Allocation</p><h2 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-34-47-8ff14e9d91dc5c25f1491a01e2d84019-20240507153447-99021c.png" alt="image.png"></p><p>Map：任务分割，一组相同的任务并行，每一个任务都在一个Map上处理<br>Reduce：把Map的输出整合在一起，变成单一输出</p><p>要求数据是大量的，否则map-reduce的代价不划算<br>通过并行提高了性能</p><h2 id="Pattern-9"><a href="#Pattern-9" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-35-10-c5969942e099ae089a1227eaf43e1fc7-20240507153509-36694f.png" alt="image.png"></p><h1 id="Multi-Tier-Pattern"><a href="#Multi-Tier-Pattern" class="headerlink" title="Multi-Tier Pattern"></a>Multi-Tier Pattern</h1><h2 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-37-11-613758ec02833ece319fcc0f8b7892df-20240507153710-1a1259.png" alt="image.png"></p><p>Tier：逻辑的分层，不是真实存在的层。软件的每一个计算资源作为一个Tier</p><h2 id="Pattern-10"><a href="#Pattern-10" class="headerlink" title="Pattern"></a>Pattern</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-38-03-070c12b3a26b2de121f315cd2e0ca9ce-20240507153803-a48a52.png" alt="image.png"></p><h1 id="Pattern和Tactic"><a href="#Pattern和Tactic" class="headerlink" title="Pattern和Tactic"></a>Pattern和Tactic</h1><p>Pattern：一组设计决定<br>Tactic：最小单元</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F15-41-41-6ecf53de649ae4edf390216d51159112-20240507154140-dc2113.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>05-质量管理</title>
    <link href="http://example.com/posts/8294aeb9/"/>
    <id>http://example.com/posts/8294aeb9/</id>
    <published>2024-05-07T02:05:00.000Z</published>
    <updated>2024-06-19T06:56:34.276Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#c00000">管理定义：目标定义，状态跟踪，纠偏</font></p><h1 id="1-质量策略"><a href="#1-质量策略" class="headerlink" title="1. 质量策略"></a>1. 质量策略</h1><h2 id="1-1-质量概念"><a href="#1-1-质量概念" class="headerlink" title="1.1. 质量概念"></a>1.1. 质量概念</h2><ol><li>软件质量为“与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体”。[ANSI/IEEE STd 729]</li><li>软件质量为内外两部分的特性：其外部质量特性面向软件产品的最终用户，其内部质量特性则不直接面向最终用户。 《代码大全》</li><li>软件质量为软件产品可以改变世界，使世界更加美好的程度。从用户的角度考察软件质量，用户满意度是最为重要的判断标准。 [Tom Demarco]</li><li>软件质量为对人（用户）的价值。这一定义强调了质量的主观性，即对同一款软件而言，不同的用户对其质量有不同的体验。 [Gerald Weinberg]</li></ol><p>内部，外部，主观</p><h2 id="1-2-面向用户的质量观"><a href="#1-2-面向用户的质量观" class="headerlink" title="1.2. 面向用户的质量观"></a>1.2. 面向用户的质量观</h2><ul><li>定义质量为满足用户需求的程度<ol><li>用户是谁？<ul><li>客户不一定是用户</li></ul></li><li>用户需求是否有优先级？<ul><li>很用户对软件的期望有关</li></ul></li><li>这种用户优先级对软件产品的开发过程产生什么样的影响？</li><li>怎样来度量这种质量观下的质量水平？</li></ol></li></ul><p>软件可工作，可度量：优先级高</p><h2 id="1-3-PSP质量策略"><a href="#1-3-PSP质量策略" class="headerlink" title="1.3. PSP质量策略"></a>1.3. PSP质量策略</h2><ol><li><font color="#c00000">用缺陷管理代替质量管理</font><ol><li><strong>缺陷管理的正当性</strong>：如果软件没有缺陷，其他质量属性也会比较好。</li><li>安全，隐私，交互友好等几乎都无法有效管理</li></ol></li><li>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷</li><li>各组件的高质量是通过<strong>高质量评审</strong>来实现的<ol><li><strong>测试是获取质量状态的手段</strong>，而不是提高质量的手段</li><li>经验数据：假设项目缺陷综述确定（但我们不知道），测试团队的消除缺陷能力稳定，测试的时候发现一个错误就有一个没发现的错误，所以<strong>希望暴露出来的错误越少越好</strong></li></ol></li></ol><p>重视Code Review<br>一旦缺陷到了系统级，消除成本会很高，所以要在早期消除</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F07%2F11-30-25-59455ef6704a5fcaf74d7e6dfb12abdb-20240507113024-e75a5a.png" alt="image.png"></p><h2 id="1-4-测试消除缺陷的典型流程"><a href="#1-4-测试消除缺陷的典型流程" class="headerlink" title="1.4. 测试消除缺陷的典型流程"></a>1.4. 测试消除缺陷的典型流程</h2><ol><li>发现待测程序的一个异常行为</li><li>理解程序的工作方式<ul><li>Measure twice, cut once</li></ul></li><li>调试程序，找出出错的位置，确定出错原因</li><li>确定修改方案，修改缺陷</li><li>回归测试，以确认修改有效</li></ol><h2 id="1-5-质量指标"><a href="#1-5-质量指标" class="headerlink" title="1.5. 质量指标"></a>1.5. 质量指标</h2><p>过程度量：在过程中度量出来数值，根据这个数值还有机会在过程中修正<br>结果度量：算出来就没法修改</p><h3 id="1-5-1-Yield"><a href="#1-5-1-Yield" class="headerlink" title="1.5.1. Yield"></a>1.5.1. Yield</h3><p>缺陷消除的效率，度量每个阶段在消除缺陷方面的效率，<strong>结果度量</strong></p><p>Phase Yield = 100 * 某阶段发现的缺陷个数 / （某阶段注入缺陷个数 + 进入该阶段前遗留的缺陷个数）<br>Process Yield = 100 * 第一次编译前发现的缺陷个数 / 第一次编译前注入的缺陷个数</p><p>问题：知道分子，但是不知道分母</p><p>设计、编码注入缺陷<br>评审、测试消除缺陷</p><h3 id="1-5-2-A-FR"><a href="#1-5-2-A-FR" class="headerlink" title="1.5.2. A/FR"></a>1.5.2. A/FR</h3><p><strong>质检失效时间比</strong>，过程度量</p><p>A/FR = PSP质检成本/PSP失效成本<br>设计评审时间 / 测试时间</p><p>理论上 A/FR越大，意味着质量越高，说明评审越充分<br>2.0是比较理想的值</p><h3 id="1-5-3-PQI"><a href="#1-5-3-PQI" class="headerlink" title="1.5.3. PQI"></a>1.5.3. PQI</h3><p><font color="#c00000">最全面</font></p><ul><li>5个数据的<strong>乘积</strong>，每个分量都在[0,1]内<ol><li>设计质量：设计时间应该大于编码时间<ul><li>min{设计时间/编码时间, 1}</li></ul></li><li>设计评审质量：设计评审的时间应该大于设计时间的50%<ul><li>min{(2 * 设计评审时间 / 设计时间), 1}</li></ul></li><li>代码评审质量：代码评审时间应该大于编码时间的50%<ul><li>min{(2 * 代码评审时间)/编码时间 , 1}</li></ul></li><li>代码质量：代码的编译缺陷密度应该小于10个/千行<ul><li>min{20/(编译缺陷密度 + 10), 1}</li></ul></li><li>程序质量：代码单元测试的缺陷密度应该小于5个/千行<ul><li>min{10/(单元测试缺陷密度 + 5), 1}</li></ul></li></ol></li></ul><p>123过程，45结果，在一个指标里<strong>包含了过程和结果</strong></p><p>PQI达到0.4，说明模块很不错<br>大部分人的PQI都是0</p><h3 id="1-5-4-Review-Rate"><a href="#1-5-4-Review-Rate" class="headerlink" title="1.5.4. Review Rate"></a>1.5.4. Review Rate</h3><p>评审速度：一个用于指导软件工程师有效评审的指标，<strong>过程度量</strong></p><p>高质量的评审需要软件工程师投入足够的时间进行评审</p><p>在PSP的实践中，代码评审速度小于200LOC/H，文档评审速度小于4 Page/H</p><h3 id="1-5-5-DRL"><a href="#1-5-5-DRL" class="headerlink" title="1.5.5. DRL"></a>1.5.5. DRL</h3><p>缺陷消除效率比值：不同缺陷消除手段消除缺陷的效率，<strong>结果度量</strong></p><p>计算：某个阶段每小时消除缺陷个数 / 单元测试每小时消除个数</p><p>期望：所有DRL都大于1，即单元测试缺陷个数最少</p><h3 id="1-5-6-其他质量"><a href="#1-5-6-其他质量" class="headerlink" title="1.5.6. 其他质量"></a>1.5.6. 其他质量</h3><p>个人评审和小组评审（标志重捕法）</p><p>Z：总缺陷<br>a 评审者1独立发现的缺陷<br>b 评审者2发现缺陷<br>c 评审者2发现的1发现的缺陷</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.738ex;" xmlns="http://www.w3.org/2000/svg" width="15.322ex" height="4.267ex" role="img" focusable="false" viewBox="0 -1118 6772.4 1886"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(1192.7,676)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D44D" d="M58 8Q58 23 64 35Q64 36 329 334T596 635L586 637Q575 637 512 637H500H476Q442 637 420 635T365 624T311 598T266 548T228 469Q227 466 226 463T224 458T223 453T222 450L221 448Q218 443 202 443Q185 443 182 453L214 561Q228 606 241 651Q249 679 253 681Q256 683 487 683H718Q723 678 723 675Q723 673 717 649Q189 54 188 52L185 49H274Q369 50 377 51Q452 60 500 100T579 247Q587 272 590 277T603 282H607Q628 282 628 271Q547 5 541 2Q538 0 300 0H124Q58 0 58 8Z"></path></g><g data-mml-node="mo" transform="translate(945.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1945.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g><rect width="2674.4" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3192.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(4248,0)"><g data-mml-node="mi" transform="translate(1045.7,676)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(651.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1651.4,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g><rect width="2284.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p>先评审再单元测试：先评审解决一些问题，测试时需要修复的问题少一些，需要的时间也少</p><h3 id="1-5-7-质量路径"><a href="#1-5-7-质量路径" class="headerlink" title="1.5.7. 质量路径"></a>1.5.7. 质量路径</h3><p>为了追求高质量的手段：</p><ol><li>各种测试</li><li>进入测试之前的产物质量提升<ul><li>各种评审</li></ul></li><li>评审过程度量和稳定<ul><li>评审阶段yield稳定</li></ul></li><li>质量意识和主人翁意识</li><li>个体Review的态度和稳定</li><li>诉诸设计<ul><li>终极手段，review测试都用上了还是没达到质量要求</li></ul></li><li>缺陷预防<ul><li>从这一步开始不是针对特定项目</li><li>根据历史项目制定checklist</li></ul></li><li>用户质量观——其他质量属性<ul><li>前面都是解决缺陷问题，从8开始解决用户质量观的其他质量问题</li></ul></li></ol><h1 id="2-设计与质量的关系"><a href="#2-设计与质量的关系" class="headerlink" title="2. 设计与质量的关系"></a>2. 设计与质量的关系</h1><h2 id="2-1-设计的内容"><a href="#2-1-设计的内容" class="headerlink" title="2.1. 设计的内容"></a>2.1. 设计的内容</h2><p>完整设计（可评审设计）包含以下4个方面</p><table><thead><tr><th></th><th align="left">动态信息</th><th>静态信息</th></tr></thead><tbody><tr><td>外部信息</td><td align="left">交互信息（服务、消息等）</td><td>功能（继承、类结构等）</td></tr><tr><td>内部信息</td><td align="left">行为信息（状态机）</td><td>结构信息（属性、业务逻辑等）</td></tr></tbody></table><h2 id="2-2-UML常用图"><a href="#2-2-UML常用图" class="headerlink" title="2.2. UML常用图"></a>2.2. UML常用图</h2><table><thead><tr><th></th><th>动态信息</th><th>静态信息</th></tr></thead><tbody><tr><td>外部信息</td><td>用例图，时序图</td><td>类图（只有signature，没有实现）</td></tr><tr><td>内部信息</td><td>状态机图</td><td><strong>缺失</strong></td></tr></tbody></table><h2 id="2-3-设计的层次：PSP模板"><a href="#2-3-设计的层次：PSP模板" class="headerlink" title="2.3. 设计的层次：PSP模板"></a>2.3. 设计的层次：PSP模板</h2><ol><li>操作规格模板</li><li>功能规则模板</li><li>状态规则模板</li><li>逻辑规则模板</li></ol><h2 id="2-4-设计验证方法"><a href="#2-4-设计验证方法" class="headerlink" title="2.4. 设计验证方法"></a>2.4. 设计验证方法</h2><ul><li>意义<ul><li>简单评审不足以发现复杂缺陷</li></ul></li><li>方法<ol><li>状态机验证</li><li>符号化执行验证</li><li>执行表验证</li><li>跟踪表验证</li><li>正确性验证</li></ol></li></ul><h3 id="2-4-1-状态机验证"><a href="#2-4-1-状态机验证" class="headerlink" title="2.4.1. 状态机验证"></a>2.4.1. 状态机验证</h3><p>PSP的状态机用文本描述</p><h2 id="2-5-符号化执行"><a href="#2-5-符号化执行" class="headerlink" title="2.5. 符号化执行"></a>2.5. 符号化执行</h2><p>用符号替换关键的变量</p><p>可以用来验证复杂算法，但不适合有复杂逻辑的场景</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F23%2F15-38-07-974e78db785a3ca75c18e9f637815699-20240523153806-fe65a9.png" alt="image.png"></p><h2 id="2-6-执行表验证"><a href="#2-6-执行表验证" class="headerlink" title="2.6. 执行表验证"></a>2.6. 执行表验证</h2><ul><li>主要争对伪代码：<ol><li>识别伪码程序的关键变量；</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量；</li><li>初始化被选定的变量；</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol></li></ul><p>伪代码+关键变量<br><strong>问题：只能检验一个样例</strong><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F23%2F15-41-05-d96a2bf74aac7c649fddb16cf2d896a8-20240523154105-9e1e9c.png" alt="image.png"></p><h2 id="2-7-跟踪表"><a href="#2-7-跟踪表" class="headerlink" title="2.7. 跟踪表"></a>2.7. 跟踪表</h2><p>伪代码+关键变量</p><ol><li>识别伪码程序的关键变量；</li><li>构建表格，表格左侧填入主要程序步骤（伪代码），右侧填入关键变量；</li><li>初始化被选定的变量；</li><li><strong>识别将伪码程序符号化的机会，并加以符号化</strong>；</li><li><strong>定义并且优化用例组合</strong>；</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h2 id="2-8-正确性检验"><a href="#2-8-正确性检验" class="headerlink" title="2.8. 正确性检验"></a>2.8. 正确性检验</h2><ul><li>用形式化语言描述程序，加以验证和推理<ol><li>分析和识别用例；</li><li>对于复杂伪码程序的结构，应用正确性检验的标准问题逐项加以验证；</li><li>对于不能明确判断的复杂程序结构，使用跟踪表等辅助验证</li></ol></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>03-质量属性</title>
    <link href="http://example.com/posts/7a0fc498/"/>
    <id>http://example.com/posts/7a0fc498/</id>
    <published>2024-04-23T06:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h1><h2 id="1-1-功能需求"><a href="#1-1-功能需求" class="headerlink" title="1.1. 功能需求"></a>1.1. 功能需求</h2><p>约定系统行为</p><p>功能独立于结构</p><h2 id="1-2-质量需求"><a href="#1-2-质量需求" class="headerlink" title="1.2. 质量需求"></a>1.2. 质量需求</h2><p>系统完成功能好坏程度</p><h2 id="1-3-约束"><a href="#1-3-约束" class="headerlink" title="1.3. 约束"></a>1.3. 约束</h2><p>约束是完全没有自由的设计决定，在设计之前就确定下来。</p><h1 id="2-质量属性"><a href="#2-质量属性" class="headerlink" title="2. 质量属性"></a>2. 质量属性</h1><p>质量属性：可以表述成非功能需求或者架构需求</p><h2 id="2-1-要素"><a href="#2-1-要素" class="headerlink" title="2.1. 要素"></a>2.1. 要素</h2><ul><li>六元素：作为架构设计的输入<ol><li>刺激 stimulus：到达系统时需要考虑的<strong>条件</strong><ul><li>外部的变化、输入，发出者可能是人也可能是外部系统</li></ul></li><li>源 source：产生刺激的<strong>实体</strong></li><li>响应 response：刺激到达后采取的<strong>活动</strong></li><li>响应度量 measure: 我们会对响应做可以量化的度量</li><li>工件 artifact：需求适用的<strong>整个</strong>系统或系统的一部分</li><li>环境 environment：发生刺激时系统的状况，例如过载，运行等</li></ol></li><li>设计决定：<ul><li><strong>最小单元</strong>是tactic</li><li>几个tactic可以组合成pattern/strategy</li></ul></li></ul><h2 id="2-2-可用性-Avaliability"><a href="#2-2-可用性-Avaliability" class="headerlink" title="2.2. 可用性 Avaliability"></a>2.2. 可用性 Avaliability</h2><h3 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1. 概述"></a>2.2.1. 概述</h3><p>在两次Failure之间：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F10-22-27-3fa32d7c9b3e50f3244c917f315d27cc-20240425102226-752219.png" alt="image.png"></p><p>Unabaliable(Detect-Repair-Restart)-Avaliable<br>MTTR——MTBT</p><p>MTTR: mean time to repair<br>MTBF: mean time between failures  </p><p>提高可以性：降低MTTR,提高MTBT</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.738ex;" xmlns="http://www.w3.org/2000/svg" width="25.432ex" height="4.812ex" role="img" focusable="false" viewBox="0 -1359 11241 2127"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(1235,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2041.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(3097.6,0)"><g data-mml-node="mrow" transform="translate(2462.7,676)"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(1755,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(2514,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(1051,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(1755,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(2514,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(3440.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4440.4,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(5491.4,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(6195.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(6954.4,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g></g><rect width="7903.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F05%2F13-22-19-cc71e1c4e715a1e93f8b217fad590e04-20240505132219-0989a6.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F05%2F13-22-31-eeea4718e2d42049c6bc20bc0c6cc8cd-20240505132230-f91baa.png" alt="image.png"></p><h3 id="2-2-2-可用性策略"><a href="#2-2-2-可用性策略" class="headerlink" title="2.2.2. 可用性策略"></a>2.2.2. 可用性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F10-26-26-4700e0c1f4eeecda5b7b0a03139d2c4e-20240425102625-15d799.png" alt="image.png"></p><h4 id="2-2-2-1-Detect"><a href="#2-2-2-1-Detect" class="headerlink" title="2.2.2.1. Detect"></a>2.2.2.1. Detect</h4><ol><li>Ping/Echo: Monitor主动给Server询问，Server响应。<ol><li>需要应答，带宽利用率更低</li></ol></li><li>Heartbeat: Server按照一定频率主动给Monitor发消息。</li><li>Timestamp:<ul><li>收到一系列的消息应该在时间上有先后顺序</li><li>进行常识的信息的检查，如果和常识不符合那么可能是出现了问题</li></ul></li><li>Santity Checking: 如果数据超出合理范围，认为系统出现问题</li><li>Condition Monitoring: 对运行的环境进行检查，如网络带宽、占用内存等。当环境达到某些阈值时，产生可用性问题的概率较大。</li><li>Voting: Voter之间不一致，认为系统出现问题。基本上使用奇数个Voter。<ol><li>Clone: 多个Voter完全一致，只根据结果投票。</li><li>Voter实现不同，为了防止组件的实现影响可用性。如果没有发生可用性问题，输入一致，输出也一致。</li><li>Voter实现不同，输入也不同，但是输出在合理范围内，也认为系统可用。</li></ol></li><li>Exception Delection: </li><li>Self-Test</li></ol><ul><li>Ping/Echo和Heartbeat区别：<ol><li>始终检测，heartbeat比ping/echo的带宽开销更小  </li><li>偶发请求，不需要时刻保证可用性，请求前ping/echo</li></ol></li></ul><h4 id="2-2-2-2-Recover"><a href="#2-2-2-2-Recover" class="headerlink" title="2.2.2.2. Recover"></a>2.2.2.2. Recover</h4><p>优先级：让系统恢复正常状态&gt;组件恢复</p><ol><li><p>active redundancy</p><ol><li>所有组件都并行提供服务</li></ol></li><li><p>passive redundancy</p><ol><li>主/副组件</li><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F10-46-24-5d427223ec0ef63efac9ba31a7400ddc-20240425104623-32b5a7.png" alt="image.png"></li></ol></li><li><p>spare</p></li><li><p>Exception Handling: 捕获异常，处理。和redundancy配合，主机发生异常后，启动副本。</p></li><li><p>Rollback：按照一定时间间隔，记录系统的正常状态checkpoint，发生意外时可以回滚。</p></li><li><p>Software Upgrade: 软件提供商已经解决了问题</p></li><li><p>Retry: 问题不是系统造成，而是由于环境问题，如网络不稳定，一段时间后retry可能就可用了。</p><ol><li>会设置最大retry次数</li></ol></li><li><p>Ignore faluts behavior: 把有问题的输入屏蔽掉</p><ol><li>白名单，黑名单</li></ol></li><li><p>degradation: 服务水平降级</p></li><li><p>reconfiguration: 系统重新配置。</p><ol><li>基于微服务的系统，每个微服务有众多实例</li></ol></li><li><p>Shadow：之前发生过错误的组件会有一段时间的shadow mode，如果出现问题立刻恢复。</p><ol><li>组件恢复之后有一段监视期，防止再次出现问题。</li></ol></li><li><p>State re-synchronisation</p><ol><li>被动和主动冗余策略要求要恢复的组件在恢复服务之前对其状态进行升级。</li></ol></li><li><p>Escalating restart：扩大重启范围，但先从最小范围开始。只重启出现错误的组件可能无法解决问题。</p></li><li><p>Non-Stop Forwarding：设备发生主备切换时最大程度地减少中断时间</p></li></ol><h4 id="2-2-2-3-Prevent"><a href="#2-2-2-3-Prevent" class="headerlink" title="2.2.2.3. Prevent"></a>2.2.2.3. Prevent</h4><p>目的：延长系统正常运行的时间MTBF。</p><ol><li>Removal from service：把带病工作的组件尽早替换掉</li><li>Transaction：2pc</li><li>Predictive Model：使用基于以往数据的概率模型预测</li><li>Exception Prevention：在异常捕获上提供更高级的处理能力</li><li>Increase Competence Set：对可能会出现faults的原因进行针对性设计</li></ol><h2 id="2-3-互操作性-Interoperability"><a href="#2-3-互操作性-Interoperability" class="headerlink" title="2.3. 互操作性 Interoperability"></a>2.3. 互操作性 Interoperability</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1. 概述"></a>2.3.1. 概述</h3><ul><li><p>互操作性：”组件和组件之间相互操作，交换数据，都通过interface完成“的程度</p></li><li><p>要素</p><ol><li>Discovery：服务注册，和哪个对象互操作，怎么查找。<ol><li>location</li><li>identity</li><li>interface of service</li></ol></li><li>Handling of response：<ol><li>reports back to the requester</li><li>sends its response on to another system</li><li>broadcasts</li></ol></li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-27-23-e24963fb38ef335e5a0929875103ee2d-20240425112722-1f7428.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-28-49-04751e4f3259e6415b58535b09e68d81-20240425112848-9dce66.png" alt="image.png"></p><h3 id="2-3-2-互操作性策略"><a href="#2-3-2-互操作性策略" class="headerlink" title="2.3.2. 互操作性策略"></a>2.3.2. 互操作性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-30-18-565bdb570d67ae4e40a0d211c005114a-20240425113017-9a2720.png" alt="image.png"></p><h4 id="2-3-2-1-Locate"><a href="#2-3-2-1-Locate" class="headerlink" title="2.3.2.1. Locate"></a>2.3.2.1. Locate</h4><ol><li>Discover Service：服务要在注册中心注册才能被找到</li></ol><h4 id="2-3-2-2-Manage-Interfaces"><a href="#2-3-2-2-Manage-Interfaces" class="headerlink" title="2.3.2.2. Manage Interfaces"></a>2.3.2.2. Manage Interfaces</h4><ol><li>Orchestrate: 工作流编排，通过编排不同服务提供数据交换能力</li><li>Tailor Interface：在interface上增加和删减一些能力<ol><li>e.g.区分付费用户和免费用户</li></ol></li></ol><h2 id="2-4-可修改性-Modifiability"><a href="#2-4-可修改性-Modifiability" class="headerlink" title="2.4. 可修改性 Modifiability"></a>2.4. 可修改性 Modifiability</h2><h3 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1. 概述"></a>2.4.1. 概述</h3><p>设计的时候就要考虑未来的变化。</p><p>预先针对变化设计，还是变化发生之后再去修改，取决于成本。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-39-58-0264100979bdb60ba4f3c304068a8f63-20240425113957-842a8a.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-40-36-bcbb77559343010d9f84807f5c36d81a-20240425114035-2af04a.png" alt="image.png"></p><h3 id="2-4-2-可修改性策略"><a href="#2-4-2-可修改性策略" class="headerlink" title="2.4.2. 可修改性策略"></a>2.4.2. 可修改性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F11-42-54-1659105ca675aaf8586ad10d242eaa00-20240425114253-47bd1d.png" alt="image.png"></p><ol><li>Reduce Size of Moudle：减小模块的规模</li><li>Increase Cohesion：提高内聚<ol><li>语义相近的部分往往需要同时修改</li></ol></li><li>Reduce Coupling<ol><li>Encapsulate：封装可能的变化</li><li>Use an Intermediary：使用中间件</li><li>Restrict Dependencies：<strong>使用分层结构简化依赖关系</strong></li><li>Refactor：不是针对系统内部重构，是架构层面的重构，把责任放到最合适的地方</li><li>Abstract Common Services：把相似的服务放在一起，修改对外参数</li></ol></li><li>Defer Binding：推迟绑定时间<ol><li>有越多的时间确定关系</li><li>但是也会对其他质量属性造成负面影响</li></ol></li></ol><h2 id="2-5-性能-Performance"><a href="#2-5-性能-Performance" class="headerlink" title="2.5. 性能 Performance"></a>2.5. 性能 Performance</h2><p>系统满足时间需求的能力</p><ul><li>决定性能的时间<ol><li>processing time</li><li>blocked time</li></ol></li></ul><h3 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1. 概述"></a>2.5.1. 概述</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-05-49-7c9ec4af005d63037d71db0ab770cd75-20240430140546-cb09ff.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-06-01-e431136370746160356a85aa199757e1-20240430140558-cf1dec.png" alt="image.png"></p><h3 id="2-5-2-性能策略"><a href="#2-5-2-性能策略" class="headerlink" title="2.5.2. 性能策略"></a>2.5.2. 性能策略</h3><p>减少任务<br>增加处理能力</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-09-32-65db085871dd299a4e9c055fd3bd4a13-20240430140930-acc202.png" alt="image.png"></p><ul><li>demand side<ol><li>降低采样频率</li><li>限制事件响应，如果系统来不及响应，把事件放入等待队列</li><li>优先级</li><li>使用中间层，提高资源利用效率</li></ol></li><li>resource side<ol><li>提升资源</li><li>并发</li><li>复制多个实例，使用负载均衡器把任务分配到实例上</li><li>复制多份数据，缓存、数据冗余</li></ol></li></ul><h2 id="2-6-安全-Security"><a href="#2-6-安全-Security" class="headerlink" title="2.6. 安全 Security"></a>2.6. 安全 Security</h2><h3 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1. 概述"></a>2.6.1. 概述</h3><p>保护系统不被未授权的访问影响</p><ul><li>特征<ol><li>Confidentiality：数据和服务不能被未授权访问</li><li>Integrity：数据和服务不能被未授权操作</li><li>Availability：系统对合法用户可以正常使用</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-31-07-341098559fc7f205a8d7d451575fd08f-20240430143105-c26ce4.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-31-20-8a217de96bc3f58a32aa3a566258e208-20240430143118-a33992.png" alt="image.png"></p><h3 id="2-6-2-安全性策略"><a href="#2-6-2-安全性策略" class="headerlink" title="2.6.2. 安全性策略"></a>2.6.2. 安全性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F14-41-22-5a25f3505c77c7d8064f7c26e4f317d6-20240430144120-1f1b76.png" alt="image.png"></p><p>与可用性区别：检测到攻击时，还处在攻击状态，系统不一定失效</p><ul><li>Detect<ol><li>根据历史攻击的特征，检测识别攻击</li><li>检测服务拒绝<strong>DoS attack</strong>，白名单/黑名单</li><li>验证消息合法性</li><li>检测消息延迟</li></ol></li><li>Resist<ol><li>用户识别，宣称自己是谁</li><li>用户身份认证，看用户是不是真的那个人<ul><li>e.g.手机号是identity, 验证码是authentication</li></ul></li><li>用户权限认证</li><li>限制访问，过滤从外部到系统内部的访问</li><li>限制对外暴露</li><li>加密数据</li><li>分离数据，把敏感数据和公告访问数据分开</li><li>改变默认设置</li></ol></li><li>React<ol><li>撤回访问，限制攻击能访问的范围</li><li>系统上锁停止服务，攻击和普通用户都不能访问<ul><li>e.g.密码错误超过十次，对设备上锁</li></ul></li><li>通知使用者</li></ol></li><li>Recover</li></ul><h2 id="2-7-可测试性-Testability"><a href="#2-7-可测试性-Testability" class="headerlink" title="2.7. 可测试性 Testability"></a>2.7. 可测试性 Testability</h2><h3 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1. 概述"></a>2.7.1. 概述</h3><p>系统是不是容易被测试，把问题暴露出来的能力<br>系统内部的质量属性，用户并不会关心</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F15-12-29-7ed103a346d781a0f4deb1e145d71ff9-20240430151226-6f3be5.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F15-12-42-d203be97b5b9d8818765ce660d9b9c86-20240430151240-b84085.png" alt="image.png"></p><h3 id="2-7-2-可测试性策略"><a href="#2-7-2-可测试性策略" class="headerlink" title="2.7.2. 可测试性策略"></a>2.7.2. 可测试性策略</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F15-16-05-46f1cef5a5879bd7ee25b52984c34204-20240430151602-ac435a.png" alt="image.png"></p><h2 id="2-8-易用性-Usability"><a href="#2-8-易用性-Usability" class="headerlink" title="2.8. 易用性 Usability"></a>2.8. 易用性 Usability</h2><p>外部质量属性</p><p>系统使用学习的难易程度</p><ul><li>层次<ol><li><strong>学习</strong>软件使用</li><li><strong>高效</strong>地使用系统</li><li>最小化<strong>出错</strong>的影响</li><li>让系统<strong>适应</strong>用户的需要</li><li>提升用户使用系统时的<strong>信心和满足感</strong></li></ol></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>06-数据库设计（一致性保障）</title>
    <link href="http://example.com/posts/30ebc364/"/>
    <id>http://example.com/posts/30ebc364/</id>
    <published>2024-04-22T06:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据库范式"><a href="#1-数据库范式" class="headerlink" title="1. 数据库范式"></a>1. 数据库范式</h1><ol><li>1NF：属性的原子性  </li><li>2NF：属性的主键完全依赖  </li><li>3NF：不存在传递函数依赖  <ul><li>冗余最小化</li></ul></li><li>BCNF、4NF、5NF（完美范式）</li></ol><h1 id="2-数据库反范式"><a href="#2-数据库反范式" class="headerlink" title="2. 数据库反范式"></a>2. 数据库反范式</h1><p>规范化的结果是一个结构上一致，且拥有最小冗余的结构，但未必是性能最优的设计。</p><ul><li>反范式本质是——考虑引入可控制的冗余<ol><li>实现更复杂，需要手动控制冗余</li><li>减低灵活性</li><li><strong>加快读取</strong>，降低更新</li></ol></li><li>主要动作：<strong>复制</strong></li><li><font color="#c00000">核心目标</font>：<strong>减低连接次数</strong>，提高查询效率</li></ul><h1 id="3-数据库反范式模式"><a href="#3-数据库反范式模式" class="headerlink" title="3. 数据库反范式模式"></a>3. 数据库反范式模式</h1><ol><li>合并1:1关系</li><li>复制1:*关系的非Key、FK及值</li><li>复制*:*关系的属性</li><li>引入重复组</li><li>创建提取临时表</li></ol><h2 id="3-1-合并1-1关系"><a href="#3-1-合并1-1关系" class="headerlink" title="3.1. 合并1:1关系"></a>3.1. 合并1:1关系</h2><p>部分参与会大量引入空值，处理复杂</p><h2 id="3-2-复制1-关系的非Key、FK及值"><a href="#3-2-复制1-关系的非Key、FK及值" class="headerlink" title="3.2. 复制1:*关系的非Key、FK及值"></a>3.2. 复制1:*关系的非Key、FK及值</h2><p>多代码表的连接基本上都是通过<strong>复制代码值</strong>，而不是外键id，来减少表连接</p><p>适用于，代码表的值比较固定，值的数量不多</p><h2 id="3-3-复制-关系的属性"><a href="#3-3-复制-关系的属性" class="headerlink" title="3.3. 复制*:*关系的属性"></a>3.3. 复制*:*关系的属性</h2><h2 id="3-4-引入重复组"><a href="#3-4-引入重复组" class="headerlink" title="3.4. 引入重复组"></a>3.4. 引入重复组</h2><p>4NF要求</p><ul><li>地址，电话</li><li>静态，数量小</li></ul><p>e.g.：淘宝，选择收获地址，在customer主表里加一列常用地址。当用户点击更多地址时，才查询用户的全部地址。</p><h2 id="3-5-创建提取临时表"><a href="#3-5-创建提取临时表" class="headerlink" title="3.5. 创建提取临时表"></a>3.5. 创建提取临时表</h2><p>静态，时间切片，不是实时数据<br>实时计算，物化视图，代价极大<br>不推荐</p><h1 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4. 数据库设计"></a>4. 数据库设计</h1><p>基本满足3NF，可能产生多种设计结果</p><h2 id="4-1-树状结构"><a href="#4-1-树状结构" class="headerlink" title="4.1. 树状结构"></a>4.1. 树状结构</h2><p>对象类型相同，而对象的层次可变，其关系就应该被建模为树结构</p><p>树状结构复杂度在于：树的访问</p><ul><li>实际实现：<ol><li>邻接模型</li><li>物化路径模型</li><li>嵌套集合模型</li></ol></li></ul><h3 id="4-1-1-临接模型"><a href="#4-1-1-临接模型" class="headerlink" title="4.1.1. 临接模型"></a>4.1.1. 临接模型</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-34-38-06846e7ba7d8cee19acef8e6c934d650-20240506143438-c20582.png" alt="image.png"></p><p>满足单父节点</p><ul><li>T(id,pid,attr…)<ul><li>id标记当前节点，pid标记父节点</li></ul></li><li>问题：<ol><li>会丢失子节点的顺序</li><li><strong>不符合归一化原则（一事，一地，一次）</strong>，无法通过数据库保证一致性<ul><li>pid存在多处修改也需要多次</li><li>insert时数据库无法检查是否是有圈，无法检查是树而不是图，需要再应用系统检查</li><li>delete复杂</li></ul></li><li>要找所有子节点很复杂</li></ol></li></ul><h3 id="4-1-2-物化路径模型"><a href="#4-1-2-物化路径模型" class="headerlink" title="4.1.2. 物化路径模型"></a>4.1.2. 物化路径模型</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F06%2F14-33-53-c3e2181ff81f828c5e79ba5b6a54a2ad-20240506143352-43562c.png" alt="image.png"></p><ul><li>T(m_path,attr…)把路径存成一个字段</li></ul><ol><li>解决了子节点顺序问题</li><li>insert时更容易控制</li><li>找所有子节点简单，只需要字符串匹配</li><li>无法满足归一化，父节点路径存在多个子节点里，发生修改还是要多次修改</li><li>不容易变成图</li><li>delete数据还是要手动处理</li></ol><p>路径id是字符串，处理性能差<br>读写性能最平衡</p><h3 id="4-1-3-嵌套集合模型"><a href="#4-1-3-嵌套集合模型" class="headerlink" title="4.1.3. 嵌套集合模型"></a>4.1.3. 嵌套集合模型</h3><p>T(left_num,right_num,attr…)，基于集合论，在[left,num]内的都是该节点的子节点</p><ol><li>可以保存子节点顺序</li><li>delete节点，可以自动缺省处理</li><li><strong>insert要修改很多，所有右边的节点都要改</strong></li><li>是归一化模型</li></ol><p>现实里使用往往更新比较少，而且保留range</p><h3 id="4-1-4-闭包表模型"><a href="#4-1-4-闭包表模型" class="headerlink" title="4.1.4. 闭包表模型"></a>4.1.4. 闭包表模型</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F08%2F10-34-24-6ea9584f1a11e2c1867bdc5693f26d17-20240508103424-84e55e.png" alt="image.png"></p><ul><li>整棵树在两张表里记录，节点表和节点关系表。</li><li>NodeRelation(id, ancester, descendant, distance)，定义了所有节点之间的关系</li></ul><p>闭包模型不仅可以处理树也可以处理图，可读性更差，通用性和扩展性强</p><p>场景：论坛回帖，典型的树状结构</p><h2 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2. 查询"></a>4.2. 查询</h2><h3 id="4-2-1-自顶向下"><a href="#4-2-1-自顶向下" class="headerlink" title="4.2.1. 自顶向下"></a>4.2.1. 自顶向下</h3><p>查询所有子节点，缩进排序</p><ol><li>邻接模型<ol><li>oracle的connect by,mysql递归查询</li><li>手动union，在一个查询中多次连接，前提是知道深度</li><li>单独设计一张关系表，T(id,pid,distance)，保存节点到所有父节点的距离</li></ol></li><li>物化路径模型<ol><li>字符串前缀比较，深度就是<code>.</code>的个数</li></ol></li><li>嵌套集合模型<ol><li>遍历整张表，只要在[left,right]内，一定是子节点。但是缩排很复杂。</li></ol></li></ol><p>效率指标： t/s，每秒做了几个事务，兼顾容量和时间</p><p>资源消耗：from表连接&gt;字符串处理&gt;数值比较</p><h3 id="4-2-2-自底向上查询"><a href="#4-2-2-自底向上查询" class="headerlink" title="4.2.2. 自底向上查询"></a>4.2.2. 自底向上查询</h3><ol><li>邻接模型<ul><li>connect by, 递归</li></ul></li><li>物化路径</li><li>嵌套集合<ol><li>动态计算深度仍然是问题，计算量大</li><li>可以按照left_num排序</li></ol></li></ol><h3 id="4-2-3-问题"><a href="#4-2-3-问题" class="headerlink" title="4.2.3. 问题"></a>4.2.3. 问题</h3><p>select 投影，只做一次<br>where 选择，对查询时遍历的每一条记录都做一次，如果在where里写复杂函数代价很大</p><ol><li>物化路径不该是KEY，既是有唯一性</li><li>物化路径和邻接模型等价使用时，不该按时任何兄弟父子节点的排序</li><li>所选择的编码方式不需要完全中立</li></ol><h2 id="4-3-效率比较"><a href="#4-3-效率比较" class="headerlink" title="4.3. 效率比较"></a>4.3. 效率比较</h2><ol><li>邻接模型<ul><li>简单，成熟，深度是最大障碍</li></ul></li><li>物化路径<ul><li>读写平很，稳定的输出</li></ul></li><li>嵌套集合<ul><li>读取频率远高于修改频率，只在乎上下关系，不在乎层级</li></ul></li><li>闭包表模型<ul><li>额外表存储，维护细节和成本高，查询效率优秀</li></ul></li></ol><h2 id="4-4-其他查询要求"><a href="#4-4-其他查询要求" class="headerlink" title="4.4. 其他查询要求"></a>4.4. 其他查询要求</h2><h3 id="4-4-1-对保存叶节点的值做聚合"><a href="#4-4-1-对保存叶节点的值做聚合" class="headerlink" title="4.4.1. 对保存叶节点的值做聚合"></a>4.4.1. 对保存叶节点的值做聚合</h3><p>邻接模型的connect by无法使用，只能递归<br>物化路径比较简单</p><h3 id="4-4-2-物料单问题"><a href="#4-4-2-物料单问题" class="headerlink" title="4.4.2. 物料单问题"></a>4.4.2. 物料单问题</h3><p>任何一个节点都可能包含多个子节点，也可能有多个父节点<br><strong>递归难以避免</strong></p><ul><li>多叉树<ol><li>复杂的层次模型</li><li>每个节点都有多父节点，多子节点</li><li>边列表结构库设计（Edge List），也是图结构的基础数据库设计</li><li>也是闭包模型的扩展，具体应用中需要增加一些实体</li></ol></li></ul><p>原子化实体和组合化实体要分开</p><ul><li>例：计算分散在各层的百分比<ul><li>A(aa 20%,bb,cc,B 30%)</li><li>B(aa 50%,bb,cc)</li><li>计算A中aa含量：20% + 30% *  50%</li></ul></li></ul><h2 id="树状结构的问题"><a href="#树状结构的问题" class="headerlink" title="树状结构的问题"></a>树状结构的问题</h2><p>要有条件地控制深度，否则都会很慢</p><h1 id="5-递归SQL语法"><a href="#5-递归SQL语法" class="headerlink" title="5. 递归SQL语法"></a>5. 递归SQL语法</h1><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte_name (column_list) <span class="keyword">AS</span> (</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>初始查询</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>递归查询</span><br><span class="line">)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>主查询</span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> cte_name</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure></div><p>引入层次</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>05-Linux MultiCore Programming</title>
    <link href="http://example.com/posts/e2194f69/"/>
    <id>http://example.com/posts/e2194f69/</id>
    <published>2024-04-22T03:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux进程"><a href="#1-Linux进程" class="headerlink" title="1. Linux进程"></a>1. Linux进程</h1><h2 id="1-1-exec"><a href="#1-1-exec" class="headerlink" title="1.1. exec"></a>1.1. exec</h2><ol><li>exec：直接执行新的程序</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ..., (<span class="type">char</span> *)<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg0, ..., (<span class="type">char</span> *)<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ..., (<span class="type">char</span> *)<span class="number">0</span>, <span class="type">char</span> *<span class="type">const</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span><br></pre></td></tr></table></figure></div><h2 id="1-2-fork"><a href="#1-2-fork" class="headerlink" title="1.2. fork"></a>1.2. fork</h2><ol><li>fork：创建一个一样的新进程</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div><p>使用：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork()==<span class="number">0</span>)</span><br><span class="line">{子进程执行的代码段；}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{父进程执行的代码段；}</span><br></pre></td></tr></table></figure></div><h2 id="1-3-进程退出方式"><a href="#1-3-进程退出方式" class="headerlink" title="1.3. 进程退出方式"></a>1.3. 进程退出方式</h2><ol><li>正常退出<ol><li>return from main</li><li>call exit 库函数（有终止处理）</li><li>call _exit 系统调用（立即退出）</li><li>线程终止</li></ol></li><li>异常退出<ol><li>call abort</li><li>被信号取消</li><li>线程被取消</li></ol></li></ol><p>exit：最终会调用_exit，但之前会有一堆终止处理程序(aexit function)</p><h2 id="1-4-Process-resources"><a href="#1-4-Process-resources" class="headerlink" title="1.4. Process resources"></a>1.4. Process resources</h2><p>每个进程都有一个进程描述符</p><h2 id="1-5-wait-waitpid"><a href="#1-5-wait-waitpid" class="headerlink" title="1.5. wait & waitpid"></a>1.5. wait &amp; waitpid</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> * status)</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span>  pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span></span><br></pre></td></tr></table></figure></div><ul><li><p>作用</p><ol><li>父进程等待子进程结束</li><li>回收僵尸进程</li></ol></li><li><p>结果</p><ol><li>阻塞</li><li>立即返回</li><li>出错</li></ol></li><li><p>waitpid</p><ol><li>指定pid</li><li><strong>非阻塞</strong></li><li>waitpid的pid参数<ol><li>pid==-1：对应wait</li><li>pid&gt; 0: 指定pid</li><li>pid==0：指定父进程的group</li><li>pid&lt;0：指定group id，等待对应组里的进程</li></ol></li></ol></li></ul><h2 id="1-6-signal"><a href="#1-6-signal" class="headerlink" title="1.6. signal"></a>1.6. signal</h2><p>进程之间通信</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal.h</span><br></pre></td></tr></table></figure></div><h3 id="1-6-1-信号"><a href="#1-6-1-信号" class="headerlink" title="1.6.1. 信号"></a>1.6.1. 信号</h3><p>SIGKILL：终止，不能被捕获或忽略<br>SIGINT：终端中断符 , 等价于ctrl + c<br>SIGTERM：终止（kill发出的默认系统终止信号），可以改</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">//Returned Value: the previous handler if success, SIG_ERR if error</span></span><br></pre></td></tr></table></figure></div><h3 id="1-6-2-可靠性"><a href="#1-6-2-可靠性" class="headerlink" title="1.6.2. 可靠性"></a>1.6.2. 可靠性</h3><ul><li>信号可靠性<ol><li>连续重复信号能不能收到<ol><li>可能会丢失，SIG对应的int值较大对应早期Linux版本不可靠，int值较小对应早期版本;后期版本有可靠机制</li></ol></li><li>阻塞信号</li><li>复位机制</li></ol></li></ul><h3 id="1-6-3-发信号"><a href="#1-6-3-发信号" class="headerlink" title="1.6.3. 发信号"></a>1.6.3. 发信号</h3><ul><li><strong>kill</strong>: send signal to a process</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 if success, -1 if failure pid:取值</span></span><br></pre></td></tr></table></figure></div><ul><li><strong>raise</strong>: send a signal to the <strong>current process</strong></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 if success, -1 if failure</span></span><br></pre></td></tr></table></figure></div><ul><li>alarm: set an alarm clock for delivery of a signal<ol><li>每个进程只能有一个闹钟</li><li>可以用来做超时处理</li></ol></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">//Returned value: 0, or the number of seconds remaining of previous alarm </span></span><br><span class="line"><span class="comment">//SIGALRM</span></span><br></pre></td></tr></table></figure></div><ul><li>pause: wait for a signal<ol><li>挂起，等到有信号来才执行</li><li>e.g. CTRL+Z的实现</li></ol></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//Returned value: -1, errno is set to be EINTR</span></span><br></pre></td></tr></table></figure></div><hr><ul><li>例子：</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sig_alrm</span><span class="params">(<span class="type">int</span> signo)</span>{</span><br><span class="line"><span class="built_in">printf</span>(“alarm received\n”);</span><br><span class="line">}</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nsecs)</span> {</span><br><span class="line"><span class="keyword">if</span> ( signal(SIGALARM, sig_alrm) == SIG_ERR)</span><br><span class="line"><span class="keyword">return</span>(nsecs);</span><br><span class="line">alarm(nsecs); <span class="comment">/* start the timer */</span></span><br><span class="line">pause(); <span class="comment">/*next caught signal wakes us up*/</span></span><br><span class="line"><span class="keyword">return</span>(alarm(<span class="number">0</span>) ); <span class="comment">/*turn off timer, return unslept time */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="1-6-4-可靠信号"><a href="#1-6-4-可靠信号" class="headerlink" title="1.6.4. 可靠信号"></a>1.6.4. 可靠信号</h3><ul><li>信号集</li></ul><p>给一个信号注册一个结构体，而不是直接注册处理函数</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">//Return value: 0 if success, -1 if error</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">//Return value: 1 if true, 0 if false</span></span><br></pre></td></tr></table></figure></div><hr><ul><li>sigprocmask：检测或更改(或两者)进程的信号掩码</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">//Return Value: 0 is success, -1 if failure</span></span><br></pre></td></tr></table></figure></div><ul><li>参数“<strong>how</strong>”决定对信号掩码的操作<ol><li>SIG_BLOCK: 将set中的信号<strong>添加</strong>到信号掩码(并集)</li><li>SIG_UNBLOCK: 从信号掩码中<strong>去掉</strong>set中的信号(差集)</li><li>SIG_SETMASK: 把信号掩码<strong>设置为</strong>set中的信号</li></ol></li><li>在sigprocmask调用后任何未阻塞并且pending的信号，在函数返回前，至少有一个信号会送达进程</li><li>例外: SIGKILL, SIGSTOP</li></ul><hr><ul><li>sigpending: 返回当前未决的信号集</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 is success, -1 if failure</span></span><br></pre></td></tr></table></figure></div><hr><ul><li><strong>sigaction</strong>：检查或修改与指定信号的关联处理动作</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">//Returned Value: 0 is success, -1 if failure)</span></span><br></pre></td></tr></table></figure></div><ul><li>struct sigaction成员：</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">handler_t</span> sa_handler; <span class="comment">/* addr of signal handler, or SIG_IGN, </span></span><br><span class="line"><span class="comment">or SIG_DEL */</span></span><br><span class="line"><span class="type">sigset_t</span> sa_mask; <span class="comment">/* additional signals to block */</span></span><br><span class="line"><span class="type">int</span> sa_flags; <span class="comment">/* signal options */</span></span><br></pre></td></tr></table></figure></div><hr><ul><li><code>sigsuspend</code>：使用临时信号替代信号掩码，在捕获一个信号或发生终止该进程的信号前，进程挂起</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> sigset *sigmask)</span>;</span><br><span class="line"><span class="comment">//Returned value: -1, errno is set to be EINTR</span></span><br></pre></td></tr></table></figure></div><h2 id="1-7-可重入函数"><a href="#1-7-可重入函数" class="headerlink" title="1.7. 可重入函数"></a>1.7. 可重入函数</h2><ul><li>可重入：可以被打断的函数</li><li>不可重入函数：<ol><li>系统资源</li><li>全局变量</li><li>使用静态数据结构</li><li>调用malloc或者free</li><li>标准IO函数</li></ol></li></ul><h1 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2. 共享内存"></a>2. 共享内存</h1><ol><li>共享内存是内核为进程创建的一个特殊内存段，它可连接(attach)到自己的地址空间，也可以连接到其它进程的地址空间</li><li><strong>最快的进程间通信方式</strong></li><li>不提供任何同步功能</li></ol><h2 id="2-1-mmap-munmap"><a href="#2-1-mmap-munmap" class="headerlink" title="2.1. mmap/munmap"></a>2.1. mmap/munmap</h2><p>把文件/设备，映射/取消映射到内存。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr,<span class="type">size_t</span> length,<span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span></span><br></pre></td></tr></table></figure></div><ul><li>flags<ol><li>MAP_SHARED</li><li>MAP_ANONYMOUS：忽略掉fd，虚拟了一个文件</li><li>MAP_PRIVATE：只有当前进程可以写</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F29%2F10-49-59-a380e5e4559554e6c4bd764939c0322a-20240429104958-5ac065.png" alt="image.png"></p><h2 id="2-2-shared-memory-system-calls"><a href="#2-2-shared-memory-system-calls" class="headerlink" title="2.2. shared memory system calls"></a>2.2. shared memory system calls</h2><h3 id="2-2-1-申请共享内存"><a href="#2-2-1-申请共享内存" class="headerlink" title="2.2.1. 申请共享内存"></a>2.2.1. 申请共享内存</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> size, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>key：区分共享内存。</li><li>flag：<ol><li>0：必须找</li><li>IPC_CREAT：找不到就创建</li><li>IPC_EXCL：只创建不找</li></ol></li></ol><h3 id="2-2-2-共享内存地址映射"><a href="#2-2-2-共享内存地址映射" class="headerlink" title="2.2.2. 共享内存地址映射"></a>2.2.2. 共享内存地址映射</h3><p>使用共享内存的时候也需要map，和文件类似:</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">void</span> *addr, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>addr</li><li>flag: <ol><li>SHM_RND：可读可写</li><li>SHM_RDONLY：只读</li></ol></li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_memory = shmat(shmid, (<span class="type">void</span> *)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shared_memory == (<span class="type">void</span> *)<span class="number">-1</span>) {</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmat failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="2-2-3-共享内存解除映射"><a href="#2-2-3-共享内存解除映射" class="headerlink" title="2.2.3. 共享内存解除映射"></a>2.2.3. 共享内存解除映射</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">void</span> * addr)</span>;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shmdt(shared_memory) == <span class="number">-1</span>) {</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmdt failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="2-2-4-共享内存释放"><a href="#2-2-4-共享内存释放" class="headerlink" title="2.2.4. 共享内存释放"></a>2.2.4. 共享内存释放</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>cmd：<ol><li>IPC_STAT：获取共享内存属性</li><li>IPC_SET：为共享内存设置属性</li><li><strong>IPC_RMID：释放</strong>，buf参数</li></ol></li></ol><p>e.g.:</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) {</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"shmctl(IPC_RMID) failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h1 id="3-POSIX-thread"><a href="#3-POSIX-thread" class="headerlink" title="3. POSIX thread"></a>3. POSIX thread</h1><ul><li>和普通thread区别<ol><li>POSIX thread不是系统调用，是Linux下的标准库</li><li>Linux下可以用clone创建thread，但是比较复杂很少用</li></ol></li></ul><p>线程共享地址空间，轻量级</p><ul><li>pthread library<ul><li>/usr/lib/libpthread.so, /usr/lib/libpthread.a</li></ul></li><li>pthread.h header file<ul><li>/usr/include/pthread.h</li></ul></li><li>Compiler options<ul><li>gcc thread.c –o thread –lpthread</li><li>-l: link，链接本地二进制码</li></ul></li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -lpthread</span><br><span class="line">//libpthread.so,libpthread.a</span><br></pre></td></tr></table></figure></div><h2 id="3-1-命名"><a href="#3-1-命名" class="headerlink" title="3.1. 命名"></a>3.1. 命名</h2><p>pthread下的所有函数都以<code>pthread_</code>开头</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F29%2F11-31-51-7c6da78deef9bd2d44a457253224f8cc-20240429113150-2588f6.png" alt="image.png"></p><h2 id="3-2-线程操作"><a href="#3-2-线程操作" class="headerlink" title="3.2. 线程操作"></a>3.2. 线程操作</h2><h3 id="3-2-1-生命周期"><a href="#3-2-1-生命周期" class="headerlink" title="3.2.1. 生命周期"></a>3.2.1. 生命周期</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F29%2F11-40-13-c1cd41e1edb023fd1ea6491d58ea4140-20240429114012-6287c9.png" alt="image.png"></p><h3 id="3-2-2-pthread-create"><a href="#3-2-2-pthread-create" class="headerlink" title="3.2.2. pthread_create"></a>3.2.2. pthread_create</h3><p>创建线程</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">pthread_t</span> *thread, </span></span><br><span class="line"><span class="params"><span class="type">pthread_attr_t</span> *attr, </span></span><br><span class="line"><span class="params"><span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), </span></span><br><span class="line"><span class="params"><span class="type">void</span> *arg)</span>；</span><br></pre></td></tr></table></figure></div><ol><li>thread：输出线程ID</li><li>attr：创建线程的时候可以传属性，默认可以传<code>NULL</code></li><li><code>start_routine</code>：线程的入口函数</li><li>arg</li></ol><h3 id="3-2-3-pthread-exit"><a href="#3-2-3-pthread-exit" class="headerlink" title="3.2.3. pthread_exit"></a>3.2.3. pthread_exit</h3><p>结束线程</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> * retval)</span>;</span><br></pre></td></tr></table></figure></div><p>可以在线程里调用<code>pthread_exit</code>，也可以在线程<code>main</code>函数<code>return</code></p><h3 id="3-2-4-pthread-join"><a href="#3-2-4-pthread-join" class="headerlink" title="3.2.4. pthread_join"></a>3.2.4. pthread_join</h3><ul><li>等待另一个线程结束<ul><li>pthread库并没有限制只能主线程join子线程，但是推荐</li></ul></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> th, <span class="type">void</span> **thread_return)</span>;</span><br></pre></td></tr></table></figure></div><ol><li><code>th</code>：需要等待的线程</li><li><code>thread_return</code>：指向线程返回值的指针<ul><li>返回值是<code>void*</code></li></ul></li></ol><h3 id="3-2-5-pthread-detach"><a href="#3-2-5-pthread-detach" class="headerlink" title="3.2.5. pthread_detach"></a>3.2.5. pthread_detach</h3><ul><li>线程自己回收自己的资源，不和任何线程做join</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> th)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="3-3-线程同步"><a href="#3-3-线程同步" class="headerlink" title="3.3. 线程同步"></a>3.3. 线程同步</h2><h3 id="3-3-1-信号量"><a href="#3-3-1-信号量" class="headerlink" title="3.3.1. 信号量"></a>3.3.1. 信号量</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> </span></span><br><span class="line"><span class="params">value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">//P</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">//V</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;<span class="comment">// 释放</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; <span class="comment">//不阻塞的P</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure></div><ul><li>sem_init参数<ol><li>sem：指向信号量指针</li><li>pshared：是否共享</li><li>value：初始值</li></ol></li></ul><h3 id="3-3-2-互斥量"><a href="#3-3-2-互斥量" class="headerlink" title="3.3.2. 互斥量"></a>3.3.2. 互斥量</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> </span></span><br><span class="line"><span class="params"><span class="type">pthread_mutexattr_t</span> *mutexattr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></div><p>互斥量里只有一份资源，内部是Boolean变量。</p><h3 id="3-3-3-条件变量"><a href="#3-3-3-条件变量" class="headerlink" title="3.3.3. 条件变量"></a>3.3.3. 条件变量</h3><p> 等待某个变量满足条件，和<strong>互斥量一起使用</strong></p><h4 id="3-3-3-1-初始化"><a href="#3-3-3-1-初始化" class="headerlink" title="3.3.3.1. 初始化"></a>3.3.3.1. 初始化</h4><ol><li>静态初始化<code>pthread_cond_t convar = PTHREAD_COND_INITIALIZER;</code></li><li><code>pthread_cond_init()</code></li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destory</span><span class="params">(<span class="type">pthread_cond_t</span> cond)</span>;</span><br></pre></td></tr></table></figure></div><h4 id="3-3-3-2-操作"><a href="#3-3-3-2-操作" class="headerlink" title="3.3.3.2. 操作"></a>3.3.3.2. 操作</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> mutex)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> cond)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> cond)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>等待：等到条件变量被通知或广播<ul><li><strong>等待时会unlock互斥量（原子操作）</strong></li><li>当重新开始执行，会lock互斥量</li></ul></li><li>通知：随机唤醒<ol><li>调用时互斥量必须是被加锁的，signal会释放互斥量</li></ol></li><li>广播：唤醒所有</li></ol><h4 id="3-3-3-3-例子"><a href="#3-3-3-3-例子" class="headerlink" title="3.3.3.3. 例子"></a>3.3.3.3. 例子</h4><p>加数据，拿数据并发修改index，len</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F05%2F13%2F10-14-29-585bba0567fdf55505009b82a7129584-20240513101428-8e6943.png" alt="image.png"></p><p><em>这代码不知道哪来的，好像不是ppt上的</em></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> condition;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrement_count</span><span class="params">()</span> {</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line">    count = count - <span class="number">1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment_count</span><span class="params">()</span> {</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        pthread_cond_signal(&amp;condition);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><code>pthread_cond_wait</code>之后的代码仍然在互斥区里，不用担心等待被唤醒后有并发问题。</p><h2 id="3-4-Thread-attributes"><a href="#3-4-Thread-attributes" class="headerlink" title="3.4. Thread attributes"></a>3.4. Thread attributes</h2><ul><li>线程属性对象</li><li>初始化：<code>int pthread_attr_init(pthread_attr * attr);</code></li><li>get/set族函数，获取/设置属性</li></ul><p>e.g.修改detachstate，schedpolicy属性</p><h2 id="3-5-Thread-cancellation"><a href="#3-5-Thread-cancellation" class="headerlink" title="3.5. Thread cancellation"></a>3.5. Thread cancellation</h2><p>线程强制终止。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> </span></span><br><span class="line"><span class="params">*oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="3-6-Multithread-program"><a href="#3-6-Multithread-program" class="headerlink" title="3.6. Multithread program"></a>3.6. Multithread program</h2><ul><li>容易出现错误<ol><li>共享变量缺乏保护，未互斥使用</li><li>特别的，创建线程时传递指针，指针指向的变量可能时共享的</li></ol></li></ul><p>系统不隔离，用起来方便，但不安全</p><h2 id="3-7-Thread-Local-Storage-TLS"><a href="#3-7-Thread-Local-Storage-TLS" class="headerlink" title="3.7. Thread Local Storage (TLS)"></a>3.7. Thread Local Storage (TLS)</h2><p>线程局部存储：变量是<strong>线程私有</strong>的，对于线程内部的函数是全局变量</p><p>函数内的局部变量在线程的函数调用栈里，本来就不存在全局共享</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br></pre></td></tr></table></figure></div><ol><li>pthread_key_create：key相当于变量名，每一个线程都创建了这个变量，只是隔离了<ul><li>在每个线程中<strong>同时创建，同时释放</strong></li></ul></li><li>delete：会调用create时传入的析构函数                                                  </li><li>get/set：对TLS读写操作</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>02-软件架构intro</title>
    <link href="http://example.com/posts/46b5218b/"/>
    <id>http://example.com/posts/46b5218b/</id>
    <published>2024-04-16T06:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<ul><li>软件的四个本质难题<ol><li>复杂度</li><li>一致性 </li><li>可变性 </li><li>不可见性：没有几何结构</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F16%2F14-49-29-00d7cb1dc073a5a241fb8794c7cb365d-20240416144928-c3fd7b.png" alt="image.png"></p><h1 id="架构来源"><a href="#架构来源" class="headerlink" title="架构来源"></a>架构来源</h1><ul><li><p>Architecture:</p><ol><li>Component interfaces</li><li>Component communications and dependencies</li><li>Component responibilities<ol><li>性能，可用……</li></ol></li></ol></li><li><p>communication</p><ol><li>Data passing</li><li>Control flow</li></ol></li></ul><h2 id="NFR"><a href="#NFR" class="headerlink" title="NFR"></a>NFR</h2><ul><li>架构强调非功能需求NFR：how well a system works</li><li>包括<ol><li>技术限制</li><li>商业限制</li><li>质量属性</li></ol></li></ul><h1 id="architecture-views"><a href="#architecture-views" class="headerlink" title="architecture views"></a>architecture views</h1><p>有多个视图<br>解决不可见</p><h2 id="4-1-view-model"><a href="#4-1-view-model" class="headerlink" title="4+1 view model"></a>4+1 view model</h2><p>Logical view ：架构的重要元素和他们之间的关系<br>Process view  ：<br>Physical view<br>Development view</p><p>Architecture use cases: 四个视图是关于某个场景的</p><h2 id="generic-design-strategies"><a href="#generic-design-strategies" class="headerlink" title="generic design strategies"></a>generic design strategies</h2><ol><li>Decomposition</li><li>Abstraction</li><li>Stepwise: Divid and Conquer</li><li>Generate and Test，先生成一个设计，再对它测试</li><li>Iteration: Incremental Refinement</li><li>Reuseable elements，重用现有的设计</li></ol><h1 id="what-does-a-software-architect-do"><a href="#what-does-a-software-architect-do" class="headerlink" title="what does a software architect do?"></a>what does a software architect do?</h1><ol><li>Liaison<ol><li>调和用户、市场、开发等</li></ol></li><li>software engineering</li><li>technology knowledge</li><li>risk management</li></ol><h1 id="架构设计过程"><a href="#架构设计过程" class="headerlink" title="架构设计过程"></a>架构设计过程</h1><ol><li>识别和架构相关的重要需求</li><li>架构设计</li><li>文档化，以视图为中心</li><li>架构评估</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_软件系统设计" scheme="http://example.com/tags/2024-Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>04-估算、计划和跟踪</title>
    <link href="http://example.com/posts/d5102dd3/"/>
    <id>http://example.com/posts/d5102dd3/</id>
    <published>2024-04-16T02:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-估算"><a href="#1-估算" class="headerlink" title="1. 估算"></a>1. 估算</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h2><ul><li>目的：给各类计划提供决策依据</li><li>对象：规模，时间，日程</li><li>常见问题：<ol><li><strong>人月是资源/时间的单位，而不是规模单位</strong>。人和月不能互换</li><li>项目交互日期、团队都确定了，估算的意义在哪里？</li><li>哪种估算方法？</li><li>哪种估算结果更好？</li></ol></li></ul><p>估算只能给自己估算，给别人估算没有意义</p><h2 id="1-2-关于估算的事实"><a href="#1-2-关于估算的事实" class="headerlink" title="1.2. 关于估算的事实"></a>1.2. 关于估算的事实</h2><ol><li>估算是主观猜测</li><li>估算能力很难提升</li><li>没有任何人知道准确的数字是什么</li><li>实验表明，是否使用估算模型，并没有显著提示</li></ol><h2 id="1-3-期望理论"><a href="#1-3-期望理论" class="headerlink" title="1.3. 期望理论"></a>1.3. 期望理论</h2><p>软件开发是知识工作，可重复性不高<br>软件工程师是知识工作者，需要被激励</p><p>激励程度=V*E<br>V: 价值（基本确定）<br><font color="#c00000">E: 期望/把握</font>，<strong>估算结果会影响E</strong></p><h2 id="1-4-PROBE估算方法"><a href="#1-4-PROBE估算方法" class="headerlink" title="1.4. PROBE估算方法"></a>1.4. PROBE估算方法</h2><ul><li><p>规模度量/估算的困境</p><ul><li>以LOC vs. FP为例<ol><li><strong>精确度量</strong>往往不便于<strong>早期规划</strong>的估算</li><li>有助于<strong>早期规划</strong>/估算的度量往往难以产生精确度量结果</li></ol></li></ul></li><li><p>PROBE(PROxy Based)</p><ul><li>可以给出相对精确的估算</li></ul></li><li><p>流程</p><ol><li>概要设计</li><li>代理识别和代理规模(E)</li></ol></li></ul><h3 id="1-4-1-概要设计"><a href="#1-4-1-概要设计" class="headerlink" title="1.4.1. 概要设计"></a>1.4.1. 概要设计</h3><ol><li>和已有的产品/组件相关联</li><li>定义能够产生期望功能的产品元素</li><li>估算你计划构造之物的规模</li></ol><h3 id="1-4-2-整合多个估算结果"><a href="#1-4-2-整合多个估算结果" class="headerlink" title="1.4.2. 整合多个估算结果"></a>1.4.2. 整合多个估算结果</h3><ol><li>整合一个开发人员做的多个估算</li><li>多个开发人员可以整合<strong>独立</strong>进行的估算</li></ol><ul><li><font color="#c00000">估算要点1：估算时尽可能划分详细一些</font><ul><li>当估算多个部件时，总的误差会比各个部件误差的综合要小</li></ul></li></ul><h2 id="1-5-SCRUM中的Story-point"><a href="#1-5-SCRUM中的Story-point" class="headerlink" title="1.5. SCRUM中的Story point"></a>1.5. SCRUM中的Story point</h2><ol><li>抽象：混合了对于开发特征所要付出的努力，开发复杂度，个中分享以及类似东西</li><li>相对：设定标准之后，考虑其他特性与标准之间的相对大小关系<ol><li>拆分</li></ol></li></ol><p>团队需要定义<strong>单位故事点</strong>：规模、优先级等，抽象</p><ul><li><font color="#c00000">估算要点2：目标是建立在对结果的信心上的</font></li><li><font color="#c00000">估算要点3：尽量依赖数据</font></li></ul><h2 id="1-6-估算方法的反思"><a href="#1-6-估算方法的反思" class="headerlink" title="1.6. 估算方法的反思"></a>1.6. 估算方法的反思</h2><ol><li>估算目标<ul><li>规模估算S比较稳定，时间估算T=S/P。但生产力P可能有1<del>26倍的偏差。1</del>26倍的P算出来的时间都可以接受。</li><li><strong>实际生产中让大家认可估算结果</strong>，<strong>反过来提高生产效率P</strong></li></ul></li><li>到底怎么做估算：<ol><li>达成共识</li><li>建立信心<ol><li>足够详细</li><li>依赖数据</li><li>最好的猜测，注意检验假设条件的合理性</li></ol></li></ol></li></ol><ul><li><font color="#c00000">估算要点4：估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程。</font></li></ul><h2 id="1-7-估算要点"><a href="#1-7-估算要点" class="headerlink" title="1.7. 估算要点"></a>1.7. 估算要点</h2><ul><li><font color="#c00000">估算要点1：估算时尽可能划分详细一些</font><ul><li>当估算多个部件时，总的误差会比各个部件误差的综合要小</li></ul></li><li><font color="#c00000">估算要点2：目标是建立在对结果的信心上的</font></li><li><font color="#c00000">估算要点3：尽量依赖数据</font></li><li><font color="#c00000">估算要点4：估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程。</font><ul><li>团队达成共识，提高生产力</li><li>如果估算结果有问题，应该去和管理层或客户沟通，而不是提高估算结果</li></ul></li></ul><h2 id="1-8-度量"><a href="#1-8-度量" class="headerlink" title="1.8. 度量"></a>1.8. 度量</h2><ul><li><p>关于度量的争议：需否需要度量取决于是否在意结果</p></li><li><p>GQM(Goal Question Metric)：数据治理</p><ul><li>从目标出发，只关心单个项目组</li></ul></li><li><p>GQM+：关心整个组织，</p></li></ul><p>实际上估算可能要在项目启动之前就开始，而不是等到需求完成</p><h2 id="1-9-过程框架-生命周期模型"><a href="#1-9-过程框架-生命周期模型" class="headerlink" title="1.9. 过程框架-生命周期模型"></a>1.9. 过程框架-生命周期模型</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F14-09-03-e5bc1f40f94fceeb64028a442f84d704-20240425140903-a0ecd0.png" alt="image.png"></p><p>指导开发的是软件过程，而不是生命周期模型，所以至少要把里面一些部分展开</p><h2 id="1-10-通用计算框架"><a href="#1-10-通用计算框架" class="headerlink" title="1.10. 通用计算框架"></a>1.10. 通用计算框架</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F25%2F14-13-41-1319d1449b44d195fd7f9d9b0c6e28ba-20240425141340-aa6558.png" alt="image.png"></p><p>倒推式估算不准确</p><p>要先做估算，然后正推<br>管理层和估算值都知道“估算不准确”这一前提</p><p>攻击点：规模估算代码行数太多，资源估算不需要那没多资源<br>反驳：PROBE<strong>只讨论需求</strong>不讨论具体数字，而需求到具体数字是自动计算的过程（基于相对大小矩阵和历史数据）</p><h2 id="1-11-风险识别"><a href="#1-11-风险识别" class="headerlink" title="1.11. 风险识别"></a>1.11. 风险识别</h2><p>头脑风暴是因为无法系统识别风险</p><p>风险是可能性还未发生，问题是已经发生的。但如果风险超过某些阈值，也可以认为变成了问题。</p><h2 id="1-12-风险应对"><a href="#1-12-风险应对" class="headerlink" title="1.12. 风险应对"></a>1.12. 风险应对</h2><ul><li>识别风险之后，就应当制定响应的风险管理策略，以及应对各类风险</li><li>策略<ol><li>风险转嫁：付费给另一个团队，让他们帮你解决风险，但是你的收益会降低</li><li>风险解决：比较困难，很难彻底解决风险</li><li>风险缓解：共存，容忍</li></ol></li></ul><h1 id="2-计划和跟踪"><a href="#2-计划和跟踪" class="headerlink" title="2. 计划和跟踪"></a>2. 计划和跟踪</h1><p>为什么要跟踪：跟踪的目的在于了解项目的进度，以便在项目实际进度与计划产生严重偏离时，可采取适当的纠正措施；</p><p>项目进度滞后与否需要参照物，即项目计划</p><p>项目跟踪需要管理针对偏差而采取的纠偏措施</p><h2 id="2-1-挣值管理方法"><a href="#2-1-挣值管理方法" class="headerlink" title="2.1. 挣值管理方法"></a>2.1. 挣值管理方法</h2><h3 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1. 概念"></a>2.1.1. 概念</h3><ul><li><p>挣值管理(Earnd Value Management，EVM)是用来客观度量项目进度的一种项目管理方法。</p><ul><li>每项任务实现附以一定价值(credit)</li><li><strong>100%完成该项任务，才能获取相应价值</strong></li><li>非常保守的策略，只承认100%完成的任务，适合知识工作。</li></ul></li><li><p>支持动态随时变化</p></li><li><p>采用<strong>进度计划</strong>、<strong>成本预算</strong>和<strong>实际成本</strong>相关联的三个独立变量，进行项目绩效测量</p></li></ul><h3 id="2-1-2-规则"><a href="#2-1-2-规则" class="headerlink" title="2.1.2. 规则"></a>2.1.2. 规则</h3><ul><li><p>获取挣值规则：</p><ol><li>0-100，完成了就是100，差一行代码都是0</li><li>50-50：打算做这件事就拿到50，全部做完了再给50</li></ol></li><li><p>解释：提早给出反馈，可以让进度数据更好看，利于激励团队</p></li><li><p>例子：</p><ul><li>价值是百分比，经常省略%<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F30%2F10-27-31-8aea22469f933f20f0888b30836df0b6-20240430102728-0bf644.png" alt="image.png"></li></ul></li></ul><h3 id="2-1-3-图示"><a href="#2-1-3-图示" class="headerlink" title="2.1.3. 图示"></a>2.1.3. 图示</h3><p>PV：激化值<br>EV：挣值，从计划来，与实际投入时间无关<br>SV：进度差异，PV-EV</p><p>AC：实际成本，工时<br>BAC：项目总预算<br>CV：成本差异</p><p>画延长线可以预测项目进度<br>如果项目进度预期会延期，加人提高未来的EV，或砍功能提高已经完成的EV</p><h3 id="2-1-4-实现等级"><a href="#2-1-4-实现等级" class="headerlink" title="2.1.4. 实现等级"></a>2.1.4. 实现等级</h3><p>初级实现：只分析到现在为止的PV，EV<br>中级实现：根据PV,EV做预测分析<br>高级实现：加入成本线</p><h3 id="2-1-5-变形-燃尽图"><a href="#2-1-5-变形-燃尽图" class="headerlink" title="2.1.5. 变形-燃尽图"></a>2.1.5. 变形-燃尽图</h3><p>Ideal<br>Actual</p><h3 id="2-1-6-局限性"><a href="#2-1-6-局限性" class="headerlink" title="2.1.6. 局限性"></a>2.1.6. 局限性</h3><ol><li>只能跟踪进度、成本，而无法跟踪质量等目标</li><li>需要定量化的管理机制，在探索型项目以及部分敏捷开发方法中的应用收到限制</li><li>完全依赖于项目的准确估算（价值体系），然而在项目早期，很难对项目进行非常准确的估算</li></ol><h2 id="2-2-里程碑评审"><a href="#2-2-里程碑评审" class="headerlink" title="2.2. 里程碑评审"></a>2.2. 里程碑评审</h2><h3 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1. 概念"></a>2.2.1. 概念</h3><ul><li>往往指的是某个时间点，用以标记某项工作的完成或阶段的结束</li><li>内容<ol><li>项目相关的承诺，如日期、规格、质量</li><li>项目计划的执行情况</li><li>项目目前的状态讨论</li><li>项目面临的风险讨论</li></ol></li></ul><p>比周会等进度评审更加正式，需要高层、客户参与</p><p><strong>回答项目能不能进入下一个阶段</strong>，如需求完成但是质量很差被高层否决</p><h2 id="2-3-其他计划跟踪"><a href="#2-3-其他计划跟踪" class="headerlink" title="2.3. 其他计划跟踪"></a>2.3. 其他计划跟踪</h2><ol><li>日程计划跟踪</li><li>承诺计划跟踪</li><li>风险计划跟踪</li><li>数据收集计划跟踪</li><li>沟通计划跟踪</li></ol><h2 id="2-4-纠偏活动管理"><a href="#2-4-纠偏活动管理" class="headerlink" title="2.4. 纠偏活动管理"></a>2.4. 纠偏活动管理</h2><ul><li>典型活动<ol><li>偏差原因分析</li><li>纠偏措施定义</li><li>纠偏措施管理</li></ol></li></ul><h1 id="3-项目总结"><a href="#3-项目总结" class="headerlink" title="3. 项目总结"></a>3. 项目总结</h1><ul><li>软件项目的特点决定了持续改善对于软件工程师的重要性</li><li>提供一个系统化方法总计</li></ul><h2 id="3-1-过程"><a href="#3-1-过程" class="headerlink" title="3.1. 过程"></a>3.1. 过程</h2><p>准备阶段<br>总结阶段</p><h2 id="3-2-基于PMBOK的总结"><a href="#3-2-基于PMBOK的总结" class="headerlink" title="3.2. 基于PMBOK的总结"></a>3.2. 基于PMBOK的总结</h2><p>9大知识领域</p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_软件质量管理" scheme="http://example.com/categories/2024-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>04-File System</title>
    <link href="http://example.com/posts/bafecc27/"/>
    <id>http://example.com/posts/bafecc27/</id>
    <published>2024-04-15T02:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1. 文件系统"></a>1. 文件系统</h1><ol><li>指特定的文件格式</li><li>指按特定格式进行了“格式化”的一块存储介质</li><li>指操作系统用来管理文件系统以及对文件进行操作的机制以及实现</li></ol><h1 id="2-👍文件类型和结构"><a href="#2-👍文件类型和结构" class="headerlink" title="2. 👍文件类型和结构"></a>2. 👍文件类型和结构</h1><ul><li>文件类型<ol><li>regular file</li><li>character special file，字符设备文件</li><li>block special file，块设备文件</li><li>fifo/pipe：管道文件，没有文件名的文件</li><li>socket：网络接口</li><li>symbolic link</li><li>directory</li></ol></li><li>结构<ul><li>Byte stream; no particular internal structure</li></ul></li></ul><h1 id="3-Virtual-File-system-Switch-VFS"><a href="#3-Virtual-File-system-Switch-VFS" class="headerlink" title="3. Virtual File system Switch(VFS)"></a>3. Virtual File system Switch(VFS)</h1><ul><li>作用<ol><li>抽象接口，上层程序可以通过统一的系统调用访问不同文件系统</li><li>多文件系统共存</li><li>维护文件和目录的树状结构</li><li>文件权限控制</li><li>文件缓存和读写优化，VFS与内核的内存管理子系统协作，支持文件数据的缓存和页缓存机制</li><li>网络文件支持</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F15%2F10-27-12-c665556f9e0546a59447cd52982131cb-20240415102711-2fedd7.png" alt="image.png"></p><p><strong>位于内核态</strong>，比系统调用更加底层。</p><ul><li>组件<ol><li>super block<ul><li>描述文件系统的属性</li><li>e.g.只读，ext4</li></ul></li><li>i-node object<ul><li>描述文件，磁盘上<strong>所有的文件都有一个唯一的inode</strong></li><li><strong>记录真正的文件，文件存储在磁盘上时是按照索引号访问文件的，软链接是不同的文件，但是硬链接是相同的inode号，同一个文件。</strong></li></ul></li><li>file object<ul><li><strong>打开文件</strong>，如果文件没有被打开，不会有file object</li><li>文件对象需要释放</li><li><del>标定唯一文件</del></li></ul></li><li>dentry object<ul><li>记录目录路径</li></ul></li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F15%2F10-36-57-db71799c0c080f4b2b107653f0779545-20240415103657-f29555.png" alt="image.png"></p><h1 id="4-硬链接和符号链接"><a href="#4-硬链接和符号链接" class="headerlink" title="4. 硬链接和符号链接"></a>4. 硬链接和符号链接</h1><ul><li><p>Hard Link</p><ol><li>不同文件共用一个inode<ul><li>两个文件没有主次关系删掉一个没有影响</li></ul></li><li>不能跨文件系统/分区</li><li>只能对regular file创建</li><li>对应<strong>系统调用link</strong></li><li><strong>命令行</strong>：<code>ln {{/path/to/file}} {{path/to/hardlink}}</code></li></ol></li><li><p>Symbolic link</p><ol><li>存储被链接文件的文件名（而不是inode）实现链接</li><li>可以跨文件系统</li><li>可以对任何文件类型创建</li><li>对应<strong>系统调用symlink</strong></li><li><strong>命令行</strong>：<code>ln -s {{/path/to/file_or_directory}} {{path/to/symlink}}</code></li></ol></li><li><p>ls -l查看链接数目</p><ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F15%2F11-17-25-fc0746aebea93640a4b72174da722b7c-20240415111724-a9fb6d.png" alt="image.png"></li></ul></li></ul><h1 id="5-System-Calls"><a href="#5-System-Calls" class="headerlink" title="5. System Calls"></a>5. System Calls</h1><ul><li><p>都以<strong>C函数</strong>的形式出现</p></li><li><p><strong>系统调用</strong></p><ol><li>Linux内核的对外接口;</li><li>用户程序和内核之间唯一的接口;</li><li>提供最小接口</li></ol></li><li><p><strong>库函数</strong></p><ol><li>依赖于系统调用</li><li>提供较复杂功能</li><li>例：标准I/O库</li></ol></li><li><p>Basic I/O System Calls</p><ol><li>没有缓冲区（buffer）</li><li>使用File descriptor</li></ol></li></ul><h2 id="5-1-File-Descriptor"><a href="#5-1-File-Descriptor" class="headerlink" title="5.1. File Descriptor"></a>5.1. File Descriptor</h2><p><strong>用户态程序访问文件最底层的句柄</strong>，再往下就是内核。<br>可以理解成下标，数组在内核态（如果存在）</p><ol><li>是一个int值<ul><li><code>unistd.h</code>：STDIN_FILENO (0), STDOUT_FILENO (1), STDERR_FILENO (2)</li></ul></li><li>系统调用的返回值<ul><li>open,read,write…</li></ul></li></ol><p>e.g.使用系统调用读写文件</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main(){</span><br><span class="line"><span class="type">int</span> fd, nread;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">/*open file “data” for reading */</span></span><br><span class="line">fd = open(“data”, O_RDONLY);</span><br><span class="line"><span class="comment">/* read in the data */</span></span><br><span class="line">nread = read(fd, buf, <span class="number">1024</span>);</span><br><span class="line"><span class="comment">/* close the file */</span></span><br><span class="line">close(fd);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="5-2-opne-creat-function"><a href="#5-2-opne-creat-function" class="headerlink" title="5.2. opne/creat function"></a>5.2. opne/creat function</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>; <span class="comment">//可变参数，不是函数重载</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">//Return: a new file descriptor if success; -1 if failure</span></span><br></pre></td></tr></table></figure></div><ul><li><p>flags: <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>，<code>O_TRUNC</code>， <code>O_APPEND</code></p></li><li><p>mode: 指定权限</p><ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F15%2F19-58-41-b7c02ff2b68a05537120b877293752e3-20240615195840-fe85a4.png" alt="image.png"></li></ul></li><li><p><code>creat</code>：<code>open</code> with flags<code>O_CREAT|O_WRONLY|O_TRUNC</code></p></li></ul><h2 id="5-3-close"><a href="#5-3-close" class="headerlink" title="5.3. close"></a>5.3. close</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">//Return: 0 if success; -1 if failure</span></span><br></pre></td></tr></table></figure></div><h2 id="5-4-read-write"><a href="#5-4-read-write" class="headerlink" title="5.4. read/write"></a>5.4. read/write</h2><p>read from a file descriptor</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">//返回值: 读到的字节数，若已到文件尾为0，若出错为-1</span></span><br></pre></td></tr></table></figure></div><p>write to a file descriptor</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">//返回值: 若成功为已写的字节数，若出错为-1</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">err_sys(“write error”);</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">err_sys(“read error”);</span><br></pre></td></tr></table></figure></div><h2 id="5-5-seek"><a href="#5-5-seek" class="headerlink" title="5.5. seek"></a>5.5. seek</h2><ul><li>设置read/write的偏移量</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">//Return: the resulting offset location if success; -1 if failure)</span></span><br></pre></td></tr></table></figure></div><ul><li>whence: seek从哪里开始加偏移量<ol><li>SEEK_SET: the offset is set to “offset” bytes</li><li>SEEK_CUR: the offset is set to its current location plus “offset” bytes</li><li>SEEK_END: the offset if set to the size of the file plus “offset“ bytes</li></ol></li></ul><h2 id="5-6-dup-dup2-Function"><a href="#5-6-dup-dup2-Function" class="headerlink" title="5.6. dup/dup2 Function"></a>5.6. dup/dup2 Function</h2><ul><li>复制文件描述符</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">//Return: the new file descriptor if success; -1 if failure)</span></span><br></pre></td></tr></table></figure></div><ul><li>e.g.重定向的实现</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(...)</span><br><span class="line">dup2(fd,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><h2 id="5-7-fcntl-Function"><a href="#5-7-fcntl-Function" class="headerlink" title="5.7. fcntl Function"></a>5.7. fcntl Function</h2><ul><li>控制文件描述符</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br><span class="line"><span class="comment">//返回值: 若成功则返回值依赖于cmd，若出错为-1</span></span><br></pre></td></tr></table></figure></div><ul><li>cmd取值<ol><li>F_DUPFD: <strong>Duplicate</strong> a file descriptor</li><li>F_GETFD/F_SETFD: Get/set the <strong>file descriptor’s close-on-exec flag</strong><ul><li>close-on-exec flag: 调用exec时文件描述符会不会关闭</li><li>为解决fork子进程执行其他任务(exec等)导致父进程的文件描述符被复制到子进程中，使得对应文件描述符无法被之后需要的进程获取。</li></ul></li><li>F_GETFL/F_SETFL: Get/set the <strong>file descriptor’s flags</strong><ul><li>open/creat中的flags 参数</li></ul></li><li>F_GETOWN/F_SETOWN: <strong>Manage I/O availability signals</strong><ul><li>可以向文件发几个信号</li><li>获得或设置当前文件描述符会接受SIGIO和SIGURG信号的进程或进程组编号</li></ul></li><li>F_GETLK/F_SETLK/F_SETLKW: Get/set the <strong>file lock</strong><ul><li>S_SETLKW同S_SETLK，但是在锁无法设置时会阻塞等待任务完成。</li></ul></li></ol></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:fcntl</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line">fd =open(<span class="string">"test.txt"</span>,<span class="number">0</span>_RDWR|<span class="number">0</span>_APPEND);<span class="keyword">if</span>(fd ==<span class="number">-1</span>)</span><br><span class="line"><span class="comment">//printf("open err/n");</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fd =%d"</span>,fd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fork!/n"</span>);</span><br><span class="line">fcntl(fd,F_SETFD,<span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> *s=<span class="string">"0000000000000000000"</span>;</span><br><span class="line">pid =fork();</span><br><span class="line"><span class="keyword">if</span>(pid ==θ)</span><br><span class="line">execl(<span class="string">"ass"</span>,<span class="string">"./ass"</span>,&amp;fd,<span class="literal">NULL</span>);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">write(fd,s,<span class="built_in">strlen</span>(s));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> θ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//file:ass.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>{</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"argc =%d“,argc);</span></span><br><span class="line"><span class="string">fd =*argv[1];</span></span><br><span class="line"><span class="string">printf("</span>fd =%d<span class="string">",fd);</span></span><br><span class="line"><span class="string">char *s ="</span>zzzzzzzzzzzzzzzzzzz<span class="string">";</span></span><br><span class="line"><span class="string">write(fd,(void *)s,strlen(s));</span></span><br><span class="line"><span class="string">close(fd);</span></span><br><span class="line"><span class="string">return θ;</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></div><h2 id="5-8-ioctl-function"><a href="#5-8-ioctl-function" class="headerlink" title="5.8. ioctl function"></a>5.8. ioctl function</h2><ul><li>控制设备</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></div><ul><li><code>d</code>：文件描述符</li><li><code>request</code>：也是命令，但是是自定义的</li></ul><h1 id="6-Standard-I-O-Library"><a href="#6-Standard-I-O-Library" class="headerlink" title="6. Standard I/O Library"></a>6. Standard I/O Library</h1><h2 id="6-1-File-Stream"><a href="#6-1-File-Stream" class="headerlink" title="6.1. File Stream"></a>6.1. File Stream</h2><p>使用用户态的<strong>结构体</strong><code>FILE</code>，而不是文件描述符。<code>FILE</code>结构体内部保存文件描述符。</p><p>有预先定义好的stdin, stdout, stderr</p><ul><li>buffer<ol><li>Full buffer</li><li>Line buffer</li><li>No buffer</li></ol></li></ul><h2 id="6-2-Stream-Buffering-Operations"><a href="#6-2-Stream-Buffering-Operations" class="headerlink" title="6.2. Stream Buffering Operations"></a>6.2. Stream Buffering Operations</h2><ul><li>buffer类型<ol><li>block buffered (fully buffered)</li><li>line buffered</li><li>unbuffered</li></ol></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div><ul><li>type:<ul><li><code>_IOFBF</code>(满缓冲）</li><li><code>_IOLBF</code>(行缓冲）</li><li><code>_IONBF</code>(无缓冲）</li></ul></li></ul><h2 id="6-3-Stream-open-close"><a href="#6-3-Stream-open-close" class="headerlink" title="6.3. Stream open/close"></a>6.3. Stream open/close</h2><ul><li>创建/销毁stream</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure></div><ul><li>mode<ol><li>r: reading</li><li>w: Truncate file to zero length or create text file for writing.</li><li>a: appending</li><li>r+: reading and writing</li><li>w+: Open for reading and writing. The file is created if it does not exist, otherwise it is truncated.</li><li>a+: Open for reading and appending. The file is created if does not exist.</li></ol></li></ul><h2 id="6-4-Input-of-a-character"><a href="#6-4-Input-of-a-character" class="headerlink" title="6.4. Input of a character"></a>6.4. Input of a character</h2><ol><li><code>getc</code>是宏定义，速度比<code>fgetc</code>快</li><li><code>fgetc</code></li><li>`getchar</li><li><code>ungetc</code>：把字符放到stream中</li><li><code>ferror(FILE *stream)</code>: 检查指定的文件流 <code>stream</code> 是否发生了错误。</li><li><code>feof(FILE *stream)</code>: stream是否已经到达EOF</li><li><code>clearerr(FILE *stream)</code>：清除指定文件流 <code>stream</code> 的错误标志和 EOF 标志。</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Result: Reads the next character from a stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.</span></span><br></pre></td></tr></table></figure></div><h2 id="6-5-Output-of-a-Character"><a href="#6-5-Output-of-a-Character" class="headerlink" title="6.5. Output of a Character"></a>6.5. Output of a Character</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">//Return: the character if success; -1 if failure</span></span><br></pre></td></tr></table></figure></div><h2 id="6-6-Input-of-a-Line-of-String"><a href="#6-6-Input-of-a-Line-of-String" class="headerlink" title="6.6. Input of a Line of String"></a>6.6. Input of a Line of String</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>; <span class="comment">//not recommended.</span></span><br></pre></td></tr></table></figure></div><p>fgets最多读取size-1个字符到stream，读到EOF或换行符停止，结尾会存一个<code>\0</code></p><h2 id="6-7-Output-of-a-Line-of-String"><a href="#6-7-Output-of-a-Line-of-String" class="headerlink" title="6.7. Output of a Line of String"></a>6.7. Output of a Line of String</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s</span></span><br></pre></td></tr></table></figure></div><h2 id="6-8-Binary-Stream-Input-Output"><a href="#6-8-Binary-Stream-Input-Output" class="headerlink" title="6.8. Binary Stream Input/Output"></a>6.8. Binary Stream Input/Output</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="comment">//Return: the number of a items successfully read or written.</span></span><br></pre></td></tr></table></figure></div><p>fwrite: 向磁盘写入数组，数组首地址ptr，数组每个格子大小size, 数组元素个数nmemb</p><ul><li>写一个数组：</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">if</span> ( fwrite(&amp;data[<span class="number">2</span>], <span class="keyword">sizeof</span>(<span class="type">float</span>), <span class="number">4</span>, fp) != <span class="number">4</span> )</span><br><span class="line">err_sys(“fwrite error”);</span><br></pre></td></tr></table></figure></div><ul><li>写一个结构体</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">short</span> count; </span><br><span class="line"><span class="type">long</span> total; </span><br><span class="line"><span class="type">char</span> name[NAMESIZE];</span><br><span class="line">}item;</span><br><span class="line"><span class="keyword">if</span> ( fwrite(&amp;item, <span class="keyword">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">err_sys(“fwrite error”);</span><br></pre></td></tr></table></figure></div><p><a class="link" href="https://stackoverflow.com/questions/43348672/correct-way-to-use-fwrite-and-fread">c - correct way to use fwrite and fread - Stack Overflow <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="6-9-Formatted-I-O"><a href="#6-9-Formatted-I-O" class="headerlink" title="6.9. Formatted I/O"></a>6.9. Formatted I/O</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure></div><p>使用<code>fgets</code>, 然后解析字符串</p><hr><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="6-10-Reposition-a-stream"><a href="#6-10-Reposition-a-stream" class="headerlink" title="6.10. Reposition a stream"></a>6.10. Reposition a stream</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *fp, <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="6-11-Flush-a-stream"><a href="#6-11-Flush-a-stream" class="headerlink" title="6.11. Flush a stream"></a>6.11. Flush a stream</h2><p>刷写文件流，把流里的数据立刻写入文件</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="6-12-Stream-and-File-Descriptor"><a href="#6-12-Stream-and-File-Descriptor" class="headerlink" title="6.12. Stream and File Descriptor"></a>6.12. Stream and File Descriptor</h2><ul><li>确定流使用的底层文件描述符</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div><ul><li>根据已打开文件描述符创建一个流</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="6-13-Temporary-File"><a href="#6-13-Temporary-File" class="headerlink" title="6.13. Temporary File"></a>6.13. Temporary File</h2><ul><li>为临时文件创建名称<ul><li>返回值：指向唯一路径名的指针</li></ul></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure></div><ul><li>创建临时文件<ul><li>返回值：如果成功返回文件指针，否则为NULL</li></ul></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div><h1 id="7-Advanced-System-Calls"><a href="#7-Advanced-System-Calls" class="headerlink" title="7. Advanced System Calls"></a>7. Advanced System Calls</h1><ul><li>Handling file attributes<ul><li>stat/fstat/lstat, …</li></ul></li><li>Handling directory</li></ul><h2 id="7-1-stat-fstat-lstat"><a href="#7-1-stat-fstat-lstat" class="headerlink" title="7.1. stat/fstat/lstat"></a>7.1. stat/fstat/lstat</h2><p>获取文件状态。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="comment">//Return: 0 if success; -1 if failure</span></span><br></pre></td></tr></table></figure></div><ul><li><span style="background:rgba(3, 135, 102, 0.2)">lstate和stat的区别</span>在于对符号链接的处理：<ol><li><code>stat</code> 会跟随符号链接并获取链接目标的文件状态信息</li><li><code>lstat</code> 则获取<strong>链接本身</strong>的文件状态信息。当你需要确定一个文件是不是符号链接，或者你需要获取符号链接本身的信息（比如权限、所有者等），这时应该使用 <code>lstat</code>。</li></ol></li></ul><hr><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> {</span></span><br><span class="line"><span class="type">mode_t</span> st_mode; <span class="comment">/*file type &amp; mode*/</span></span><br><span class="line"><span class="type">ino_t</span> st_ino; <span class="comment">/*inode number (serial number)*/</span></span><br><span class="line"><span class="type">dev_t</span> st_rdev; <span class="comment">/*device number (file system)*/</span> </span><br><span class="line"><span class="type">nlink_t</span> st_nlink; <span class="comment">/*link count*/</span></span><br><span class="line"><span class="type">uid_t</span> st_uid; <span class="comment">/*user ID of owner*/</span></span><br><span class="line"><span class="type">gid_t</span> st_gid; <span class="comment">/*group ID of owner*/</span></span><br><span class="line"><span class="type">off_t</span> st_size; <span class="comment">/*size of file, in bytes*/</span></span><br><span class="line"><span class="type">time_t</span> st_atime; <span class="comment">/*time of last access*/</span></span><br><span class="line"><span class="type">time_t</span> st_mtime; <span class="comment">/*time of last modification*/</span></span><br><span class="line"><span class="type">time_t</span> st_ctime; <span class="comment">/*time of last file status change*/</span></span><br><span class="line"><span class="type">long</span> st_blksize; <span class="comment">/*Optimal block size for I/O*/</span></span><br><span class="line"><span class="type">long</span> st_blocks; <span class="comment">/*number 512-byte blocks allocated*/</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><ul><li>types<ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F15-44-56-d242d33e62d872278b310f72104be0f3-20240616154455-89aee9.png" alt="image.png"></li></ul></li><li>mode<ul><li><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F16%2F15-44-31-651ec3334b5d75bec36c65ffcd3cc500-20240616154430-2690d8.png" alt="image.png"></li></ul></li></ul><h2 id="7-2-umask"><a href="#7-2-umask" class="headerlink" title="7.2. umask"></a>7.2. umask</h2><p>为进程设置文件存取权限屏蔽字，并返回以前的值。<br>定义了文件系统创建文件和目录时<strong>默认应该屏蔽掉的权限位</strong></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"example.txt"</span>, &amp;statbuf) == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File size: %ld bytes\n"</span>, statbuf.st_size);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        perror(<span class="string">"stat failed"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置umask</span></span><br><span class="line">    umask(S_IWGRP | S_IWOTH); <span class="comment">// 屏蔽组和其他用户的写权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件，权限将自动应用umask</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">"newfile.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"Hello, World!"</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        perror(<span class="string">"fopen failed"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h2 id="7-3-directory"><a href="#7-3-directory" class="headerlink" title="7.3. directory"></a>7.3. directory</h2><ul><li><p>数据结构</p><ol><li>DIR：文件夹</li><li>struct dirent：文件夹中的目录项</li></ol></li><li><p>DIR</p></li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">//The data type of directory stream objects</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">dirstream</span> <span class="title">DIR</span>;</span></span><br></pre></td></tr></table></figure></div><ul><li>struct dirent</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">//Directory item</span></span><br><span class="line"><span class="type">ino_t</span> d_ino; <span class="comment">/* inode number */</span></span><br><span class="line"><span class="type">char</span> d_name[NAME_MAX + <span class="number">1</span>]; <span class="comment">/* file name */</span></span><br></pre></td></tr></table></figure></div><hr><ul><li>操作:</li></ul><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">telldir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">seekdir</span><span class="params">(DIR *dir, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure></div><hr><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DIR *dp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"><span class="keyword">if</span> ( (dp = opendir(dir)) == <span class="literal">NULL</span> )</span><br><span class="line">err_sys(…);</span><br><span class="line"><span class="keyword">while</span> ( (entry = readdir(dp)) != <span class="literal">NULL</span> ) {</span><br><span class="line">lstat(entry-&gt;d_name, &amp;statbuf);</span><br><span class="line"><span class="keyword">if</span> ( S_ISDIR(statbuf.st_mode) ) </span><br><span class="line">…</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">…</span><br><span class="line">}</span><br><span class="line">closedir(dp);</span><br></pre></td></tr></table></figure></div><h1 id="8-File-lock"><a href="#8-File-lock" class="headerlink" title="8. File lock"></a>8. File lock</h1><p>作用：几个进程同时操作一个文件</p><h2 id="8-1-分类"><a href="#8-1-分类" class="headerlink" title="8.1. 分类"></a>8.1. 分类</h2><ul><li>记录锁：往文件加锁时，是否要锁整个文件，还是只锁一部分（记录锁）。<strong>允许只对文件特点部分上锁</strong>。</li></ul><hr><ul><li>劝告锁：<ul><li>检查，加锁由应用程序控制</li><li>系统会给进程发信号，告诉他这个文件被上锁，但是<strong>可以强行操作文件</strong></li></ul></li><li>强制锁：<ul><li>检查，加锁由内核控制</li><li><strong>不允许违反锁规则访问</strong></li><li>影响open,write,read等操作</li></ul></li></ul><hr><ul><li>共享锁</li><li>排他锁</li></ul><h2 id="8-2-fcntl"><a href="#8-2-fcntl" class="headerlink" title="8.2. fcntl"></a>8.2. fcntl</h2><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br><span class="line"><span class="comment">//返回值: 若成功则依赖于cmd，若出错为-1</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span>{</span></span><br><span class="line">...</span><br><span class="line"><span class="type">short</span> l_type; <span class="comment">/* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span></span><br><span class="line"><span class="type">short</span> l_whence; <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, </span></span><br><span class="line"><span class="comment">SEEK_END */</span></span><br><span class="line"><span class="type">off_t</span> l_start; <span class="comment">/* Starting offset for lock */</span></span><br><span class="line"><span class="type">off_t</span> l_len; <span class="comment">/* Number of bytes to lock */</span></span><br><span class="line"><span class="type">pid_t</span> l_pid; <span class="comment">/* PID of process blocking our lock (F_GETLK only) */</span></span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><ul><li>cmd参数<ol><li>F_GETLK：获得文件的封锁信息</li><li>F_SETLK：对文件的某个区域封锁或解除封锁</li><li>F_SETLKW：功能同F_SETLK, <strong>wait方式</strong></li></ol></li><li>l_type<ol><li>F_RDLCK：<strong>共享锁（Shared Lock）</strong>,read lock</li><li>F_WRLCK：<strong>排他锁（Exclusive Lock）</strong>,write lock</li><li>F_UNLCK：<strong>解锁（Unlock）</strong></li></ol></li><li>l_whence<ul><li>起始位置的参考点，通常是<code>SEEK_SET</code>（文件开头）、<code>SEEK_CUR</code>（当前位置）或<code>SEEK_END</code>（文件结尾）</li></ul></li><li>l_len：锁的长度，0通常表示直到文件末尾。</li><li>l_start：锁的起始位置，可以指定为字节偏移量。</li><li><strong>记录锁（Record Lock）</strong> 的实现：<ul><li>通过设置 <code>l_start</code>、<code>l_len</code> 和 <code>l_whence</code> 字段来定义锁的范围</li></ul></li></ul><p><a class="link" href="https://cn.linux-console.net/?p=23446#:~:text=%E5%BC%BA%E5%88%B6%E9%94%81%E6%98%AF%E6%96%87%E4%BB%B6%E9%94%81%EF%BC%8C%E5%8F%AF%E9%98%B2%E6%AD%A2%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9B%B4%E5%88%B0%E9%94%81%E8%A2%AB%E9%87%8A%E6%94%BE%E3%80%82%20%E5%BC%BA%E5%88%B6%E9%94%81%E7%94%B1%E5%86%85%E6%A0%B8%E8%AE%BE%E7%BD%AE%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E8%BF%9B%E7%A8%8B%E8%A6%86%E7%9B%96%E3%80%82%20%E5%BD%93%E6%96%87%E4%BB%B6%E5%BE%88%E5%85%B3%E9%94%AE%E5%B9%B6%E4%B8%94%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BB%BB%E4%BD%95%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E4%BF%AE%E6%94%B9%E6%97%B6%EF%BC%8C%E5%BC%BA%E5%88%B6%E9%94%81%E5%BE%88%E6%9C%89%E7%94%A8%E3%80%82%20fcntl,%28%29%20%E5%87%BD%E6%95%B0%E8%BF%98%E7%94%A8%E4%BA%8E%E5%AF%B9%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E9%94%81%E5%AE%9A%E3%80%82%20F_SETLK%20%E6%A0%87%E5%BF%97%E7%94%A8%E4%BA%8E%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E9%94%81%E5%AE%9A%E3%80%82">fcntl实现强制锁和劝告锁 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>05-事务</title>
    <link href="http://example.com/posts/891158d6/"/>
    <id>http://example.com/posts/891158d6/</id>
    <published>2024-04-08T06:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-事务处理"><a href="#1-事务处理" class="headerlink" title="1. 事务处理"></a>1. 事务处理</h1><p>事务的本质是多个操作一个步骤（操作包括读取和写入数据记录）</p><ul><li>ACID特性：<ol><li>A 原子性：事务本质要求</li><li>C 一致性：数据完整要求，开发者控制而不是数据库控制<ol><li>数据库只能保证实体完整性和参照完整性，数据的一致性只能由开发者保证</li></ol></li><li>I 隔离性：并发的要求</li><li>D 持久性：数据库系统要求</li></ol></li></ul><p>事务调度管理器 ：协调、调度和跟踪事务的各个步骤<br>锁管理器：保证隔离性，锁的粒度决定隔离级别<br>页缓存：充当持久化存储和存储引擎其余部分之间的中介<br>日志管理器 ：记录已应用在缓存页上的操作（日志条目），以便撤销已中止的事务所作出的更改<br>分布式事务协调</p><h1 id="2-缓冲区管理-Buffer-Management"><a href="#2-缓冲区管理-Buffer-Management" class="headerlink" title="2. 缓冲区管理 Buffer Management"></a>2. 缓冲区管理 Buffer Management</h1><ol><li>双层存储是大部分数据库的基础</li><li><strong>页缓存</strong><ol><li>Page in 换入</li><li>Flush 刷写</li><li>Evict 换出</li></ol></li></ol><blockquote><p>缓存页什么时候换出？<br>提早换出，还是刷写时才换出？</p></blockquote><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F22-36-20-d051686a868834303594276d0c934d72-20240612223619-25dc21.png" alt="image.png"></p><h2 id="2-1-在缓存中锁定页"><a href="#2-1-在缓存中锁定页" class="headerlink" title="2.1. 在缓存中锁定页"></a>2.1. 在缓存中锁定页</h2><ol><li>B+树越靠近顶部越窄，层次较高的节点在大多数读取中都会被命中</li><li>分裂和合并操作最终会传播到高层节点</li><li>频繁的子树结构变化，可以一起处理</li></ol><h2 id="2-2-页置换策略选择"><a href="#2-2-页置换策略选择" class="headerlink" title="2.2. 页置换策略选择"></a>2.2. 页置换策略选择</h2><p>缓存更大不能减少换出次数，Beadly异常</p><ol><li>FIFO</li><li>LRU：最长时间未使用策略<ol><li>范围查询时，连续查询叶节点，叶节点虽然只被读一次但会把根节点换出去</li></ol></li><li>LRU-K：最近K次访问频繁用到的页，并使用此信息估计访问时间</li><li>2Q的LRU（双队列，k=2）：后续访问移入第二个队列，从而区分最近访问和经常访问</li><li>LFU</li><li>CLOCK</li></ol><h1 id="3-恢复"><a href="#3-恢复" class="headerlink" title="3. 恢复"></a>3. 恢复</h1><ul><li><p>日志：<strong>恢复最重要的技术</strong></p><ol><li>Undo</li><li>Redo：事务提交后，数据库发生崩溃，还未写回到磁盘<ul><li>格式e.g.把#1表的#293页面的偏移量2323的值更新为2</li></ul></li></ol></li><li><p>为什么不在事务提交之前，把事务所有的页面刷写到磁盘？</p><ol><li>刷写一个完整的数据页太浪费，如果只修改一个字节，却要刷写一个16k的数据页</li><li>随机I/O环境效率低</li></ol></li></ul><h2 id="3-1-redo日志"><a href="#3-1-redo日志" class="headerlink" title="3.1. redo日志"></a>3.1. redo日志</h2><ul><li>Redo<ol><li>占用空间小，</li><li>顺序I/O</li></ol></li></ul><h3 id="3-1-1-redo日志设计"><a href="#3-1-1-redo日志设计" class="headerlink" title="3.1.1. redo日志设计"></a>3.1.1. redo日志设计</h3><ul><li>静态结构<ol><li>redo目录的结构</li><li>redo需不需要设置页大小？要不要比正常的page大？<ul><li>页要足够大，方便一次性全部读出来</li></ul></li><li>顺序文件还是随机文件？<ul><li>顺序I/O，追加写</li></ul></li></ol></li><li>动态结构<ol><li>事务的原子性如何保障？冲突如何解决？</li><li>redo日志也是双存储结构，如何写？</li></ol></li><li>维护<ol><li>如何循环使用redo</li></ol></li></ul><h3 id="3-1-2-格式"><a href="#3-1-2-格式" class="headerlink" title="3.1.2. 格式"></a>3.1.2. 格式</h3><ul><li><p>本质是记录事务对数据库物理表上的修改<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F22-52-40-1637d9d419ae1520c0a4cf16766d3835-20240612225239-6db313.png" alt="image.png"></p></li><li><p>简单日志：</p><ol><li>Type</li><li>SpaceID：表ID</li><li>Page number：页ID</li><li>Data：日志的内容</li><li>offset</li><li>len：可能是变长</li></ol></li><li><p>复杂日志：一条SQL可能修改多个地方（数据页面，聚簇索引，二级索引等）</p><ol><li>在每个修改的地方都记录一条日志<ul><li>导致有很多条日志</li></ul></li><li>将整个页面第一个修改的字节到最后一个修改的字节之间的数据，当成一条物理redo<ul><li>只有一条日志，但是很大</li></ul></li></ol></li><li><p>其他可能：只记录操作，不记录物理变化</p><ol><li>物理层面的记录：指明哪个表空间，哪个页被改动</li><li>逻辑层面的记录：记录操作，系统崩溃后，重新执行这个操作<ul><li>基于逻辑的日志：本质是提供了调用恢复函数的参数，并不能直接执行日志恢复</li></ul></li></ol></li></ul><h3 id="3-1-3-Mini-Transaction"><a href="#3-1-3-Mini-Transaction" class="headerlink" title="3.1.3. Mini-Transaction"></a>3.1.3. Mini-Transaction</h3><ul><li><p>以组的形式写入redo log</p><ol><li>一组操作，一组日志，不可分割</li></ol></li><li><p>特殊类型的redo日志：保证一组日志的原子性<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-23-10-8cb8747301cb3f872fb4eb3797368e4c-20240613112310-278262.png" alt="image.png"></p></li><li><p>事务管理器：把整个事务组织成一个树状结构<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-24-05-0b9aa269d9c33be189f7bc168279d99f-20240613112405-522fb6.png" alt="image.png"></p></li></ul><h3 id="3-1-4-redo-log-block"><a href="#3-1-4-redo-log-block" class="headerlink" title="3.1.4. redo log block"></a>3.1.4. redo log block</h3><p>redo log的日志page大小比正常的page大（MySQL中,512K）</p><p>结构：头，尾，内容<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-24-41-98d096cced2b10498860601bccb8651d-20240613112441-c71902.png" alt="image.png"></p><h3 id="3-1-5-redo日志缓存-redo-log-buffer-pool"><a href="#3-1-5-redo日志缓存-redo-log-buffer-pool" class="headerlink" title="3.1.5. redo日志缓存(redo log buffer pool)"></a>3.1.5. redo日志缓存(redo log buffer pool)</h3><ul><li>redo依然是双存储结构，有独立的Buffer，由若干连续redo log block组成  <ul><li><span style="background:rgba(3, 135, 102, 0.2)">事务结束标准</span>：内存里的操作执行完成，脏页已经产生，<span style="background:rgba(3, 135, 102, 0.2)">日志已经写回磁盘</span></li></ul></li><li>顺序写入，速度是最快的</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-26-30-0118490e46dd4fa558f22db5e07df755-20240613112630-044014.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-27-12-58abc171d8751422e16e4866ee14859d-20240613112711-023f30.png" alt="image.png"></p><h3 id="3-1-6-lsn-log-sequence-number"><a href="#3-1-6-lsn-log-sequence-number" class="headerlink" title="3.1.6. lsn(log sequence number)"></a>3.1.6. lsn(log sequence number)</h3><p>LSN是一个单调递增的数字，用于唯一标识事务日志记录（Log Record）在日志文件中的位置。每次事务修改了数据库中的数据并将其变更写入日志时，都会分配一个LSN。</p><ol><li><font color="#9bbb59">记录哪些log已经刷写，哪些日志尚未被刷写</font><ol><li>buf_free,buf_next_to_write</li></ol></li><li>对大多数数据库，需要有一个<span style="background:rgba(3, 135, 102, 0.2)">全局log变量定位位置</span><ul><li>记录block头尾和log大小，包括跨页，这样可以完整计算所有的偏移量，而不需要记录页id+偏移量，因为顺序插入</li></ul></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-29-52-612e2c9f28935b61595c3ae3c52b9b75-20240613112951-881fb6.png" alt="image.png"></p><h3 id="3-1-7-redo-日志文件-redo-log-file"><a href="#3-1-7-redo-日志文件-redo-log-file" class="headerlink" title="3.1.7. redo 日志文件(redo log file)"></a>3.1.7. redo 日志文件(redo log file)</h3><ul><li>redo log刷盘时机<ol><li>log buffer空间不足时</li><li>事务提交时</li><li>脏页刷新</li><li>定时进程，固定刷新</li><li>正常关闭服务器</li></ol></li><li>磁盘中日志文件<ol><li>数量和大小(2-100，48M)</li><li>循环写入<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-29-28-6a2483fa435604cebf1d9241ef212a4a-20240613112927-a8afad.png" alt="image.png"></li></ol></li></ul><h3 id="3-1-8-check-point"><a href="#3-1-8-check-point" class="headerlink" title="3.1.8. check point"></a>3.1.8. check point</h3><p>定期地将内存中的数据（如缓存中的脏页）刷写到磁盘上。<br>在数据库恢复时，可以从最新的Checkpoint开始，然后根据日志中的LSN顺序redo或undo操作，直到达到最新的状态。</p><ul><li>redo日志组容量时有限的，不得不循环使用  </li><li>需要解决的问题：<ol><li>buffer中，哪个日志组已经刷写到硬盘？</li><li>日志文件中，哪个日志组所涉及的操作已经刷写到数据文件中？</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-31-44-13f4b1c41ced8da77c958f53f4ee9b72-20240613113143-4b2e38.png" alt="image.png"></p><ul><li><p>计算步骤</p><ol><li>计算当前系统可以被覆盖的redo日志对应的lsn值最大是多少</li><li>将信息写入日志文件的管理信息中，记录check point的操作<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-33-14-1932f2a89152273eadf537888af04800-20240613113313-27f8b6.png" alt="image.png"></li></ol></li><li><p>理想状况，check point记录一次就行，但如果更新过快，可能需要多次记录</p></li><li><p>check point每执行一次，均要修改redo日志文件的管理信息</p></li><li><p>后台刷脏操作和check point操作是两个<span style="background:rgba(3, 135, 102, 0.2)">并行</span>的操作</p><ol><li>修改页面非常频繁，导致lsn快速增长，无法及时做checkpoint，则线程做刷脏操作</li><li>定时完成check point操作</li></ol></li></ul><h3 id="redo日志文件格式"><a href="#redo日志文件格式" class="headerlink" title="redo日志文件格式"></a>redo日志文件格式</h3><ol><li>log buffer本质上是一片连续的内存空间，被划分为若干个512k大小的block</li><li>redo日志刷新到磁盘是把block的镜像写入日志文件，文件也是若干个512k的block</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-39-00-10a051d8a1854f5e17c5d862ce565654-20240613113900-d3e97a.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-41-17-8856567a67948ef734c501c06426b3a7-20240613114117-09cfa7.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-41-00-a6cddfef4966a5a16fc24ea6442170b1-20240613114059-238f9a.png" alt="image.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-41-11-7fd6e3883236c51bc041fcac9f4d355d-20240613114111-4445dd.png" alt="image.png"></p><h3 id="3-1-9-恢复"><a href="#3-1-9-恢复" class="headerlink" title="3.1.9. 恢复"></a>3.1.9. 恢复</h3><ol><li><span style="background:rgba(3, 135, 102, 0.2)">确定恢复的起点</span>：<ul><li>选取最近的checkpoint的信息，checkpoint_no比较一下大小</li><li>然后找<strong>checkpoint_lsn</strong>和<strong>checkpoint_offset</strong></li></ul></li><li><span style="background:rgba(3, 135, 102, 0.2)">确定恢复的终点</span>：log中记录的每个block的字节空间，找没满的那个</li><li>按照日志的内容扫描，checkpoint_lsn之后的redo日志进行页面恢复</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-48-21-01cd0d0b2e092c882664a466bcf99524-20240613114821-7bcab8.png" alt="image.png"></p><ol><li>同一个页面的redo log在同一个槽里</li><li>同一个页面的redo log按生成时间顺序排序，保证恢复时操作有序<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F13%2F11-49-43-aa6473879d1a124f8bb90c1615cbc457-20240613114942-2017df.png" alt="image.png"></li></ol><h2 id="3-2-Undo日志"><a href="#3-2-Undo日志" class="headerlink" title="3.2. Undo日志"></a>3.2. Undo日志</h2><p>是Redo操作的子集</p><ol><li>事务原子性都是用日志保证</li><li>对每一条记录进行改动的时候，都需要留一手<ol><li>INSERT，记录主键，rollback就删除主键</li><li>DELET，记录内容，rollback就恢复记录</li><li>UPDATE，记录内容，rollback就恢复记录</li></ol></li></ol><h2 id="3-3-更一般的恢复"><a href="#3-3-更一般的恢复" class="headerlink" title="3.3. 更一般的恢复"></a>3.3. 更一般的恢复</h2><ol><li><strong>预写日志(Write-Ahead-Log, WAL)</strong> ，也叫提交日志(commit log)<ol><li>允许页缓存将页进行缓存的时候，保留数据库可持久性语义</li><li><span style="background:rgba(3, 135, 102, 0.2)">事务的提交，以日志写在磁盘上为结束</span>，而不是事务修改的脏页写到磁盘上</li><li>当发生崩溃时，数据库可以从日志重建内容</li></ol></li><li>日志是追加还是原地<ol><li>WAL是<span style="background:rgba(3, 135, 102, 0.2)">仅追加</span>，已写入内容不变，<span style="background:rgba(3, 135, 102, 0.2)">顺序写入</span></li><li>安全访问写入边界之前的内容，并在结尾增加新的日志</li></ol></li><li>日志的语义要求：<ol><li>日志序列号LSN，唯一，递增，内部计数器或时间戳</li><li>强制刷盘操作，事务管理器，页缓存触发</li><li>WAL作为事务结束标准</li></ol></li></ol><ul><li>每次换出页都刷写磁盘，性能可能会更差，解决⽅案是？<ul><li>独立后台进程循环刷写（PostgreSQL的后台刷写器）以及定期checkpoint刷写</li></ul></li></ul><h2 id="3-4-操作日志和复制日志"><a href="#3-4-操作日志和复制日志" class="headerlink" title="3.4. 操作日志和复制日志"></a>3.4. 操作日志和复制日志</h2><ul><li>影子页（shadow paging）——写时复制（copy-on-write）<ul><li>新更改的内容被存放在一个新的、未发布的影子页</li><li>并通过指针翻转使其可见，从旧页切换到包含更新内容的新页</li></ul></li><li>数据日志（保存对完整页状态或字节级的更改，物理日志）</li><li>操作日志（保存在当前状态上执行的操作）</li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>04-B树结构的物理实现</title>
    <link href="http://example.com/posts/743a9869/"/>
    <id>http://example.com/posts/743a9869/</id>
    <published>2024-04-01T05:04:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二进制编码"><a href="#1-二进制编码" class="headerlink" title="1. 二进制编码"></a>1. 二进制编码</h1><ul><li>固定大小，编解码使用相同的字节序</li></ul><p>大端：高位在低字节，符合人类习惯<br>小端：高位在高字节，加法运算方便</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F01%2F14-10-33-387d6897a375b5a1ccbe633784039722-32bit-Endianess-d4424d.svg" alt="32bit-Endianess.svg"></p><p><a class="link" href="https://stackoverflow.com/questions/30074492/what-is-the-difference-between-utf8mb4-and-utf8-charsets-in-mysql">encoding - What is the difference between utf8mb4 and utf8 charsets in MySQL? - Stack Overflow <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h1 id="2-数据库文件物理组织形式通用原理"><a href="#2-数据库文件物理组织形式通用原理" class="headerlink" title="2. 数据库文件物理组织形式通用原理"></a>2. 数据库文件物理组织形式通用原理</h1><h2 id="2-1-确定寻址方式"><a href="#2-1-确定寻址方式" class="headerlink" title="2.1. 确定寻址方式"></a>2.1. 确定寻址方式</h2><ol><li>文件拆分成大小相同的页(page)，单个块(block)或连续块(multiple block)组成</li><li>相同大小的page，目的是简化读取和写入访问，按页写入，从内存写到磁盘</li></ol><p>数据存储结构一般分为两类：<strong>原地更新</strong>、<strong>仅追加</strong>通常都是按照页进行组织。</p><p>数据库的表结构一般是固定的，指定字段的数量、顺序和类型。<br>元数据放在page的头部。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F20-12-08-d66b0367b4d8a27d9d23bce6d03cba6f-20240612201208-fd4035.png" alt="image.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F20-14-15-87e5eb8484d6660f84d04e093f5fb81f-20240612201415-7f76fc.png" alt="image.png"></p><h2 id="2-2-定长：页的结构"><a href="#2-2-定长：页的结构" class="headerlink" title="2.2. 定长：页的结构"></a>2.2. 定长：页的结构</h2><p>顺序的(key,value,pointer)</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F20-13-18-8006f20090056cf53fec6fcd49367575-20240612201317-d1e43c.png" alt="image.png"></p><h2 id="2-3-变长"><a href="#2-3-变长" class="headerlink" title="2.3. 变长"></a>2.3. 变长</h2><h3 id="2-3-1-分槽页（slotted-page）"><a href="#2-3-1-分槽页（slotted-page）" class="headerlink" title="2.3.1. 分槽页（slotted page）"></a>2.3.1. 分槽页（slotted page）</h3><ul><li><p>前面的<strong>指针</strong>按顺序，后面具体存值的<strong>单元格</strong>不按顺序（从后往前放，两块区域相遇说明放满了）</p></li><li><p>实现了：</p><ol><li>最小开销：唯一的<span style="background:rgba(3, 135, 102, 0.2)">额外开销是指针</span></li><li>空间回收：页的碎片整理和重写</li><li>动态布局：外部只能通过page id引用，确切位置由页内决定</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F01%2F14-37-23-53fecd9430ae797f555bb6f9ed36eeed-20240401143722-fdacc7.png" alt="image.png"></p><h3 id="2-3-2-分页槽的单元格布局（Cell-Layout）"><a href="#2-3-2-分页槽的单元格布局（Cell-Layout）" class="headerlink" title="2.3.2. 分页槽的单元格布局（Cell Layout）"></a>2.3.2. 分页槽的单元格布局（Cell Layout）</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F20-27-30-893362a930ab99fc0347850d6eedb2c9-20240612202730-3d356b.png" alt="image.png"></p><h3 id="2-3-3-管理变长数据-del-modify"><a href="#2-3-3-管理变长数据-del-modify" class="headerlink" title="2.3.3. 管理变长数据(del/modify)"></a>2.3.3. 管理变长数据(del/modify)</h3><p>构建free block，并指向第一个空闲块的指针保存在页头部，并保存可用字节数</p><ul><li>使用空闲块的策略<ol><li>首次适配优先：找到第一个适配的空闲块</li><li>最佳适配优先：找到一个剩余段最小的空闲块</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F20-19-05-2ea1b5bcc690d709779eefd4c91340dc-20240612201905-95e39b.png" alt="image.png"></p><h2 id="2-4-版本"><a href="#2-4-版本" class="headerlink" title="2.4. 版本"></a>2.4. 版本</h2><ol><li>文件名带版本前缀</li><li>版本使用专门文件存储，postgreSQL存在PG_VERSION</li><li>直接存在每一个具体文件（索引）的头部，头部按照不变式编码</li></ol><h2 id="2-5-页头"><a href="#2-5-页头" class="headerlink" title="2.5. 页头"></a>2.5. 页头</h2><ul><li><p>保存关于用于页定位，维护和优化的信息。</p><ul><li>包括——页内容和布局的标志位、单元格数量、空闲空间的上界下界的偏移量以及其他</li><li>PostgreSQL——页大小和布局版本</li><li>MySQL InnoDB——记录总数、层数和其他一些与实现相关的值</li><li>SQLite ——单元格的数量和最右指针</li></ul></li><li><p><strong>Magic Numbers</strong>: 多字节的常量数值</p><ul><li>标志：后面是一个page</li><li>标识：指定页的类型或者标识其版本</li><li>意义：验证页加载和对齐是否正确</li></ul></li></ul><h2 id="2-6-同级指针-Sibling-Links"><a href="#2-6-同级指针-Sibling-Links" class="headerlink" title="2.6. 同级指针 Sibling Links"></a>2.6. 同级指针 Sibling Links</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F08%2F14-19-55-3ded1085ea39deed8b13dd6b116987ec-20240408141954-b00a68.png" alt="image.png"></p><h2 id="2-7-最右指针（Rightmost-Pointers）"><a href="#2-7-最右指针（Rightmost-Pointers）" class="headerlink" title="2.7. 最右指针（Rightmost Pointers）"></a>2.7. 最右指针（Rightmost Pointers）</h2><ul><li>B 树拆分子树并进行遍历，指向子页的指针总比键的个数多一个（指针 N+1）<ul><li>最右指针单独存放，其他键值+指针匹配存放</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F08%2F14-23-54-71b7ba4f71f606dd64f91a4f800891f6-20240408142353-792c97.png" alt="image.png"></p><ul><li>拆分后追加到其父节点上，则必须对最右侧的子指针重新赋值<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F20-33-06-ca3b040e81454670b7d484429b5d17aa-20240612203306-4959ba.png" alt="image.png"></li></ul><h2 id="2-8-节点高键-High-Keys"><a href="#2-8-节点高键-High-Keys" class="headerlink" title="2.8. 节点高键 High Keys"></a>2.8. 节点高键 High Keys</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F08%2F14-20-18-930ed76ed4fdd7366bf7623ad6e44c66-20240408142017-0f56f6.png" alt="image.png"></p><h2 id="2-9-溢出页-Overflow-Pages"><a href="#2-9-溢出页-Overflow-Pages" class="headerlink" title="2.9. 溢出页 Overflow Pages"></a>2.9. 溢出页 Overflow Pages</h2><p>节点大小和树的扇出是固定的 ，不会动态改变</p><p>溢出页在B树上没有限制，但是在基本表上有限制</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F08%2F14-20-31-6efe7dcdcd1680f5c18b45db161603b4-20240408142031-428db6.png" alt="image.png"></p><h2 id="2-10-二分搜索"><a href="#2-10-二分搜索" class="headerlink" title="2.10. 二分搜索"></a>2.10. 二分搜索</h2><p>带间接指针的⼆分搜索（灰⾊为要搜索 的数据，虚线是通过指针进⾏⼆分搜索， 实线是跟随指针的访问动作</p><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F08%2F14-22-08-359bdb6044af95bb52af6b10a2dfa1f7-20240408142208-e35f02.png" alt="image.png"></p><h2 id="2-11-分裂与合并"><a href="#2-11-分裂与合并" class="headerlink" title="2.11. 分裂与合并"></a>2.11. 分裂与合并</h2><ul><li>分裂与合并都从叶节点发起，向上传递<ul><li><strong>需要一条从叶节点返回跟节点的路径</strong></li></ul></li><li>实现方式：<ol><li>功能上实现：用一个栈记录路径</li><li>结构上实现：在页头里放一个指向父节点的指针的字段(引入冗余需要保证一致性)</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F06%2F12%2F20-47-15-e5e3fa0b1a9cc4cefeda107a69ce30d9-20240612204715-137790.png" alt="image.png"></p><h2 id="2-12-再平衡"><a href="#2-12-再平衡" class="headerlink" title="2.12. 再平衡"></a>2.12. 再平衡</h2><ul><li><p>为了推迟分裂，减少频繁的分裂和合并。</p></li><li><p>再平衡</p><ol><li>提高平均占用率</li><li>但需要额外跟踪和平衡</li><li>更高的利用率意味着更高效的搜索</li></ol></li></ul><h2 id="2-13-右侧追加"><a href="#2-13-右侧追加" class="headerlink" title="2.13. 右侧追加"></a>2.13. 右侧追加</h2><p>直接往后延</p><ul><li><p>自增数值作为主索引的优势在优化方面</p><ul><li>所有的插入都在所有的末尾（最右边的叶子），大量的分裂集中在每层的最右边</li></ul></li><li><p>特征，在非自增数值做主索引中应用</p><ul><li>批量加载，重新构建（批处理，自下而上构建树，按层写入）</li><li>不可变B+树</li></ul></li></ul><h2 id="2-14-压缩"><a href="#2-14-压缩" class="headerlink" title="2.14. 压缩"></a>2.14. 压缩</h2><p>本质也是一种平衡，访问速度vs压缩率</p><ul><li>不同粒度下的压缩<ol><li>文件压缩，应用在较小的文件</li><li>按页压缩数据<ul><li>可能会导致跨页读取，增加IO次数</li></ul></li><li>按记录行/列压缩<ul><li>对每个行都要解压缩</li></ul></li></ol></li><li>压缩算法选择的基本逻辑<ol><li>压缩比、性能和内存开销</li><li>指标：内存开销、压缩性能、解压性能、压缩比</li></ol></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F08%2F14-08-10-b103fe84da725d38ebc062245a6477ac-20240408140809-00ac13.png" alt="image.png"></p><h2 id="2-15-维护"><a href="#2-15-维护" class="headerlink" title="2.15. 维护"></a>2.15. 维护</h2><ul><li>一个软件系统，除了面向用户的操作之外，还有面向系统本身的操作<ul><li>维护存储的完整性、回收空间、减少开销和维持Page的有序</li><li>后台执行，批处理</li></ul></li></ul><h3 id="2-15-1-删除"><a href="#2-15-1-删除" class="headerlink" title="2.15.1. 删除"></a>2.15.1. 删除</h3><ul><li>基本操作：<ol><li>填空</li><li>无法寻址<br><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F04%2F08%2F14-16-09-b8a5611f53c4f7fa7566423fac028a05-20240408141608-bff93f.png" alt="image.png"></li></ol></li></ul><h3 id="2-15-2-更新和删除碎片"><a href="#2-15-2-更新和删除碎片" class="headerlink" title="2.15.2. 更新和删除碎片"></a>2.15.2. 更新和删除碎片</h3><ul><li>填空null或删除偏移量<ol><li>删除偏移量是最常使用的方式，体会一下Page为什么要设置偏移量（分离）</li><li>有些数据库又专门的垃圾收集功能，将删除和更新的单元格留在原处，以便进行多版本控制</li><li>事务完成后，ghost record的数据结构被回收</li></ol></li><li>碎片化单元格（fragmented）需要被碎片整理<ol><li>重写页面，更新操作对叶节点页面也可以更新偏移量，不重写页面</li><li>碎片整理（compaction、vacuum……）</li><li>更新偏移量、移动新位置、可用磁盘页id进入空闲页列表（freelist）</li></ol></li></ul><h2 id="2-16-总结"><a href="#2-16-总结" class="headerlink" title="2.16. 总结"></a>2.16. 总结</h2><ol><li>静态：页头、最右指针、高键、溢出页</li><li>动态：遍历、间接指针二分搜索、父指针或导航结构</li><li>维护：再平衡、右侧追加、批量加载、垃圾收集</li></ol><p>密集存储：查询方便<br>分散存储：写方便</p><p>堆文件</p><h1 id="3-数据库具体文件的物理组织形式"><a href="#3-数据库具体文件的物理组织形式" class="headerlink" title="3. 数据库具体文件的物理组织形式"></a>3. 数据库具体文件的物理组织形式</h1><p><strong>本质都是树</strong>，结构相同、但取值以及不同动态使用算法的树</p><ol><li>顺序文件(索引，B+树等)</li><li>散列文件（hash）<ul><li>纯随机，没有顺序</li></ul></li><li>随机文件（堆文件，基本表结构）</li><li>聚簇文件（融合性文件）<ul><li>按照一定程度的顺序</li></ul></li></ol><p>结构优化<br>算法优化</p><h1 id="4-IOT"><a href="#4-IOT" class="headerlink" title="4. IOT"></a>4. IOT</h1><p>Index-orginzed Table</p><p>记录强制排序</p><h1 id="5-数据自动分组-grouping"><a href="#5-数据自动分组-grouping" class="headerlink" title="5. 数据自动分组(grouping)"></a>5. 数据自动分组(grouping)</h1><ul><li><p><strong>分区(Partition)</strong> 也是一种数据分组的方式</p><ul><li><strong>把逻辑上的一张基本表分到不同的物理文件上，底层是多张物理表</strong></li></ul></li><li><p>优点</p><ul><li>提高并发性和并行性</li><li>从而增强系统架构的伸缩性</li></ul></li><li><p>面对两大问题</p><ol><li>管理问题（备份和恢复）</li><li>数据量巨大的表，B+树的索引失效，非聚簇索引的大量随机I/O问题</li></ol></li><li><p>应对策略</p><ol><li>全量扫描数据，不需要任何索引</li><li>索引数据，并分离出热点数据</li></ol></li></ul><h2 id="5-1-循环分区"><a href="#5-1-循环分区" class="headerlink" title="5.1. 循环分区"></a>5.1. 循环分区</h2><p>如滑动窗口</p><ul><li>不受数据影响的内部机制<ol><li>分区定义为各个磁盘的存储区域</li><li>可以看作是随意散布数据的机制</li><li>保持更改带来的磁盘I/O操作的平衡</li></ol></li></ul><h2 id="5-2-数据驱动分区"><a href="#5-2-数据驱动分区" class="headerlink" title="5.2. 数据驱动分区"></a>5.2. 数据驱动分区</h2><ul><li>根据一个或多个字段的值来定义分区<ul><li>一般叫分区视图（partitioned view），而MYSQL老版本称为（merge table）</li></ul></li><li>实现方式<ol><li>哈希分区</li><li>范围分区/键值分区</li><li>列表分区：把记录的某些字段放在某些分区，把热点和非热点分开，每个分区会额外复制主键</li></ol></li></ul><h2 id="5-3-分区表的底层实现原理"><a href="#5-3-分区表的底层实现原理" class="headerlink" title="5.3. 分区表的底层实现原理"></a>5.3. 分区表的底层实现原理</h2><p>分区表由多个相关的底层表实现<br>对<span style="background:rgba(3, 135, 102, 0.2)">存储引擎</span>来说，底层表和普通表没有任何区别<br><span style="background:rgba(3, 135, 102, 0.2)">分区表的索引</span>是在底层表上各自加上一个完全相同的索引<br>操作时都有一个<span style="background:rgba(3, 135, 102, 0.2)">分区层打开并锁住所有底层表</span>的过程</p><h2 id="5-4-分区的问题"><a href="#5-4-分区的问题" class="headerlink" title="5.4. 分区的问题"></a>5.4. 分区的问题</h2><ol><li><p>NULL值会使分区过滤无效（PATITION by RANGE COLUMN（order_date））</p></li><li><p>分区列和索引列不匹配（没有索引，或关联查询时关联条件不匹配索引）</p></li><li><p>选择分区的成本较高（分区范围的成本需要注意）</p></li><li><p>打开并锁住所有底层表的成本可能很高（开销和分区类型无关，主键查找单行会带来明显开销）</p></li><li><p>维护分区成本高</p></li><li><p>如果不走分区键，很容易造成全表锁或多次相同索引查询。</p></li><li><p>很难实现分区中关联查询。</p></li><li><p>索引的复制导致更新复杂，分区层锁定问题。</p></li><li><p>分区表，隐藏复杂，使得工程师不可控。</p></li></ol><h2 id="5-5-数据分区的最佳方法"><a href="#5-5-数据分区的最佳方法" class="headerlink" title="5.5. 数据分区的最佳方法"></a>5.5. 数据分区的最佳方法</h2><ol><li>partition key尽量均匀分布</li><li>partition key不能改动</li></ol><h1 id="6-分区、分表、分库"><a href="#6-分区、分表、分库" class="headerlink" title="6. 分区、分表、分库"></a>6. 分区、分表、分库</h1><p>分区和分表的目的都是减少数据库的负担，提高表的增删改查效率。<br>分区只是一张表中的数据的存储位置发生改变，分表是将一张表分成多张表<br>分库主要目的是为突破单节点数据库服务器的 I/O 能力限制</p><h2 id="6-1-分区-Partitioning"><a href="#6-1-分区-Partitioning" class="headerlink" title="6.1. 分区 Partitioning"></a>6.1. 分区 Partitioning</h2><ul><li>把一张表分成N个区块，逻辑上是一张表，但底层是N个物理区块组成</li><li>原因：处理大型表，提高查询效率</li><li>问题：<ol><li>分区维护成本高，尤其是数据分布不均匀的时候</li><li>NULL值和分区键的选择不当可能导致分区过滤无效</li><li>分区列和索引列不匹配，全表扫描</li><li>选择分区的成本可能很高</li><li>打开并锁住所有底层表的成本可能很高</li><li>索引维护复杂</li><li>不能解决并发问题</li></ol></li></ul><h2 id="6-2-分表（手搓分区）"><a href="#6-2-分表（手搓分区）" class="headerlink" title="6.2. 分表（手搓分区）"></a>6.2. 分表（手搓分区）</h2><ul><li>把一张表按照一定规则分解成N个具有独立空间的实体表</li><li>系统读写时需要根据定义好的规则得到对应的字表明，然后操作它</li><li>解决的问题：<ol><li>插入数据需要重建的索引减少</li><li>在应用层完成表的选择，读写锁影响的数据量少(不用锁住所有表再选择)</li><li>分表后单表的并发能力提高了，磁盘I/O性能也提高了，写操作效率提高了</li><li>数据分布在不同的文件，磁盘I/O性能提高</li></ol></li><li>问题：<ol><li>多张表的事务处理和回滚比一张逻辑表复杂得多</li><li>需要业务系统配合迁移升级，工作量大</li></ol></li></ul><h2 id="6-3-分库"><a href="#6-3-分库" class="headerlink" title="6.3. 分库"></a>6.3. 分库</h2><ul><li><p>解决单个数据节点访问的I/O能力上限，解决数据库扩展性问题</p></li><li><p>问题：</p><ol><li>事务的支持，分库分表，就变成了分布式事务</li><li>join时跨库，跨表的问题</li><li>分库分表，读写分离使用了分布式，分布式为了保证强一致性，必然带来延迟，导致性能降低，系统的复杂度变高</li></ol></li><li><p>垂直拆分</p><ul><li>将不存在关联关系或者需要join的表可以放在不同的数据库不同的服务器中</li><li><span style="background:rgba(3, 135, 102, 0.2)">按照业务垂直划分</span>。比如：可以按照业务分为资金、会员、订单三个数据库</li><li>需要解决的问题：跨数据库的事务、join查询等问题</li></ul></li><li><p>水平拆分</p><ul><li>例如，大部分的站点。数据都是和用户有关，那么可以根据用户，将数据按照用户水平拆分</li><li><span style="background:rgba(3, 135, 102, 0.2)">按照规则划分</span>，一般水平分库是在垂直分库之后的。比如每天处理的订单数量是海量的，可以按照一定的规则水平划分</li><li>需要解决的问题：数据路由、组装</li></ul></li><li><p>读写分离</p><ul><li>对于<span style="background:rgba(3, 135, 102, 0.2)">时效性不高</span>的数据，可以通过读写分离缓解数据库压力</li><li>需要解决的问题：在业务上区分哪些业务上是允许一定<span style="background:rgba(3, 135, 102, 0.2)">时间延迟</span>的，以及<span style="background:rgba(3, 135, 102, 0.2)">数据同步</span>问题</li></ul></li></ul><h1 id="7-全局ID生成算法"><a href="#7-全局ID生成算法" class="headerlink" title="7. 全局ID生成算法"></a>7. 全局ID生成算法</h1><ol><li>自动增长列<ol><li>自带功能，有序，性能不错</li></ol></li><li>UUID (128位)</li><li>COMB (组合)</li><li>Snowflake (雪花)</li></ol>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/categories/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_数据库开发" scheme="http://example.com/tags/2024-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>03-Programming Prerequisite</title>
    <link href="http://example.com/posts/30ede758/"/>
    <id>http://example.com/posts/30ede758/</id>
    <published>2024-03-25T02:03:00.000Z</published>
    <updated>2024-06-19T06:56:34.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Programming-Language"><a href="#1-Programming-Language" class="headerlink" title="1. Programming Language"></a>1. Programming Language</h1><ul><li>High-level Language<ul><li>C/C++, Java, Fortran…</li><li>ELF binary format</li><li>binary code: 本地二进制码，直接对应机器指令</li></ul></li><li>Script <ul><li>Shell: sh/bash, csh, ksh</li><li>Perl, Python, tcl/tk, sed, awk</li></ul></li></ul><h1 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://chillcharlie-img.oss-cn-hangzhou.aliyuncs.com/image%2F2024%2F03%2F25%2F11-15-22-efb7064e12a9cbfd0fdedef49bcc392a-20240325111521-19928c.png" alt="image.png"></p><ul><li><p>预处理</p><ul><li>把预处理指令处理掉（<code>#include</code>, <code>#if</code>,<code>#define</code>…）</li><li><code>#include</code>把目标文件粘贴到include的位置</li><li><code>#define</code>字符串替换</li></ul></li><li><p>链接：保证可执行文件里的二进制码是完整的</p><ul><li>编译器每次只编译一个文件，链接实现了把这些单独的文件合成一个文件</li></ul></li><li><p>静态库</p><ul><li>在编译时就把库文件放到可执行文件里</li><li><code>.a</code> in Linux ,<code>.lib</code> in Windows</li></ul></li><li><p>动态库</p><ul><li>运行时去找库文件，用完可以释放掉减少内存占用，有利于打补丁</li><li><code>.so</code> in Linux, <code>.dll</code> in Windows</li></ul></li></ul><h1 id="3-其它语言"><a href="#3-其它语言" class="headerlink" title="3. 其它语言"></a>3. 其它语言</h1><ul><li>Java<ul><li>只有编译+解释执行</li><li>没有链接的选项</li><li>只有动态库</li></ul></li><li>.Net平台：VC++.net, c#, VB.net<ul><li>编译成中间语言</li></ul></li><li>VC++及Delphi等（一般称为Win编程）<ul><li>编译成本地二进制码</li></ul></li></ul><h1 id="4-GCC"><a href="#4-GCC" class="headerlink" title="4. GCC"></a>4. GCC</h1><h2 id="4-1-选项"><a href="#4-1-选项" class="headerlink" title="4.1. 选项"></a>4.1. 选项</h2><p>gcc的参数和llvm差不多</p><ul><li><p>只编译: <code>gcc -c test.c -o test.obj</code>， 输出<code>.obj</code></p></li><li><p>只链接<code>gcc test.obj -o test</code>，输出可执行文件</p></li><li><p>编译链接一起做：<code>gcc test.c -o test</code>，</p></li><li><p>Usage:</p><ul><li>gcc [options] [filename]</li></ul></li><li><p>Basic options:</p><ol><li>-E: 只对源程序进行预处理(调用cpp预处理器)</li><li>-S: 只对源程序进行预处理、编译</li><li>-c: 执行预处理、编译、汇编, 而不链接</li><li>-o output_file: 指定输出文件名</li><li><strong>-g</strong>: 产生<strong>调试</strong>工具必需的符号信息</li><li>-O/On: 在程序编译、链接过程中进行优化处理<ol><li>如果开优化就无法调试，因为优化后代码与源代码无法直接对应</li><li>在一台机器上编译，无法直接复制到另一台机器上调试</li></ol></li><li>-Wall: 显示所有的警告信息</li><li>-Idir: 指定<strong>额外的头文件</strong>搜索路径</li><li>-Ldir: 指定<strong>额外的库文件</strong>搜索路径</li><li>-Iname: 链接时搜索指定的<strong>库文件</strong></li><li>-DMACRO=[=DEFN]: 定义MACRO宏</li></ol></li></ul><h2 id="4-2-文件扩展名"><a href="#4-2-文件扩展名" class="headerlink" title="4.2. 文件扩展名"></a>4.2. 文件扩展名</h2><table><thead><tr><th>扩展名</th><th>解释</th></tr></thead><tbody><tr><td>.c</td><td>C source code which must be preprocessed<br>使用C语言编译器</td></tr><tr><td>.C .cc .cp .cpp .CPP .c++ .cxx</td><td>C++ source code which must be preprocessed<br>使用C++编译器</td></tr><tr><td>.i</td><td>C source code which should not be preprocessed</td></tr><tr><td>.ii</td><td>C++ source code which should not be preprocessed</td></tr><tr><td>.h</td><td>C or C++ header file to be turned into a precompiled header</td></tr><tr><td>.H .hh</td><td>C++ header file to be turned into a precompiled header</td></tr><tr><td>.s</td><td>Assembler code</td></tr><tr><td>.S</td><td>Assembler code which must be preprocessed</td></tr><tr><td>.o</td><td>Object file</td></tr><tr><td>.a</td><td>Static library file (archive file)</td></tr><tr><td>.so</td><td>Dynamic library file (shared object)</td></tr></tbody></table><h1 id="5-GDB"><a href="#5-GDB" class="headerlink" title="5. GDB"></a>5. GDB</h1><ul><li>GDB: GNU Debug<ol><li>设置断点</li><li>监视变量值</li><li>但不执行</li><li>修改变量值</li></ol></li></ul><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>file</td><td>打开要调试的文件</td></tr><tr><td>break/tbreak</td><td>设置断点，可以是行号、函数名及地址(以*开头)<br> tbreak: 设置临时断点</td></tr><tr><td>run</td><td>执行当前调试的程序</td></tr><tr><td>list</td><td>执行当前调试的程序</td></tr><tr><td>next</td><td>执行一条语句但不进入函数内部</td></tr><tr><td>step</td><td>执行一条语句，是函数则进入函数内部</td></tr><tr><td>display</td><td>显示表达式的值</td></tr><tr><td>print</td><td>临时显示表达式的值</td></tr><tr><td>kill</td><td>中止正在调试的程序</td></tr><tr><td>quit</td><td>退出gdb</td></tr><tr><td>shell</td><td>不退出gdb就执行shell命令</td></tr><tr><td>make</td><td>不退出gdb就执行make</td></tr></tbody></table><h1 id="6-make和makefile"><a href="#6-make和makefile" class="headerlink" title="6. make和makefile"></a>6. make和makefile</h1><ol><li>makefile<ul><li>描述模块间的依赖关系，<strong>定义工程的编译规则</strong>;</li><li>记录实际编译的命令的脚本；</li><li><strong>自动支持增量编译</strong></li><li>编译开源软件时一般从./configure或cmake生成</li></ul></li><li>make<ul><li>根据makefile对程序进行管理和维护；</li><li>判断被维护文件的时序关系</li><li>make的时候用普通用户(会产生很多中间文件，如果用root会导致没有删除权限)，make install可能需要root权限(把生成的文件复制到系统目录)</li></ul></li></ol><h2 id="6-1-makefile格式"><a href="#6-1-makefile格式" class="headerlink" title="6.1. makefile格式"></a>6.1. makefile格式</h2><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">command</span><br></pre></td></tr></table></figure></div><ol><li>target是一个目标文件，可以是Object File，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令。（可以是任意的Shell命令）<ul><li><strong>命令前面必须是Tab，不能是空格;命令和目标之间不能有空行</strong></li></ul></li></ol><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello : main.o kbd.o </span><br><span class="line">gcc -o hello main.o kbd.o </span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">cc -c kbd.c </span><br><span class="line">clean :</span><br><span class="line">rm edit main.o kbd.o </span><br></pre></td></tr></table></figure></div><p>赋值号两边可以有空格</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TOPDIR = ../</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(TOPDIR)</span>RuIes.mak</span><br><span class="line">EXTRA LIBS</span><br><span class="line">EXEC =</span><br><span class="line">OBJS = hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(EXEC)</span></span></span><br><span class="line"><span class="variable">$(EXEC)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line"><span class="variable">$(EXEC)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -f <span class="variable">$(EXEC)</span> *.elf *.gdb</span><br></pre></td></tr></table></figure></div><p>./configure<br>make<br>make install</p><p>make uninstall<br>make clean<br>make distclean 回到刚刚解压的状态</p><h2 id="6-2-makefile执行次序"><a href="#6-2-makefile执行次序" class="headerlink" title="6.2. makefile执行次序"></a>6.2. makefile执行次序</h2><ol><li>make会在当前目录下找名字叫“Makefile” 或 “makefile” 的文件。</li><li>查找文件中的<strong>第一个目标文件（target）</strong>，举例中的hello</li><li>如果hello文件不存在，或是hello所依赖的文件修改时间要 比hello新，就会执行后面所定义的命令来生成hello文件。</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文 件中找目标为.o文件的依赖性，如果找到则再根据那一个 规则生成.o文件。（类似一个堆栈的过程）</li><li>make根据.o文件的规则生成 .o 文件，然后再用 .o 文件生 成hello文件。</li></ol><h2 id="6-3-作用"><a href="#6-3-作用" class="headerlink" title="6.3. 作用"></a>6.3. 作用</h2><ol><li>定义整个工程的编译规则<ul><li>一个工程中的源文件不计数，其按类型、功能、模块 分别放在若干个目录中，makefile定义了一系列的规 则来指定，哪些文件需要先编译，哪些文件需要后编 译，哪些文件需要重新编译，甚至于进行更复杂的功 能操作 。</li></ul></li><li>自动化编译<ul><li>只需要一个make命令，整个工程完全自动编译 ； make是一个命令工具，是一个解释makefile中指令的命令工具；</li></ul></li></ol><h2 id="6-4-命令"><a href="#6-4-命令" class="headerlink" title="6.4. 命令"></a>6.4. 命令</h2><ul><li>make命令格式：make [-f Makefile] [option] [target]</li></ul><h2 id="6-5-伪目标"><a href="#6-5-伪目标" class="headerlink" title="6.5. 伪目标"></a>6.5. 伪目标</h2><p>clean,install…</p><ol><li>不是一个文件，只是标签，所以 make无法生成它的依赖关系和决定它是否要执行，<strong>只能通过显示地指明这个“目标”才能让其生效</strong></li><li>“伪目标”的取名<strong>不能和文件名重名</strong></li><li>为了避免和文件重名的这种情况，可以使用一个特殊 的标记“.PHONY”来显示地指明一个目标是“伪目标 ”，向make说明，不管是否有这个文件，这个目标就 是“伪目标”</li><li>伪目标一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。</li><li>伪目标<strong>同样可以作为“默认目标”</strong>，只要将其放在第一个</li></ol><h2 id="6-6-多目标"><a href="#6-6-多目标" class="headerlink" title="6.6. 多目标"></a>6.6. 多目标</h2><p>当多个目标同时依赖于一个文件，并且其生成的命令大体类 似，可以使用一个自动化变量“$@”表示着目前规则中所有的目标的集合。</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span> </span><br></pre></td></tr></table></figure></div><p>等价于：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure></div><h2 id="6-7-预定义变量"><a href="#6-7-预定义变量" class="headerlink" title="6.7. 预定义变量"></a>6.7. 预定义变量</h2><ol><li>$&lt; 第一个依赖文件的名称</li><li>$? 所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li>$+ 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li>$* 不包括扩展名的目标文件名称</li><li>$@目标的完整名称</li><li>$%如果目标是归档成员，则该变量表示目标的归档成员名称</li></ol><h2 id="6-8-多目标扩展"><a href="#6-8-多目标扩展" class="headerlink" title="6.8. 多目标扩展"></a>6.8. 多目标扩展</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">&lt;commands&gt;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div><p>等价于：</p><div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure></div><ol><li>目标从$object中获取</li><li>“%.o”表明要所有以“.o”结尾的目标，即“foo.o bar.o”，就是变量 $object集合的模式</li><li>依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其 加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c</li></ol><h2 id="6-9-函数"><a href="#6-9-函数" class="headerlink" title="6.9. 函数"></a>6.9. 函数</h2><ul><li>调用语法<ul><li><code>$(&lt;function&gt; &lt;arguments&gt;)</code></li><li><code>${&lt;function&gt; &lt;arguments&gt;}</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">false</summary>
    
    
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/categories/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="课程" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="2024_Spring_Linux系统编程" scheme="http://example.com/tags/2024-Spring-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
